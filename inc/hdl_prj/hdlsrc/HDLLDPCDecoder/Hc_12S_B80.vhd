-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLLDPCDecoder/Hc_12S_B80.vhd
-- Created: 2024-08-10 15:27:55
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Hc_12S_B80
-- Source Path: HDLLDPCDecoder/reduced_ldpc_rx_HDL_resource_test/Hc_12S_B80
-- Hierarchy Level: 1
-- Model version: 1.11
-- 
-- LDPC Decoder
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY Hc_12S_B80 IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
        in1_start                         :   IN    std_logic;
        in1_end                           :   IN    std_logic;
        in1_valid                         :   IN    std_logic;
        out0                              :   OUT   std_logic;
        out1_start                        :   OUT   std_logic;
        out1_end                          :   OUT   std_logic;
        out1_valid                        :   OUT   std_logic;
        out2                              :   OUT   std_logic
        );
END Hc_12S_B80;


ARCHITECTURE rtl OF Hc_12S_B80 IS

  -- Component Declarations
  COMPONENT CodeParameters
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          data                            :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          start                           :   IN    std_logic;
          end_rsvd                        :   IN    std_logic;
          valid                           :   IN    std_logic;
          reset                           :   OUT   std_logic;  -- ufix1
          datacp                          :   OUT   std_logic_vector(3 DOWNTO 0);  -- sfix4
          validcp                         :   OUT   std_logic;  -- ufix1
          framevalid                      :   OUT   std_logic;  -- ufix1
          endind                          :   OUT   std_logic;  -- ufix1
          nitero                          :   OUT   std_logic_vector(7 DOWNTO 0)  -- ufix8
          );
  END COMPONENT;

  COMPONENT DecoderCore
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          reset                           :   IN    std_logic;  -- ufix1
          data                            :   IN    std_logic_vector(5 DOWNTO 0);  -- sfix6
          valid                           :   IN    std_logic;  -- ufix1
          framevalid                      :   IN    std_logic;  -- ufix1
          endind                          :   IN    std_logic;  -- ufix1
          numiter                         :   IN    std_logic_vector(7 DOWNTO 0);  -- ufix8
          data_1                          :   OUT   std_logic;
          start                           :   OUT   std_logic;
          end_rsvd                        :   OUT   std_logic;
          valid_1                         :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : CodeParameters
    USE ENTITY work.CodeParameters(rtl);

  FOR ALL : DecoderCore
    USE ENTITY work.DecoderCore(rtl);

  -- Signals
  SIGNAL sofVld                           : std_logic;
  SIGNAL in0_signed                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL dataIn                           : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL startIn                          : std_logic;
  SIGNAL endIn                            : std_logic;
  SIGNAL validIn                          : std_logic;
  SIGNAL reset                            : std_logic;  -- ufix1
  SIGNAL dataOut                          : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL valid                            : std_logic;  -- ufix1
  SIGNAL frameValid                       : std_logic;  -- ufix1
  SIGNAL endInd                           : std_logic;  -- ufix1
  SIGNAL niterOut                         : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL dataOut_signed                   : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL dataDTC                          : signed(5 DOWNTO 0);  -- sfix6
  SIGNAL alpha_reg                        : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL endindReg                        : std_logic;  -- ufix1
  SIGNAL dataO                            : std_logic;
  SIGNAL startO                           : std_logic;
  SIGNAL endO                             : std_logic;
  SIGNAL validO                           : std_logic;
  SIGNAL const0                           : std_logic;  -- ufix1
  SIGNAL sofVldNeg                        : std_logic;  -- ufix1
  SIGNAL eofVld                           : std_logic;
  SIGNAL const0Reg                        : std_logic;  -- ufix1
  SIGNAL frame_switch_delay               : std_logic;  -- ufix1
  SIGNAL fValidTmp                        : std_logic;  -- ufix1
  SIGNAL fValidReg                        : std_logic;  -- ufix1
  SIGNAL endVld                           : std_logic;
  SIGNAL fValid                           : std_logic;  -- ufix1
  SIGNAL endTrigger                       : std_logic;  -- ufix1
  SIGNAL endTrigger2                      : std_logic;  -- ufix1
  SIGNAL end_trigger_reg                  : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL endTriggerReg                    : std_logic;  -- ufix1
  SIGNAL vFrame                           : std_logic;  -- ufix1
  SIGNAL countVal                         : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL maxCount                         : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rel_count                        : std_logic;  -- ufix1
  SIGNAL invalid_length_switch_delay      : std_logic;  -- ufix1
  SIGNAL invalidLength                    : std_logic;  -- ufix1
  SIGNAL resetFrame                       : std_logic;  -- ufix1
  SIGNAL validOReg                        : std_logic;
  SIGNAL validout                         : std_logic;
  SIGNAL endOReg                          : std_logic;
  SIGNAL endout                           : std_logic;
  SIGNAL endOutVld                        : std_logic;  -- ufix1
  SIGNAL endOutVldTmp                     : std_logic;  -- ufix1
  SIGNAL endOutVldReg                     : std_logic;  -- ufix1
  SIGNAL invFrame                         : std_logic;  -- ufix1
  SIGNAL nFrameEnb                        : std_logic;  -- ufix1
  SIGNAL nextFrame_switch_delay           : std_logic;  -- ufix1
  SIGNAL nFrameTmp                        : std_logic;  -- ufix1
  SIGNAL nFrame                           : std_logic;  -- ufix1
  SIGNAL zData                            : std_logic;
  SIGNAL decData                          : std_logic;
  SIGNAL dataout_1                        : std_logic;
  SIGNAL startOReg                        : std_logic;
  SIGNAL startout                         : std_logic;

BEGIN
  u_Code_Parameters : CodeParameters
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              data => std_logic_vector(dataIn),  -- sfix4
              start => startIn,
              end_rsvd => endIn,
              valid => validIn,
              reset => reset,  -- ufix1
              datacp => dataOut,  -- sfix4
              validcp => valid,  -- ufix1
              framevalid => frameValid,  -- ufix1
              endind => endInd,  -- ufix1
              nitero => niterOut  -- ufix8
              );

  u_Decoder_Core : DecoderCore
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              reset => reset,  -- ufix1
              data => std_logic_vector(dataDTC),  -- sfix6
              valid => valid,  -- ufix1
              framevalid => frameValid,  -- ufix1
              endind => endindReg,  -- ufix1
              numiter => niterOut,  -- ufix8
              data_1 => dataO,
              start => startO,
              end_rsvd => endO,
              valid_1 => validO
              );

  sofVld <= in1_valid AND in1_start;

  in0_signed <= signed(in0);

  c_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      dataIn <= to_signed(16#0#, 4);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataIn <= in0_signed;
      END IF;
    END IF;
  END PROCESS c_process;


  c_1_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      startIn <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        startIn <= in1_start;
      END IF;
    END IF;
  END PROCESS c_1_process;


  c_2_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      endIn <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endIn <= in1_end;
      END IF;
    END IF;
  END PROCESS c_2_process;


  c_3_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      validIn <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validIn <= in1_valid;
      END IF;
    END IF;
  END PROCESS c_3_process;


  dataOut_signed <= signed(dataOut);

  dataDTC <= resize(dataOut_signed, 6);

  c_4_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      alpha_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        alpha_reg(0) <= endInd;
        alpha_reg(1) <= alpha_reg(0);
      END IF;
    END IF;
  END PROCESS c_4_process;

  endindReg <= alpha_reg(1);

  const0 <= '0';

  sofVldNeg <=  NOT sofVld;

  eofVld <= in1_valid AND in1_end;

  c_5_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      const0Reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND in1_valid = '1' THEN
        const0Reg <= const0;
      END IF;
    END IF;
  END PROCESS c_5_process;


  frame_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      frame_switch_delay <= '1';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF sofVld = '1' THEN
          frame_switch_delay <= '1';
        ELSIF eofVld = '1' THEN
          frame_switch_delay <= const0Reg;
        END IF;
      END IF;
    END IF;
  END PROCESS frame_process;

  
  fValidTmp <= '1' WHEN sofVld = '1' ELSE
      frame_switch_delay;

  c_6_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      fValidReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        fValidReg <= fValidTmp;
      END IF;
    END IF;
  END PROCESS c_6_process;


  endVld <= validIn AND endIn;

  fValid <= fValidReg OR endVld;

  endTrigger <= eofVld AND fValid;

  endTrigger2 <= endTrigger AND sofVldNeg;

  end_trigger_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      end_trigger_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        end_trigger_reg(0) <= endTrigger2;
        end_trigger_reg(1) <= end_trigger_reg(0);
      END IF;
    END IF;
  END PROCESS end_trigger_process;

  endTriggerReg <= end_trigger_reg(1);

  vFrame <= in1_valid AND fValid;

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 1920
  -- Counter for input data length
  Counting_Data_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      countVal <= to_unsigned(16#001#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF sofVld = '1' THEN 
          countVal <= to_unsigned(16#001#, 11);
        ELSIF vFrame = '1' THEN 
          IF countVal >= to_unsigned(16#780#, 11) THEN 
            countVal <= to_unsigned(16#001#, 11);
          ELSE 
            countVal <= countVal + to_unsigned(16#001#, 11);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS Counting_Data_process;


  maxCount <= to_unsigned(16#77F#, 11);

  -- Comparison of counter to max count
  
  rel_count <= '1' WHEN countVal /= maxCount ELSE
      '0';

  invalid_length_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      invalid_length_switch_delay <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF endTriggerReg = '1' THEN
          invalid_length_switch_delay <= '0';
        ELSIF endTrigger2 = '1' THEN
          invalid_length_switch_delay <= rel_count;
        END IF;
      END IF;
    END IF;
  END PROCESS invalid_length_process;

  
  invalidLength <= '0' WHEN endTriggerReg = '1' ELSE
      invalid_length_switch_delay;

  
  validOReg <= validO WHEN resetFrame = '0' ELSE
      const0;

  valid_1_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      validout <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validout <= validOReg;
      END IF;
    END IF;
  END PROCESS valid_1_process;


  
  endOReg <= endO WHEN resetFrame = '0' ELSE
      const0;

  end_rsvd_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      endout <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endout <= endOReg;
      END IF;
    END IF;
  END PROCESS end_rsvd_process;


  endOutVld <= endout AND validout;

  endOutVldTmp <= endOutVld AND sofVldNeg;

  c_7_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      endOutVldReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endOutVldReg <= endOutVldTmp;
      END IF;
    END IF;
  END PROCESS c_7_process;


  invFrame <= endOutVldReg OR invalidLength;

  nFrameEnb <= invFrame AND sofVldNeg;

  nextFrame_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      nextFrame_switch_delay <= '1';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF nFrameEnb = '1' THEN
          nextFrame_switch_delay <= '1';
        ELSIF sofVld = '1' THEN
          nextFrame_switch_delay <= const0Reg;
        END IF;
      END IF;
    END IF;
  END PROCESS nextFrame_process;

  
  nFrameTmp <= '1' WHEN nFrameEnb = '1' ELSE
      nextFrame_switch_delay;

  nFrame <= nFrameTmp OR invFrame;

  resetFrame <= nFrame OR fValid;

  zData <= '0';

  
  decData <= dataO WHEN resetFrame = '0' ELSE
      zData;

  data_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      dataout_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataout_1 <= decData;
      END IF;
    END IF;
  END PROCESS data_process;


  
  startOReg <= startO WHEN resetFrame = '0' ELSE
      const0;

  start_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      startout <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        startout <= startOReg;
      END IF;
    END IF;
  END PROCESS start_process;


  out1_start <= startout;

  out1_end <= endout;

  out1_valid <= validout;

  out0 <= dataout_1;

  out2 <= nFrame;

END rtl;

