-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLDecimator/decimator_ip_src_FIRDecimInteg.vhd
-- Created: 2024-10-01 07:52:33
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: decimator_ip_src_FIRDecimInteg
-- Source Path: HDLDecimator/decimator/FIR Decimator/FIRDecimInteg
-- Hierarchy Level: 2
-- Model version: 1.40
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.decimator_ip_src_decimator_pac.ALL;

ENTITY decimator_ip_src_FIRDecimInteg IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        filterOut                         :   IN    std_logic_vector(24 DOWNTO 0);  -- sfix25_En22
        filterOut_vld                     :   IN    std_logic;
        softReset                         :   IN    std_logic;
        dataOut                           :   OUT   std_logic_vector(11 DOWNTO 0);  -- sfix12_En10
        validOut                          :   OUT   std_logic
        );
END decimator_ip_src_FIRDecimInteg;


ARCHITECTURE rtl OF decimator_ip_src_FIRDecimInteg IS

  -- Signals
  SIGNAL filterOut_signed                 : signed(24 DOWNTO 0);  -- sfix25_En22
  SIGNAL FIRdDecimInteg_state             : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_cnt               : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_integReg          : signed(24 DOWNTO 0);  -- sfix25
  SIGNAL FIRdDecimInteg_integVldReg       : std_logic;
  SIGNAL FIRdDecimInteg_doutReg           : signed(11 DOWNTO 0);  -- sfix12
  SIGNAL FIRdDecimInteg_doutVldReg        : std_logic;
  SIGNAL FIRdDecimInteg_state_next        : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_cnt_next          : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_integReg_next     : signed(24 DOWNTO 0);  -- sfix25_En22
  SIGNAL FIRdDecimInteg_integVldReg_next  : std_logic;
  SIGNAL FIRdDecimInteg_doutReg_next      : signed(11 DOWNTO 0);  -- sfix12_En10
  SIGNAL FIRdDecimInteg_doutVldReg_next   : std_logic;
  SIGNAL dataOut_tmp                      : signed(11 DOWNTO 0);  -- sfix12_En10

BEGIN
  filterOut_signed <= signed(filterOut);

  -- FIRDecimInteg
  FIRdDecimInteg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        FIRdDecimInteg_state <= '0';
        FIRdDecimInteg_integVldReg <= '0';
        FIRdDecimInteg_doutVldReg <= '0';
        FIRdDecimInteg_cnt <= '1';
        FIRdDecimInteg_integReg <= to_signed(16#0000000#, 25);
        FIRdDecimInteg_doutReg <= to_signed(16#000#, 12);
      ELSIF enb = '1' THEN
        IF softReset = '1' THEN
          FIRdDecimInteg_state <= '0';
          FIRdDecimInteg_integVldReg <= '0';
          FIRdDecimInteg_doutVldReg <= '0';
          FIRdDecimInteg_cnt <= '1';
          FIRdDecimInteg_integReg <= to_signed(16#0000000#, 25);
          FIRdDecimInteg_doutReg <= to_signed(16#000#, 12);
        ELSE 
          FIRdDecimInteg_state <= FIRdDecimInteg_state_next;
          FIRdDecimInteg_cnt <= FIRdDecimInteg_cnt_next;
          FIRdDecimInteg_integReg <= FIRdDecimInteg_integReg_next;
          FIRdDecimInteg_integVldReg <= FIRdDecimInteg_integVldReg_next;
          FIRdDecimInteg_doutReg <= FIRdDecimInteg_doutReg_next;
          FIRdDecimInteg_doutVldReg <= FIRdDecimInteg_doutVldReg_next;
        END IF;
      END IF;
    END IF;
  END PROCESS FIRdDecimInteg_process;

  FIRdDecimInteg_output : PROCESS (FIRdDecimInteg_cnt, FIRdDecimInteg_doutReg, FIRdDecimInteg_doutVldReg,
       FIRdDecimInteg_integReg, FIRdDecimInteg_integVldReg,
       FIRdDecimInteg_state, filterOut_signed, filterOut_vld)
    VARIABLE sub_cast : unsigned(1 DOWNTO 0);
    VARIABLE sub_temp : unsigned(1 DOWNTO 0);
  BEGIN
    sub_temp := to_unsigned(16#0#, 2);
    sub_cast := to_unsigned(16#0#, 2);
    FIRdDecimInteg_cnt_next <= FIRdDecimInteg_cnt;
    FIRdDecimInteg_integReg_next <= FIRdDecimInteg_integReg;
    FIRdDecimInteg_integVldReg_next <= FIRdDecimInteg_integVldReg;
    IF FIRdDecimInteg_integVldReg = '1' THEN 
      FIRdDecimInteg_doutReg_next <= FIRdDecimInteg_integReg(23 DOWNTO 12);
    ELSE 
      FIRdDecimInteg_doutReg_next <= to_signed(16#000#, 12);
    END IF;
    FIRdDecimInteg_doutVldReg_next <= FIRdDecimInteg_integVldReg;
    CASE FIRdDecimInteg_state IS
      WHEN '0' =>
        FIRdDecimInteg_state_next <= '0';
        FIRdDecimInteg_cnt_next <= '1';
        FIRdDecimInteg_integReg_next <= to_signed(16#0000000#, 25);
        FIRdDecimInteg_integVldReg_next <= '0';
        IF filterOut_vld = '1' THEN 
          FIRdDecimInteg_state_next <= '1';
          FIRdDecimInteg_integReg_next <= filterOut_signed;
          FIRdDecimInteg_cnt_next <= '0';
        END IF;
      WHEN '1' =>
        FIRdDecimInteg_state_next <= '1';
        IF filterOut_vld = '1' THEN 
          FIRdDecimInteg_integReg_next <= FIRdDecimInteg_integReg + filterOut_signed;
          IF FIRdDecimInteg_cnt = '0' THEN 
            FIRdDecimInteg_state_next <= '0';
            FIRdDecimInteg_integVldReg_next <= '1';
            FIRdDecimInteg_cnt_next <= '1';
          ELSE 
            sub_cast := '0' & FIRdDecimInteg_cnt;
            sub_temp := sub_cast - to_unsigned(16#1#, 2);
            FIRdDecimInteg_cnt_next <= sub_temp(0);
          END IF;
        END IF;
      WHEN OTHERS => 
        FIRdDecimInteg_state_next <= '0';
        FIRdDecimInteg_cnt_next <= '1';
        FIRdDecimInteg_integReg_next <= to_signed(16#0000000#, 25);
        FIRdDecimInteg_integVldReg_next <= '0';
    END CASE;
    dataOut_tmp <= FIRdDecimInteg_doutReg;
    validOut <= FIRdDecimInteg_doutVldReg;
  END PROCESS FIRdDecimInteg_output;


  dataOut <= std_logic_vector(dataOut_tmp);

END rtl;

