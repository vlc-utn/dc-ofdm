-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/full_rx_ip_src_General_CRC_Syndrome_Detector_HDL_Optimized.vhd
-- Created: 2024-10-05 22:40:32
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_rx_ip_src_General_CRC_Syndrome_Detector_HDL_Optimized
-- Source Path: HDLRx/full_rx/h_rx_full/h_crc_rx/General CRC Syndrome Detector HDL Optimized
-- Hierarchy Level: 3
-- Model version: 1.125
-- 
-- CRC Syndrome Detector HDL Optimized
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY full_rx_ip_src_General_CRC_Syndrome_Detector_HDL_Optimized IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataIn                            :   IN    std_logic;
        startIn                           :   IN    std_logic;
        endIn                             :   IN    std_logic;
        validIn                           :   IN    std_logic;
        dataOut                           :   OUT   std_logic;
        startOut                          :   OUT   std_logic;
        endOut                            :   OUT   std_logic;
        validOut                          :   OUT   std_logic;
        err                               :   OUT   std_logic
        );
END full_rx_ip_src_General_CRC_Syndrome_Detector_HDL_Optimized;


ARCHITECTURE rtl OF full_rx_ip_src_General_CRC_Syndrome_Detector_HDL_Optimized IS

  -- Component Declarations
  COMPONENT full_rx_ip_src_CRCGenerator
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic;
          startIn                         :   IN    std_logic;
          endIn                           :   IN    std_logic;
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   std_logic;
          startOut                        :   OUT   std_logic;
          endOut                          :   OUT   std_logic;
          validOut                        :   OUT   std_logic;
          outputCRC                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT full_rx_ip_src_CRCCompare
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataRef                         :   IN    std_logic;
          endIn                           :   IN    std_logic;
          dataOutgen                      :   IN    std_logic;
          startOutgen                     :   IN    std_logic;
          endOutgen                       :   IN    std_logic;
          validOutgen                     :   IN    std_logic;
          outputCRC                       :   IN    std_logic;
          dataOut                         :   OUT   std_logic;
          startOut                        :   OUT   std_logic;
          endOut                          :   OUT   std_logic;
          validOut                        :   OUT   std_logic;
          err                             :   OUT   std_logic;
          csumbufferenb                   :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_rx_ip_src_CRCGenerator
    USE ENTITY work.full_rx_ip_src_CRCGenerator(rtl);

  FOR ALL : full_rx_ip_src_CRCCompare
    USE ENTITY work.full_rx_ip_src_CRCCompare(rtl);

  -- Signals
  SIGNAL end_valid                        : std_logic;
  SIGNAL datain_tapreg_1                  : std_logic_vector(15 DOWNTO 0);  -- boolean [16]
  SIGNAL msg_datain_1                     : std_logic_vector(15 DOWNTO 0);  -- boolean [16]
  SIGNAL start_valid                      : std_logic;
  SIGNAL startin_register_reg             : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL startinreg                       : std_logic;
  SIGNAL startin_gen                      : std_logic;
  SIGNAL validin_register_reg             : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL validinreg                       : std_logic;
  SIGNAL validin_gen                      : std_logic;
  SIGNAL dataoutgen                       : std_logic;
  SIGNAL startoutgen                      : std_logic;
  SIGNAL endoutgen                        : std_logic;
  SIGNAL validoutgen                      : std_logic;
  SIGNAL outputcrc                        : std_logic;
  SIGNAL csum_tapreg_1                    : std_logic_vector(15 DOWNTO 0);  -- boolean [16]
  SIGNAL csum_datain                      : std_logic_vector(15 DOWNTO 0);  -- boolean [16]
  SIGNAL csumreg_in_1                     : std_logic_vector(15 DOWNTO 0);  -- boolean [16]
  SIGNAL csumbufferenb                    : std_logic;
  SIGNAL csumenb                          : std_logic;
  SIGNAL csumreg_enb                      : std_logic;

BEGIN
  -- HDL CRC Generator
  u_HDLCRCGen_inst : full_rx_ip_src_CRCGenerator
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              dataIn => datain_tapreg_1(0),
              startIn => startin_gen,
              endIn => end_valid,
              validIn => validin_gen,
              dataOut => dataoutgen,
              startOut => startoutgen,
              endOut => endoutgen,
              validOut => validoutgen,
              outputCRC => outputcrc
              );

  -- Checksum Comparison
  u_ChecksumCompare_inst : full_rx_ip_src_CRCCompare
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              dataRef => csum_tapreg_1(0),
              endIn => end_valid,
              dataOutgen => dataoutgen,
              startOutgen => startoutgen,
              endOutgen => endoutgen,
              validOutgen => validoutgen,
              outputCRC => outputcrc,
              dataOut => dataOut,
              startOut => startOut,
              endOut => endOut,
              validOut => validOut,
              err => err,
              csumbufferenb => csumbufferenb
              );

  end_valid <= endIn AND validIn;

  datain_tapregister1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        datain_tapreg_1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        IF end_valid = '1' THEN
          datain_tapreg_1 <= (OTHERS => '0');
        ELSIF validIn = '1' THEN
          datain_tapreg_1(15) <= dataIn;
          datain_tapreg_1(14 DOWNTO 0) <= datain_tapreg_1(15 DOWNTO 1);
        END IF;
      END IF;
    END IF;
  END PROCESS datain_tapregister1_process;


  msg_datain_1(0) <= datain_tapreg_1(1);
  msg_datain_1(1) <= datain_tapreg_1(2);
  msg_datain_1(2) <= datain_tapreg_1(3);
  msg_datain_1(3) <= datain_tapreg_1(4);
  msg_datain_1(4) <= datain_tapreg_1(5);
  msg_datain_1(5) <= datain_tapreg_1(6);
  msg_datain_1(6) <= datain_tapreg_1(7);
  msg_datain_1(7) <= datain_tapreg_1(8);
  msg_datain_1(8) <= datain_tapreg_1(9);
  msg_datain_1(9) <= datain_tapreg_1(10);
  msg_datain_1(10) <= datain_tapreg_1(11);
  msg_datain_1(11) <= datain_tapreg_1(12);
  msg_datain_1(12) <= datain_tapreg_1(13);
  msg_datain_1(13) <= datain_tapreg_1(14);
  msg_datain_1(14) <= datain_tapreg_1(15);
  msg_datain_1(15) <= dataIn;

  start_valid <= startIn AND validIn;

  startin_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        startin_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        IF end_valid = '1' THEN
          startin_register_reg <= (OTHERS => '0');
        ELSIF validIn = '1' THEN
          startin_register_reg(0) <= start_valid;
          startin_register_reg(15 DOWNTO 1) <= startin_register_reg(14 DOWNTO 0);
        END IF;
      END IF;
    END IF;
  END PROCESS startin_register_process;

  startinreg <= startin_register_reg(15);

  startin_gen <= startinreg AND validIn;

  validin_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validin_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        IF end_valid = '1' THEN
          validin_register_reg <= (OTHERS => '0');
        ELSIF validIn = '1' THEN
          validin_register_reg(0) <= validIn;
          validin_register_reg(15 DOWNTO 1) <= validin_register_reg(14 DOWNTO 0);
        END IF;
      END IF;
    END IF;
  END PROCESS validin_register_process;

  validinreg <= validin_register_reg(15);

  validin_gen <= validinreg AND validIn;

  csum_datain(0) <= csum_tapreg_1(1);
  csum_datain(1) <= csum_tapreg_1(2);
  csum_datain(2) <= csum_tapreg_1(3);
  csum_datain(3) <= csum_tapreg_1(4);
  csum_datain(4) <= csum_tapreg_1(5);
  csum_datain(5) <= csum_tapreg_1(6);
  csum_datain(6) <= csum_tapreg_1(7);
  csum_datain(7) <= csum_tapreg_1(8);
  csum_datain(8) <= csum_tapreg_1(9);
  csum_datain(9) <= csum_tapreg_1(10);
  csum_datain(10) <= csum_tapreg_1(11);
  csum_datain(11) <= csum_tapreg_1(12);
  csum_datain(12) <= csum_tapreg_1(13);
  csum_datain(13) <= csum_tapreg_1(14);
  csum_datain(14) <= csum_tapreg_1(15);
  csum_datain(15) <= dataIn;

  
  csumreg_in_1 <= csum_datain WHEN end_valid = '0' ELSE
      msg_datain_1;

  csumenb <= csumbufferenb OR validIn;

  csumreg_enb <= csumenb OR end_valid;

  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        csum_tapreg_1 <= (OTHERS => '0');
      ELSIF enb = '1' AND csumreg_enb = '1' THEN
        csum_tapreg_1 <= csumreg_in_1;
      END IF;
    END IF;
  END PROCESS intdelay_process;


END rtl;

