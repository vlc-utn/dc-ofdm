-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/full_rx_ip_src_CRCGenControl.vhd
-- Created: 2024-10-02 12:29:28
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_rx_ip_src_CRCGenControl
-- Source Path: HDLRx/full_rx/h_rx_full/h_crc_rx/General CRC Syndrome Detector HDL Optimized/CRCGenerator/CRCGenControl
-- Hierarchy Level: 5
-- Model version: 1.100
-- 
-- CRC Generator Control Signals Generation
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY full_rx_ip_src_CRCGenControl IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        startIn                           :   IN    std_logic;  -- ufix1
        endIn                             :   IN    std_logic;  -- ufix1
        validIn                           :   IN    std_logic;  -- ufix1
        startOut                          :   OUT   std_logic;  -- ufix1
        processMsg                        :   OUT   std_logic;  -- ufix1
        padZero                           :   OUT   std_logic;  -- ufix1
        outputCRC                         :   OUT   std_logic;  -- ufix1
        endOut                            :   OUT   std_logic;  -- ufix1
        validOut                          :   OUT   std_logic;  -- ufix1
        counter                           :   OUT   std_logic_vector(3 DOWNTO 0);  -- ufix4
        counter_outputCRC                 :   OUT   std_logic_vector(3 DOWNTO 0)  -- ufix4
        );
END full_rx_ip_src_CRCGenControl;


ARCHITECTURE rtl OF full_rx_ip_src_CRCGenControl IS

  -- Signals
  SIGNAL deofin                           : std_logic;  -- ufix1
  SIGNAL cnt3out                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL processzero_short                : std_logic;  -- ufix1
  SIGNAL cnt3enb                          : std_logic;  -- ufix1
  SIGNAL tsysenb_short                    : std_logic;  -- ufix1
  SIGNAL tprocessMsg                      : std_logic;  -- ufix1
  SIGNAL sysenb_short                     : std_logic;  -- ufix1
  SIGNAL ready                            : std_logic;  -- ufix1
  SIGNAL cnt1enb                          : std_logic;  -- ufix1
  SIGNAL cnt2out                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL cnt2rst                          : std_logic;  -- ufix1
  SIGNAL cnt2enb                          : std_logic;  -- ufix1
  SIGNAL compare_cmpOut                   : std_logic;
  SIGNAL cnt2fstout                       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL cnt2fstout_is_not0               : std_logic;
  SIGNAL cnt1rst                          : std_logic;  -- ufix1
  SIGNAL cnt1out                          : std_logic;  -- ufix1
  SIGNAL dtprocessMsg                     : std_logic;  -- ufix1
  SIGNAL rdtprocessMsg                    : std_logic;  -- ufix1
  SIGNAL startout_1                       : std_logic;  -- ufix1
  SIGNAL sof_delay_register_reg           : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL processzero                      : std_logic;  -- ufix1
  SIGNAL tpadZero                         : std_logic;  -- ufix1
  SIGNAL cnt4rst                          : std_logic;  -- ufix1
  SIGNAL cnt5enb                          : std_logic;  -- ufix1
  SIGNAL cnt5out                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL cnt4out                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL dteofout                         : std_logic;  -- ufix1
  SIGNAL rdteofout                        : std_logic;  -- ufix1
  SIGNAL sysenb                           : std_logic;  -- ufix1
  SIGNAL udvalidin                        : std_logic;  -- ufix1
  SIGNAL rcnt3enb                         : std_logic;  -- ufix1
  SIGNAL clearvalidin                     : std_logic;  -- ufix1
  SIGNAL tvalidout                        : std_logic;  -- ufix1
  SIGNAL tvalidout_delay_register_reg     : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL dvalidout                        : std_logic;  -- ufix1

BEGIN
  eofin_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        deofin <= '0';
      ELSIF enb = '1' THEN
        deofin <= endIn;
      END IF;
    END IF;
  END PROCESS eofin_delay_register_process;


  
  processzero_short <= '1' WHEN cnt3out < to_unsigned(16#F#, 4) ELSE
      '0';

  tsysenb_short <= cnt3enb AND processzero_short;

  sysenb_short <= tprocessMsg OR tsysenb_short;

  ready <=  NOT sysenb_short;

  cnt1enb <= ready AND startIn;

  -- Counter 3 enable signal
  
  cnt3enb <= '1' WHEN cnt2out >= to_unsigned(16#1#, 4) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 15
  -- Counter3: counts when start to pad zeros
  counter_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt3out <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        IF cnt2rst = '1' THEN 
          cnt3out <= to_unsigned(16#0#, 4);
        ELSIF cnt3enb = '1' THEN 
          cnt3out <= cnt3out + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_1_process;


  
  cnt2rst <= '1' WHEN cnt3out = to_unsigned(16#F#, 4) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 15
  --  count to value  = 1
  -- Counter2: triggered by End of frame signal
  counter_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt2out <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        IF cnt2rst = '1' THEN 
          cnt2out <= to_unsigned(16#0#, 4);
        ELSIF cnt2enb = '1' THEN 
          IF cnt2out = to_unsigned(16#1#, 4) THEN 
            cnt2out <= to_unsigned(16#0#, 4);
          ELSE 
            cnt2out <= cnt2out + to_unsigned(16#F#, 4);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS counter_2_process;


  
  compare_cmpOut <= '1' WHEN cnt2out = to_unsigned(16#0#, 4) ELSE
      '0';

  cnt2fstout <= '0' & '0' & '0' & compare_cmpOut;

  
  cnt2fstout_is_not0 <= '1' WHEN cnt2fstout /= to_unsigned(16#0#, 4) ELSE
      '0';

  -- Counter 2 enable signal
  cnt2enb <= tprocessMsg AND deofin;

  cnt1rst <= cnt2enb AND cnt2fstout_is_not0;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  -- Counter1: triggered by Start of frame signal
  counter_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt1out <= '0';
      ELSIF enb = '1' THEN
        IF cnt1rst = '1' THEN 
          cnt1out <= '0';
        ELSIF cnt1enb = '1' THEN 
          cnt1out <=  NOT cnt1out;
        END IF;
      END IF;
    END IF;
  END PROCESS counter_3_process;


  
  tprocessMsg <= '1' WHEN cnt1out = '1' ELSE
      '0';

  tprocessMsg_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dtprocessMsg <= '0';
      ELSIF enb = '1' THEN
        dtprocessMsg <= tprocessMsg;
      END IF;
    END IF;
  END PROCESS tprocessMsg_delay_register_process;


  rdtprocessMsg <=  NOT dtprocessMsg;

  startout_1 <= tprocessMsg AND rdtprocessMsg;

  -- Start of frame output signal
  sof_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        sof_delay_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        sof_delay_register_reg(0) <= startout_1;
        sof_delay_register_reg(15 DOWNTO 1) <= sof_delay_register_reg(14 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS sof_delay_register_process;

  startOut <= sof_delay_register_reg(15);

  -- processMsg
  processMsg <= tprocessMsg;

  processzero <= '1';

  tpadZero <= cnt3enb AND processzero;

  -- padZero
  padZero <= tpadZero;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 15
  -- Counter5: counts when start to output CRC
  counter_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt5out <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        IF cnt4rst = '1' THEN 
          cnt5out <= to_unsigned(16#0#, 4);
        ELSIF cnt5enb = '1' THEN 
          cnt5out <= cnt5out + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_4_process;


  
  cnt4rst <= '1' WHEN cnt5out = to_unsigned(16#F#, 4) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 15
  -- Counter4: triggered after processing all the padded zeros
  counter_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt4out <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        IF cnt4rst = '1' THEN 
          cnt4out <= to_unsigned(16#0#, 4);
        ELSIF cnt2rst = '1' THEN 
          cnt4out <= cnt4out + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_5_process;


  -- Counter 5 enable signal
  
  cnt5enb <= '1' WHEN cnt4out >= to_unsigned(16#1#, 4) ELSE
      '0';

  -- outputCRC
  outputCRC <= cnt5enb;

  eofout_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dteofout <= '0';
      ELSIF enb = '1' THEN
        dteofout <= cnt4rst;
      END IF;
    END IF;
  END PROCESS eofout_delay_register_process;


  rdteofout <=  NOT dteofout;

  -- End of frame output signal
  endOut <= cnt4rst AND rdteofout;

  sysenb <= tprocessMsg OR tpadZero;

  validin_unitdelay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        udvalidin <= '0';
      ELSIF enb = '1' THEN
        udvalidin <= validIn;
      END IF;
    END IF;
  END PROCESS validin_unitdelay_register_process;


  rcnt3enb <=  NOT cnt3enb;

  
  clearvalidin <= udvalidin WHEN cnt3enb = '0' ELSE
      rcnt3enb;

  tvalidout <= sysenb AND clearvalidin;

  -- Buffer the validIn signal
  tvalidout_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        tvalidout_delay_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        tvalidout_delay_register_reg(0) <= tvalidout;
        tvalidout_delay_register_reg(15 DOWNTO 1) <= tvalidout_delay_register_reg(14 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS tvalidout_delay_register_process;

  dvalidout <= tvalidout_delay_register_reg(15);

  -- Data valid output
  validOut <= dvalidout OR cnt5enb;

  counter <= std_logic_vector(cnt3out);

  counter_outputCRC <= std_logic_vector(cnt5out);

END rtl;

