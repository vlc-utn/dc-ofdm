-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/full_rx_ip_src_CRCCompare.vhd
-- Created: 2024-10-04 15:18:53
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_rx_ip_src_CRCCompare
-- Source Path: HDLRx/full_rx/h_rx_full/h_crc_rx/General CRC Syndrome Detector HDL Optimized/CRCCompare
-- Hierarchy Level: 4
-- Model version: 1.101
-- 
-- Checksum Comparison
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY full_rx_ip_src_CRCCompare IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataRef                           :   IN    std_logic;
        endIn                             :   IN    std_logic;  -- ufix1
        dataOutgen                        :   IN    std_logic;
        startOutgen                       :   IN    std_logic;  -- ufix1
        endOutgen                         :   IN    std_logic;  -- ufix1
        validOutgen                       :   IN    std_logic;  -- ufix1
        outputCRC                         :   IN    std_logic;  -- ufix1
        dataOut                           :   OUT   std_logic;
        startOut                          :   OUT   std_logic;  -- ufix1
        endOut                            :   OUT   std_logic;  -- ufix1
        validOut                          :   OUT   std_logic;  -- ufix1
        err                               :   OUT   std_logic;  -- ufix1
        csumbufferenb                     :   OUT   std_logic  -- ufix1
        );
END full_rx_ip_src_CRCCompare;


ARCHITECTURE rtl OF full_rx_ip_src_CRCCompare IS

  -- Signals
  SIGNAL outputCRC_1                      : std_logic;  -- ufix1
  SIGNAL const0data                       : std_logic;
  SIGNAL tdataout                         : std_logic;
  SIGNAL dataout_delay_register_reg       : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL startout_delay_register_reg      : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL const0ctl                        : std_logic;  -- ufix1
  SIGNAL tvalidout                        : std_logic;  -- ufix1
  SIGNAL validout_delay_register_reg      : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL cnt1rst                          : std_logic;  -- ufix1
  SIGNAL cnt2enb                          : std_logic;  -- ufix1
  SIGNAL cnt2out                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL cnt1out                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL bufferenb                        : std_logic;  -- ufix1
  SIGNAL alpha_reg                        : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL checksumreg                      : std_logic;
  SIGNAL xorchecksums                     : std_logic;
  SIGNAL cmpresult                        : std_logic;  -- ufix1
  SIGNAL const0cnt                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL numerr                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL totalerr                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL dtotalerr                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL adder_add_cast                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL adder_add_temp                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL hadErr                           : std_logic;  -- ufix1

BEGIN
  -- Buffer Checksum output control signal
  outputCRC_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        outputCRC_1 <= '0';
      ELSIF enb = '1' THEN
        outputCRC_1 <= outputCRC;
      END IF;
    END IF;
  END PROCESS outputCRC_register_process;


  -- Constant 0
  const0data <= '0';

  -- Data output
  
  tdataout <= dataOutgen WHEN outputCRC_1 = '0' ELSE
      const0data;

  dataout_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dataout_delay_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        dataout_delay_register_reg(0) <= tdataout;
        dataout_delay_register_reg(15 DOWNTO 1) <= dataout_delay_register_reg(14 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS dataout_delay_register_process;

  dataOut <= dataout_delay_register_reg(15);

  -- startOut
  startout_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        startout_delay_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        startout_delay_register_reg(0) <= startOutgen;
        startout_delay_register_reg(15 DOWNTO 1) <= startout_delay_register_reg(14 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS startout_delay_register_process;

  startOut <= startout_delay_register_reg(15);

  -- endOut
  endOut <= endOutgen;

  const0ctl <= '0';

  -- validOut
  
  tvalidout <= validOutgen WHEN outputCRC_1 = '0' ELSE
      const0ctl;

  validout_delay_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validout_delay_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        validout_delay_register_reg(0) <= tvalidout;
        validout_delay_register_reg(15 DOWNTO 1) <= validout_delay_register_reg(14 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS validout_delay_register_process;

  validOut <= validout_delay_register_reg(15);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 15
  counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt2out <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        IF cnt1rst = '1' THEN 
          cnt2out <= to_unsigned(16#0#, 4);
        ELSIF cnt2enb = '1' THEN 
          cnt2out <= cnt2out + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_process;


  
  cnt1rst <= '1' WHEN cnt2out = to_unsigned(16#F#, 4) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 15
  counter_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnt1out <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        IF cnt1rst = '1' THEN 
          cnt1out <= to_unsigned(16#0#, 4);
        ELSIF endIn = '1' THEN 
          cnt1out <= cnt1out + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_1_process;


  -- Generate Checksum buffer enable
  
  cnt2enb <= '1' WHEN cnt1out >= to_unsigned(16#1#, 4) ELSE
      '0';

  bufferenb <= cnt2enb OR outputCRC_1;

  -- Buffer input Checksum
  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_reg <= (OTHERS => '0');
      ELSIF enb = '1' AND bufferenb = '1' THEN
        alpha_reg(0) <= dataRef;
        alpha_reg(15 DOWNTO 1) <= alpha_reg(14 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS c_2_process;

  checksumreg <= alpha_reg(15);

  -- Compare Checksum
  
  xorchecksums <= '1' WHEN dataOutgen /= checksumreg ELSE
      '0';

  
  cmpresult <= const0ctl WHEN outputCRC_1 = '0' ELSE
      xorchecksums;

  const0cnt <= to_unsigned(16#0#, 4);

  
  totalerr <= numerr WHEN endOutgen = '0' ELSE
      const0cnt;

  totalErr_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dtotalerr <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        dtotalerr <= totalerr;
      END IF;
    END IF;
  END PROCESS totalErr_register_process;


  -- Count number of errors
  adder_add_cast <= '0' & '0' & '0' & '0' & cmpresult;
  adder_add_temp <= adder_add_cast + resize(dtotalerr, 5);
  
  numerr <= "1111" WHEN adder_add_temp(4) /= '0' ELSE
      adder_add_temp(3 DOWNTO 0);

  -- Detectot error
  
  hadErr <= '1' WHEN numerr > to_unsigned(16#0#, 4) ELSE
      '0';

  
  err <= const0ctl WHEN endOutgen = '0' ELSE
      hadErr;

  csumbufferenb <= cnt2enb;

END rtl;

