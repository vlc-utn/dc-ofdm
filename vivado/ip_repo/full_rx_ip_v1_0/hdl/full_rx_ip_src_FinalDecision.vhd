-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/full_rx_ip_src_FinalDecision.vhd
-- Created: 2024-10-02 12:29:28
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_rx_ip_src_FinalDecision
-- Source Path: HDLRx/full_rx/h_rx_full/LDPC_Deco_Hc_12H/DecoderCore/FinalDecision
-- Hierarchy Level: 4
-- Model version: 1.100
-- 
-- Final Decision
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_rx_ip_src_full_rx_pac.ALL;

ENTITY full_rx_ip_src_FinalDecision IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        reset                             :   IN    std_logic;  -- ufix1
        data                              :   IN    vector_of_std_logic_vector18(0 TO 13);  -- sfix18_En12 [14]
        iterdone                          :   IN    std_logic;  -- ufix1
        decbits                           :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        start                             :   OUT   std_logic;  -- ufix1
        valid                             :   OUT   std_logic  -- ufix1
        );
END full_rx_ip_src_FinalDecision;


ARCHITECTURE rtl OF full_rx_ip_src_FinalDecision IS

  -- Signals
  SIGNAL data_signed                      : vector_of_signed18(0 TO 13);  -- sfix18_En12 [14]
  SIGNAL finalDecision_enb_dec            : std_logic;
  SIGNAL finalDecision_count              : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL finalDecision_iterDone           : std_logic;
  SIGNAL finalDecision_zCount1            : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL finalDecision_zCount2            : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL finalDecision_cntEnb             : std_logic;
  SIGNAL finalDecision_endD               : std_logic;
  SIGNAL finalDecision_ctrlEnd            : std_logic;
  SIGNAL finalDecision_enb_dec_next       : std_logic;
  SIGNAL finalDecision_count_next         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL finalDecision_iterDone_next      : std_logic;
  SIGNAL finalDecision_zCount1_next       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL finalDecision_zCount2_next       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL finalDecision_cntEnb_next        : std_logic;
  SIGNAL finalDecision_endD_next          : std_logic;
  SIGNAL finalDecision_ctrlEnd_next       : std_logic;
  SIGNAL data_1                           : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL start_out                        : std_logic;  -- ufix1
  SIGNAL valid_out                        : std_logic;  -- ufix1

BEGIN
  outputgen: FOR k IN 0 TO 13 GENERATE
    data_signed(k) <= signed(data(k));
  END GENERATE;

  finalDecision_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        finalDecision_enb_dec <= '0';
        finalDecision_count <= to_unsigned(16#1#, 4);
        finalDecision_iterDone <= '0';
        finalDecision_zCount1 <= to_unsigned(16#0#, 4);
        finalDecision_zCount2 <= to_unsigned(16#0#, 4);
        finalDecision_cntEnb <= '0';
        finalDecision_endD <= '0';
        finalDecision_ctrlEnd <= '0';
      ELSIF enb = '1' THEN
        finalDecision_enb_dec <= finalDecision_enb_dec_next;
        finalDecision_count <= finalDecision_count_next;
        finalDecision_iterDone <= finalDecision_iterDone_next;
        finalDecision_zCount1 <= finalDecision_zCount1_next;
        finalDecision_zCount2 <= finalDecision_zCount2_next;
        finalDecision_cntEnb <= finalDecision_cntEnb_next;
        finalDecision_endD <= finalDecision_endD_next;
        finalDecision_ctrlEnd <= finalDecision_ctrlEnd_next;
      END IF;
    END IF;
  END PROCESS finalDecision_process;

  finalDecision_output : PROCESS (data_signed, finalDecision_cntEnb, finalDecision_count, finalDecision_ctrlEnd,
       finalDecision_enb_dec, finalDecision_endD, finalDecision_iterDone,
       finalDecision_zCount1, finalDecision_zCount2, iterdone, reset)
    VARIABLE validi : std_logic;
    VARIABLE starto : std_logic;
    VARIABLE enb_dec_temp : std_logic;
    VARIABLE count_temp : unsigned(3 DOWNTO 0);
    VARIABLE zCount1_temp : unsigned(3 DOWNTO 0);
    VARIABLE zCount2_temp : unsigned(3 DOWNTO 0);
    VARIABLE cntEnb_temp : std_logic;
    VARIABLE endD_temp : std_logic;
    VARIABLE ctrlEnd_temp : std_logic;
  BEGIN
    enb_dec_temp := finalDecision_enb_dec;
    count_temp := finalDecision_count;
    zCount1_temp := finalDecision_zCount1;
    zCount2_temp := finalDecision_zCount2;
    cntEnb_temp := finalDecision_cntEnb;
    endD_temp := finalDecision_endD;
    ctrlEnd_temp := finalDecision_ctrlEnd;
    IF reset /= '0' THEN 
      enb_dec_temp := '0';
      count_temp := to_unsigned(16#1#, 4);
      zCount1_temp := to_unsigned(16#0#, 4);
      zCount2_temp := to_unsigned(16#0#, 4);
      cntEnb_temp := '0';
      endD_temp := '0';
      ctrlEnd_temp := '0';
      starto := '0';
    ELSE 
      starto := iterdone AND ( NOT finalDecision_iterDone);
    END IF;
    finalDecision_iterDone_next <= iterdone;
    IF ctrlEnd_temp = '1' THEN 
      count_temp := to_unsigned(16#1#, 4);
    END IF;
    IF starto = '1' THEN 
      enb_dec_temp := iterdone;
      zCount1_temp := to_unsigned(16#0#, 4);
      zCount2_temp := to_unsigned(16#0#, 4);
    END IF;
    IF enb_dec_temp = '1' THEN 
      IF zCount1_temp = to_unsigned(16#E#, 4) THEN 
        zCount1_temp := to_unsigned(16#1#, 4);
        cntEnb_temp := '1';
      ELSE 
        zCount1_temp := zCount1_temp + to_unsigned(16#1#, 4);
        cntEnb_temp := '0';
      END IF;
      IF cntEnb_temp = '1' THEN 
        IF count_temp = to_unsigned(16#B#, 4) THEN 
          endD_temp := '1';
          enb_dec_temp := '0';
        ELSE 
          count_temp := count_temp + to_unsigned(16#1#, 4);
        END IF;
      END IF;
      validi := '1';
    ELSE 
      validi := '0';
    END IF;
    IF endD_temp = '1' THEN 
      IF zCount2_temp = to_unsigned(16#D#, 4) THEN 
        zCount2_temp := to_unsigned(16#0#, 4);
        ctrlEnd_temp := '1';
        endD_temp := '0';
      ELSE 
        ctrlEnd_temp := '0';
        zCount2_temp := zCount2_temp + to_unsigned(16#1#, 4);
      END IF;
    ELSE 
      ctrlEnd_temp := '0';
    END IF;
    valid_out <= (validi OR endD_temp) OR ctrlEnd_temp;

    FOR t_0 IN 0 TO 13 LOOP
      IF data_signed(t_0) <= to_signed(16#00000#, 18) THEN 
        data_1(t_0) <= '1';
      ELSE 
        data_1(t_0) <= '0';
      END IF;
    END LOOP;

    start_out <= starto;
    finalDecision_enb_dec_next <= enb_dec_temp;
    finalDecision_count_next <= count_temp;
    finalDecision_zCount1_next <= zCount1_temp;
    finalDecision_zCount2_next <= zCount2_temp;
    finalDecision_cntEnb_next <= cntEnb_temp;
    finalDecision_endD_next <= endD_temp;
    finalDecision_ctrlEnd_next <= ctrlEnd_temp;
  END PROCESS finalDecision_output;


  dataOut_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        decbits <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        decbits <= data_1;
      END IF;
    END IF;
  END PROCESS dataOut_process;


  startOut_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        start <= '0';
      ELSIF enb = '1' THEN
        start <= start_out;
      END IF;
    END IF;
  END PROCESS startOut_process;


  validOut_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        valid <= '0';
      ELSIF enb = '1' THEN
        valid <= valid_out;
      END IF;
    END IF;
  END PROCESS validOut_process;


END rtl;

