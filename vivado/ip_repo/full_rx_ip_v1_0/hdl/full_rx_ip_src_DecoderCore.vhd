-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/full_rx_ip_src_DecoderCore.vhd
-- Created: 2024-08-10 11:14:31
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_rx_ip_src_DecoderCore
-- Source Path: HDLRx/full_rx/h_rx_full/LDPC_Deco_Hc_12H/DecoderCore
-- Hierarchy Level: 3
-- Model version: 1.14
-- 
-- Decoder Core
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_rx_ip_src_full_rx_pac.ALL;

ENTITY full_rx_ip_src_DecoderCore IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        reset                             :   IN    std_logic;  -- ufix1
        data                              :   IN    std_logic_vector(9 DOWNTO 0);  -- sfix10
        valid                             :   IN    std_logic;  -- ufix1
        framevalid                        :   IN    std_logic;  -- ufix1
        endind                            :   IN    std_logic;  -- ufix1
        numiter                           :   IN    std_logic_vector(7 DOWNTO 0);  -- ufix8
        data_1                            :   OUT   std_logic;  -- ufix1
        start                             :   OUT   std_logic;  -- ufix1
        end_rsvd                          :   OUT   std_logic;  -- ufix1
        valid_1                           :   OUT   std_logic  -- ufix1
        );
END full_rx_ip_src_DecoderCore;


ARCHITECTURE rtl OF full_rx_ip_src_DecoderCore IS

  -- Component Declarations
  COMPONENT full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT full_rx_ip_src_CheckNodeRAM
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          bdecomp1                        :   IN    vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
          bdecomp2                        :   IN    vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
          bdecomp3                        :   IN    vector_of_std_logic_vector14(0 TO 13);  -- ufix14 [14]
          countlayer                      :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          enbread                         :   IN    std_logic;  -- ufix1
          bvalid                          :   IN    std_logic;  -- ufix1
          bdecomp1Out                     :   OUT   vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
          bdecomp2Out                     :   OUT   vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
          bdecomp3Out                     :   OUT   vector_of_std_logic_vector14(0 TO 13);  -- ufix14 [14]
          bvalidOut                       :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT full_rx_ip_src_BarrelRotator
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          data                            :   IN    vector_of_std_logic_vector10(0 TO 13);  -- sfix10 [14]
          shift                           :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          shiftData                       :   OUT   vector_of_std_logic_vector10(0 TO 13)  -- sfix10 [14]
          );
  END COMPONENT;

  COMPONENT full_rx_ip_src_FunctionalUnit
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          reset                           :   IN    std_logic;  -- ufix1
          data                            :   IN    vector_of_std_logic_vector10(0 TO 13);  -- sfix10 [14]
          valid                           :   IN    std_logic;  -- ufix1
          count                           :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          betaComp1                       :   IN    vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
          betaComp2                       :   IN    vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
          betaComp3                       :   IN    vector_of_std_logic_vector14(0 TO 13);  -- ufix14 [14]
          betaValid                       :   IN    std_logic;  -- ufix1
          gamma                           :   OUT   vector_of_std_logic_vector10(0 TO 13);  -- sfix10 [14]
          valid_1                         :   OUT   std_logic;  -- ufix1
          cnuComp1                        :   OUT   vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
          cnuComp2                        :   OUT   vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
          cnuComp3                        :   OUT   vector_of_std_logic_vector14(0 TO 13);  -- ufix14 [14]
          cnuValid                        :   OUT   std_logic;  -- ufix1
          rdAddr                          :   OUT   std_logic_vector(2 DOWNTO 0)  -- ufix3
          );
  END COMPONENT;

  COMPONENT full_rx_ip_src_FinalDecision
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          reset                           :   IN    std_logic;  -- ufix1
          data                            :   IN    vector_of_std_logic_vector10(0 TO 13);  -- sfix10 [14]
          iterdone                        :   IN    std_logic;  -- ufix1
          decbits                         :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          start                           :   OUT   std_logic;  -- ufix1
          valid                           :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    USE ENTITY work.full_rx_ip_src_SimpleDualPortRAM_generic_block4(rtl);

  FOR ALL : full_rx_ip_src_CheckNodeRAM
    USE ENTITY work.full_rx_ip_src_CheckNodeRAM(rtl);

  FOR ALL : full_rx_ip_src_BarrelRotator
    USE ENTITY work.full_rx_ip_src_BarrelRotator(rtl);

  FOR ALL : full_rx_ip_src_FunctionalUnit
    USE ENTITY work.full_rx_ip_src_FunctionalUnit(rtl);

  FOR ALL : full_rx_ip_src_FinalDecision
    USE ENTITY work.full_rx_ip_src_FinalDecision(rtl);

  -- Constants
  CONSTANT ShiftWriteLUT_data             : vector_of_unsigned4(0 TO 95) := 
    (to_unsigned(16#8#, 4), to_unsigned(16#E#, 4), to_unsigned(16#5#, 4), to_unsigned(16#D#, 4),
     to_unsigned(16#A#, 4), to_unsigned(16#B#, 4), to_unsigned(16#E#, 4), to_unsigned(16#5#, 4),
     to_unsigned(16#5#, 4), to_unsigned(16#9#, 4), to_unsigned(16#6#, 4), to_unsigned(16#4#, 4),
     to_unsigned(16#5#, 4), to_unsigned(16#B#, 4), to_unsigned(16#3#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#6#, 4), to_unsigned(16#E#, 4), to_unsigned(16#8#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#D#, 4), to_unsigned(16#6#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#8#, 4), to_unsigned(16#2#, 4), to_unsigned(16#1#, 4), to_unsigned(16#7#, 4),
     to_unsigned(16#C#, 4), to_unsigned(16#6#, 4), to_unsigned(16#9#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#1#, 4), to_unsigned(16#A#, 4), to_unsigned(16#5#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#C#, 4), to_unsigned(16#D#, 4), to_unsigned(16#C#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#9#, 4), to_unsigned(16#D#, 4), to_unsigned(16#1#, 4), to_unsigned(16#D#, 4),
     to_unsigned(16#2#, 4), to_unsigned(16#9#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#A#, 4), to_unsigned(16#B#, 4), to_unsigned(16#2#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#6#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#A#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4),
     to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4), to_unsigned(16#E#, 4));  -- ufix4 [96]
  CONSTANT ShiftReadLUT_data              : vector_of_unsigned4(0 TO 83) := 
    (to_unsigned(16#6#, 4), to_unsigned(16#0#, 4), to_unsigned(16#9#, 4), to_unsigned(16#1#, 4),
     to_unsigned(16#4#, 4), to_unsigned(16#3#, 4), to_unsigned(16#0#, 4), to_unsigned(16#9#, 4),
     to_unsigned(16#9#, 4), to_unsigned(16#5#, 4), to_unsigned(16#8#, 4), to_unsigned(16#A#, 4),
     to_unsigned(16#9#, 4), to_unsigned(16#3#, 4), to_unsigned(16#B#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#8#, 4), to_unsigned(16#0#, 4), to_unsigned(16#6#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#1#, 4), to_unsigned(16#8#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#6#, 4), to_unsigned(16#C#, 4), to_unsigned(16#D#, 4), to_unsigned(16#7#, 4),
     to_unsigned(16#2#, 4), to_unsigned(16#8#, 4), to_unsigned(16#5#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#D#, 4), to_unsigned(16#4#, 4), to_unsigned(16#9#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#2#, 4), to_unsigned(16#1#, 4), to_unsigned(16#2#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#5#, 4), to_unsigned(16#1#, 4), to_unsigned(16#D#, 4), to_unsigned(16#1#, 4),
     to_unsigned(16#C#, 4), to_unsigned(16#5#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#4#, 4), to_unsigned(16#3#, 4), to_unsigned(16#C#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#8#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#4#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4));  -- ufix4 [84]
  CONSTANT iterationController_data       : vector_of_unsigned5(0 TO 76) := 
    (to_unsigned(16#04#, 5), to_unsigned(16#07#, 5), to_unsigned(16#08#, 5), to_unsigned(16#0B#, 5),
     to_unsigned(16#0D#, 5), to_unsigned(16#0E#, 5), to_unsigned(16#02#, 5), to_unsigned(16#06#, 5),
     to_unsigned(16#08#, 5), to_unsigned(16#09#, 5), to_unsigned(16#0C#, 5), to_unsigned(16#0E#, 5),
     to_unsigned(16#0F#, 5), to_unsigned(16#02#, 5), to_unsigned(16#03#, 5), to_unsigned(16#06#, 5),
     to_unsigned(16#09#, 5), to_unsigned(16#0A#, 5), to_unsigned(16#0F#, 5), to_unsigned(16#10#, 5),
     to_unsigned(16#01#, 5), to_unsigned(16#04#, 5), to_unsigned(16#07#, 5), to_unsigned(16#0B#, 5),
     to_unsigned(16#10#, 5), to_unsigned(16#11#, 5), to_unsigned(16#04#, 5), to_unsigned(16#05#, 5),
     to_unsigned(16#0B#, 5), to_unsigned(16#0C#, 5), to_unsigned(16#11#, 5), to_unsigned(16#12#, 5),
     to_unsigned(16#02#, 5), to_unsigned(16#03#, 5), to_unsigned(16#06#, 5), to_unsigned(16#09#, 5),
     to_unsigned(16#12#, 5), to_unsigned(16#13#, 5), to_unsigned(16#04#, 5), to_unsigned(16#05#, 5),
     to_unsigned(16#0A#, 5), to_unsigned(16#0B#, 5), to_unsigned(16#13#, 5), to_unsigned(16#14#, 5),
     to_unsigned(16#04#, 5), to_unsigned(16#08#, 5), to_unsigned(16#0B#, 5), to_unsigned(16#0C#, 5),
     to_unsigned(16#14#, 5), to_unsigned(16#15#, 5), to_unsigned(16#01#, 5), to_unsigned(16#02#, 5),
     to_unsigned(16#03#, 5), to_unsigned(16#06#, 5), to_unsigned(16#09#, 5), to_unsigned(16#15#, 5),
     to_unsigned(16#16#, 5), to_unsigned(16#02#, 5), to_unsigned(16#05#, 5), to_unsigned(16#06#, 5),
     to_unsigned(16#09#, 5), to_unsigned(16#16#, 5), to_unsigned(16#17#, 5), to_unsigned(16#04#, 5),
     to_unsigned(16#07#, 5), to_unsigned(16#0A#, 5), to_unsigned(16#0B#, 5), to_unsigned(16#0D#, 5),
     to_unsigned(16#17#, 5), to_unsigned(16#18#, 5), to_unsigned(16#01#, 5), to_unsigned(16#02#, 5),
     to_unsigned(16#06#, 5), to_unsigned(16#09#, 5), to_unsigned(16#0D#, 5), to_unsigned(16#18#, 5),
     to_unsigned(16#04#, 5));  -- ufix5 [77]
  CONSTANT iterationcontroller_data_0     : vector_of_unsigned3(0 TO 11) := 
    (to_unsigned(16#6#, 3), to_unsigned(16#7#, 3), to_unsigned(16#7#, 3), to_unsigned(16#6#, 3),
     to_unsigned(16#6#, 3), to_unsigned(16#6#, 3), to_unsigned(16#6#, 3), to_unsigned(16#6#, 3),
     to_unsigned(16#7#, 3), to_unsigned(16#6#, 3), to_unsigned(16#7#, 3), to_unsigned(16#6#, 3));  -- ufix3 [12]

  -- Signals
  SIGNAL endIndReg                        : std_logic;  -- ufix1
  SIGNAL endIndNeg                        : std_logic;  -- ufix1
  SIGNAL softReset                        : std_logic;  -- ufix1
  SIGNAL intReset                         : std_logic;  -- ufix1
  SIGNAL data_signed                      : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL dataReg                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL validReg                         : std_logic;  -- ufix1
  SIGNAL frameValidReg                    : std_logic;  -- ufix1
  SIGNAL dataSel                          : std_logic;  -- ufix1
  SIGNAL const1                           : std_logic;  -- ufix1
  SIGNAL numiter_unsigned                 : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL termPassReg                      : std_logic;  -- ufix1
  SIGNAL rdAddr                           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL wrEnb                            : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL wrAddr                           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL wrData                           : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL data_array_14                    : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_13                    : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_12                    : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_11                    : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_10                    : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_9                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_8                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_7                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_6                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_5                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_4                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_3                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL data_array_2                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL sData                            : vector_of_std_logic_vector10(0 TO 13);  -- ufix10 [14]
  SIGNAL sData_signed                     : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL validMC                          : std_logic;  -- ufix1
  SIGNAL validMCReg                       : std_logic;  -- ufix1
  SIGNAL rdValidReg1                      : std_logic;  -- ufix1
  SIGNAL rdNeg                            : std_logic;  -- ufix1
  SIGNAL rdValidReg                       : std_logic;  -- ufix1
  SIGNAL betaTmp                          : std_logic;  -- ufix1
  SIGNAL betaRead                         : std_logic;  -- ufix1
  SIGNAL betaReadReg                      : std_logic;  -- ufix1
  SIGNAL countLayer                       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL bDecomp1                         : vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
  SIGNAL bDecomp2                         : vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
  SIGNAL bDecomp3                         : vector_of_std_logic_vector14(0 TO 13);  -- ufix14 [14]
  SIGNAL bValid                           : std_logic;  -- ufix1
  SIGNAL cDecomp1                         : vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
  SIGNAL cDecomp2                         : vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
  SIGNAL cDecomp3                         : vector_of_std_logic_vector14(0 TO 13);  -- ufix14 [14]
  SIGNAL cValid                           : std_logic;  -- ufix1
  SIGNAL countIdx                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL rdValid                          : std_logic;  -- ufix1
  SIGNAL yIndexTmp                        : std_logic_vector(2 DOWNTO 0);  -- ufix3
  SIGNAL yIndexTmp_unsigned               : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL cLayerIdx                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL ShiftWriteLUT_add_cast           : signed(31 DOWNTO 0);  -- int32
  SIGNAL ShiftWriteLUT_cast               : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL ShiftWriteLUT_mul_temp           : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL shiftValWrite                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL shiftValReg1                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL validCount                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL validCountReg                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL sub_Comp_sub_cast                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL sub_Comp_sub_temp                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL ShiftReadLUT_add_cast            : signed(31 DOWNTO 0);  -- int32
  SIGNAL ShiftReadLUT_cast                : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL ShiftReadLUT_mul_temp            : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL shiftValRead                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL shiftValReg                      : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL gammaValid                       : std_logic;  -- ufix1
  SIGNAL sValIn                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL gamma                            : vector_of_std_logic_vector10(0 TO 13);  -- ufix10 [14]
  SIGNAL gamma_signed                     : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL colData                          : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL sDataIn                          : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL sDataIn_1                        : vector_of_std_logic_vector10(0 TO 13);  -- ufix10 [14]
  SIGNAL validMCNeg                       : std_logic;  -- ufix1
  SIGNAL layerDone                        : std_logic;  -- ufix1
  SIGNAL layerDoneReg                     : std_logic;  -- ufix1
  SIGNAL iterationController_wrData       : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL iterationController_wrAddr       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_wrEnb        : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL iterationController_idxCount     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_wrCount      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_countLayer   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_betaRead     : std_logic;
  SIGNAL iterationController_countIdx     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL iterationController_validCount   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL iterationController_iterDone     : std_logic;
  SIGNAL iterationController_dataSel      : std_logic;
  SIGNAL iterationController_rdAddr       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_rdAddrFinal  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_iterCount    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL iterationController_noOp         : std_logic;
  SIGNAL iterationController_colCount     : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterationController_rdEnb        : std_logic;
  SIGNAL iterationController_readValid    : std_logic;
  SIGNAL iterationController_finalEnb     : std_logic;
  SIGNAL iterationController_zCount       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_rdCount      : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterationController_iterDoneReg  : std_logic;
  SIGNAL iterationController_indexCount   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_wrData_next  : vector_of_signed10(0 TO 13);  -- sfix10 [14]
  SIGNAL iterationController_wrAddr_next  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_wrEnb_next   : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL iterationController_idxCount_next : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_wrCount_next : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_countLayer_next : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_betaRead_next : std_logic;
  SIGNAL iterationController_countIdx_next : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL iterationController_validCount_next : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL iterationController_iterDone_next : std_logic;
  SIGNAL iterationController_dataSel_next : std_logic;
  SIGNAL iterationController_rdAddr_next  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_rdAddrFinal_next : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL iterationController_iterCount_next : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL iterationController_noOp_next    : std_logic;
  SIGNAL iterationController_colCount_next : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterationController_rdEnb_next   : std_logic;
  SIGNAL iterationController_readValid_next : std_logic;
  SIGNAL iterationController_finalEnb_next : std_logic;
  SIGNAL iterationController_zCount_next  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterationController_rdCount_next : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterationController_iterDoneReg_next : std_logic;
  SIGNAL iterationController_indexCount_next : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL iterDone                         : std_logic;  -- ufix1
  SIGNAL iterOut                          : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL data_array_1                     : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL colData_1                        : vector_of_std_logic_vector10(0 TO 13);  -- ufix10 [14]
  SIGNAL iterDoneReg                      : std_logic;  -- ufix1
  SIGNAL dataFinal                        : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL startFinal                       : std_logic;  -- ufix1
  SIGNAL validFinal                       : std_logic;  -- ufix1
  SIGNAL outputGeneration_dataOut         : std_logic;
  SIGNAL outputGeneration_startOut        : std_logic;
  SIGNAL outputGeneration_endOut          : std_logic;
  SIGNAL outputGeneration_validOut        : std_logic;
  SIGNAL outputGeneration_countIdx        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL outputGeneration_outCount        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL outputGeneration_startReg        : std_logic;
  SIGNAL outputGeneration_validReg        : std_logic;
  SIGNAL outputGeneration_dataReg         : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL outputGeneration_countIndex      : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL outputGeneration_dataOut_next    : std_logic;
  SIGNAL outputGeneration_startOut_next   : std_logic;
  SIGNAL outputGeneration_endOut_next     : std_logic;
  SIGNAL outputGeneration_validOut_next   : std_logic;
  SIGNAL outputGeneration_countIdx_next   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL outputGeneration_outCount_next   : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL outputGeneration_startReg_next   : std_logic;
  SIGNAL outputGeneration_validReg_next   : std_logic;
  SIGNAL outputGeneration_dataReg_next    : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL outputGeneration_countIndex_next : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL dataO                            : std_logic;  -- ufix1
  SIGNAL startO                           : std_logic;  -- ufix1
  SIGNAL endO                             : std_logic;  -- ufix1
  SIGNAL validO                           : std_logic;  -- ufix1
  SIGNAL zeroData                         : std_logic;  -- ufix1
  SIGNAL dataTmp                          : std_logic;  -- ufix1
  SIGNAL data_2                           : std_logic;  -- ufix1
  SIGNAL const0                           : std_logic;  -- ufix1
  SIGNAL startTmp                         : std_logic;  -- ufix1
  SIGNAL endTmp                           : std_logic;  -- ufix1
  SIGNAL validTmp                         : std_logic;  -- ufix1
  SIGNAL valid_2                          : std_logic;  -- ufix1

BEGIN
  u_Variable_Node_RAM : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(13)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(13),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_14
              );

  u_Variable_Node_RAM_1 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(12)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(12),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_13
              );

  u_Variable_Node_RAM_2 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(11)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(11),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_12
              );

  u_Variable_Node_RAM_3 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(10)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(10),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_11
              );

  u_Variable_Node_RAM_4 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(9)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(9),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_10
              );

  u_Variable_Node_RAM_5 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(8)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(8),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_9
              );

  u_Variable_Node_RAM_6 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(7)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(7),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_8
              );

  u_Variable_Node_RAM_7 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(6)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(6),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_7
              );

  u_Variable_Node_RAM_8 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(5)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(5),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_6
              );

  u_Variable_Node_RAM_9 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(4)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(4),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_5
              );

  u_Variable_Node_RAM_10 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(3)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(3),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_4
              );

  u_Variable_Node_RAM_11 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(2)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(2),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_3
              );

  u_Variable_Node_RAM_12 : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(1)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(1),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_2
              );

  u_BetaMemory : full_rx_ip_src_CheckNodeRAM
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              bdecomp1 => bDecomp1,  -- ufix7 [14]
              bdecomp2 => bDecomp2,  -- ufix4 [14]
              bdecomp3 => bDecomp3,  -- ufix14 [14]
              countlayer => std_logic_vector(countLayer),  -- ufix4
              enbread => betaReadReg,  -- ufix1
              bvalid => bValid,  -- ufix1
              bdecomp1Out => cDecomp1,  -- ufix7 [14]
              bdecomp2Out => cDecomp2,  -- ufix4 [14]
              bdecomp3Out => cDecomp3,  -- ufix14 [14]
              bvalidOut => cValid  -- ufix1
              );

  u_Barrel_Rotator_Unit : full_rx_ip_src_BarrelRotator
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              data => sDataIn_1,  -- sfix10 [14]
              shift => std_logic_vector(sValIn),  -- ufix4
              shiftData => sData  -- sfix10 [14]
              );

  u_FunctionalUnit : full_rx_ip_src_FunctionalUnit
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              reset => intReset,  -- ufix1
              data => sData,  -- sfix10 [14]
              valid => rdValidReg1,  -- ufix1
              count => std_logic_vector(countIdx),  -- ufix3
              betaComp1 => cDecomp1,  -- ufix7 [14]
              betaComp2 => cDecomp2,  -- ufix4 [14]
              betaComp3 => cDecomp3,  -- ufix14 [14]
              betaValid => cValid,  -- ufix1
              gamma => gamma,  -- sfix10 [14]
              valid_1 => gammaValid,  -- ufix1
              cnuComp1 => bDecomp1,  -- ufix7 [14]
              cnuComp2 => bDecomp2,  -- ufix4 [14]
              cnuComp3 => bDecomp3,  -- ufix14 [14]
              cnuValid => bValid,  -- ufix1
              rdAddr => yIndexTmp  -- ufix3
              );

  u_Variable_Node_RAM_generic : full_rx_ip_src_SimpleDualPortRAM_generic_block4
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 10
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wrData(0)),
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnb(0),  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => data_array_1
              );

  u_Final_Decision : full_rx_ip_src_FinalDecision
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              reset => intReset,  -- ufix1
              data => colData_1,  -- sfix10 [14]
              iterdone => iterDoneReg,  -- ufix1
              decbits => dataFinal,  -- ufix1 [14]
              start => startFinal,  -- ufix1
              valid => validFinal  -- ufix1
              );

  c_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      endIndReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endIndReg <= endind;
      END IF;
    END IF;
  END PROCESS c_process;


  endIndNeg <=  NOT endIndReg;

  softReset <= endIndNeg AND endind;

  intReset <= softReset OR reset;

  data_signed <= signed(data);

  c_1_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      dataReg <= to_signed(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataReg <= data_signed;
      END IF;
    END IF;
  END PROCESS c_1_process;


  c_2_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      validReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validReg <= valid;
      END IF;
    END IF;
  END PROCESS c_2_process;


  c_3_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      frameValidReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        frameValidReg <= framevalid;
      END IF;
    END IF;
  END PROCESS c_3_process;


  dataSel <=  NOT frameValidReg;

  const1 <= '1';

  numiter_unsigned <= unsigned(numiter);

  termPassReg <= '0';

  outputgen3: FOR k IN 0 TO 13 GENERATE
    sData_signed(k) <= signed(sData(k));
  END GENERATE;

  c_4_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      validMCReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validMCReg <= validMC;
      END IF;
    END IF;
  END PROCESS c_4_process;


  rdNeg <=  NOT rdValidReg1;

  betaTmp <= rdValidReg AND rdNeg;

  betaReadReg <= betaTmp AND betaRead;

  c_5_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      rdValidReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdValidReg <= rdValid;
      END IF;
    END IF;
  END PROCESS c_5_process;


  c_6_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      rdValidReg1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdValidReg1 <= rdValidReg;
      END IF;
    END IF;
  END PROCESS c_6_process;


  yIndexTmp_unsigned <= unsigned(yIndexTmp);

  ShiftWriteLUT_add_cast <= signed(resize(cLayerIdx, 32));
  ShiftWriteLUT_cast <= signed(resize(yIndexTmp_unsigned, 4));
  ShiftWriteLUT_mul_temp <= ShiftWriteLUT_cast * to_signed(16#0000000C#, 32);
  shiftValWrite <= ShiftWriteLUT_data(to_integer(ShiftWriteLUT_add_cast + resize(ShiftWriteLUT_mul_temp, 32)));

  c_7_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      shiftValReg1 <= to_unsigned(16#0#, 4);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        shiftValReg1 <= shiftValWrite;
      END IF;
    END IF;
  END PROCESS c_7_process;


  c_8_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      validCountReg <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validCountReg <= validCount;
      END IF;
    END IF;
  END PROCESS c_8_process;


  sub_Comp_sub_cast <= '0' & '0' & '0' & '0' & const1;
  sub_Comp_sub_temp <= resize(countLayer, 5) - sub_Comp_sub_cast;
  
  cLayerIdx <= "1111" WHEN sub_Comp_sub_temp(4) /= '0' ELSE
      sub_Comp_sub_temp(3 DOWNTO 0);

  ShiftReadLUT_add_cast <= signed(resize(cLayerIdx, 32));
  ShiftReadLUT_cast <= signed(resize(validCountReg, 4));
  ShiftReadLUT_mul_temp <= ShiftReadLUT_cast * to_signed(16#0000000C#, 32);
  shiftValRead <= ShiftReadLUT_data(to_integer(ShiftReadLUT_add_cast + resize(ShiftReadLUT_mul_temp, 32)));

  c_9_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      shiftValReg <= to_unsigned(16#0#, 4);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        shiftValReg <= shiftValRead;
      END IF;
    END IF;
  END PROCESS c_9_process;


  
  sValIn <= shiftValReg WHEN gammaValid = '0' ELSE
      shiftValReg1;

  outputgen2: FOR k IN 0 TO 13 GENERATE
    gamma_signed(k) <= signed(gamma(k));
  END GENERATE;

  
  sDataIn <= colData WHEN gammaValid = '0' ELSE
      gamma_signed;

  outputgen1: FOR k IN 0 TO 13 GENERATE
    sDataIn_1(k) <= std_logic_vector(sDataIn(k));
  END GENERATE;

  c_10_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      validMC <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validMC <= gammaValid;
      END IF;
    END IF;
  END PROCESS c_10_process;


  validMCNeg <=  NOT validMC;

  layerDone <= validMCNeg AND validMCReg;

  c_11_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      layerDoneReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        layerDoneReg <= layerDone;
      END IF;
    END IF;
  END PROCESS c_11_process;


  iterationController_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      iterationController_wrAddr <= to_unsigned(16#00#, 5);
      iterationController_wrData <= (OTHERS => to_signed(16#000#, 10));
      iterationController_wrEnb <= (OTHERS => '0');
      iterationController_idxCount <= to_unsigned(16#1#, 4);
      iterationController_indexCount <= to_unsigned(16#1#, 4);
      iterationController_wrCount <= to_unsigned(16#01#, 5);
      iterationController_countLayer <= to_unsigned(16#1#, 4);
      iterationController_betaRead <= '0';
      iterationController_countIdx <= to_unsigned(16#0#, 3);
      iterationController_validCount <= to_unsigned(16#0#, 3);
      iterationController_iterDone <= '0';
      iterationController_dataSel <= '0';
      iterationController_rdAddr <= to_unsigned(16#00#, 5);
      iterationController_rdAddrFinal <= to_unsigned(16#01#, 5);
      iterationController_iterCount <= to_unsigned(16#00#, 8);
      iterationController_noOp <= '0';
      iterationController_colCount <= to_unsigned(16#01#, 7);
      iterationController_rdEnb <= '0';
      iterationController_readValid <= '0';
      iterationController_finalEnb <= '0';
      iterationController_zCount <= to_unsigned(16#0#, 4);
      iterationController_rdCount <= to_unsigned(16#01#, 7);
      iterationController_iterDoneReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        iterationController_wrAddr <= iterationController_wrAddr_next;
        iterationController_wrData <= iterationController_wrData_next;
        iterationController_wrEnb <= iterationController_wrEnb_next;
        iterationController_idxCount <= iterationController_idxCount_next;
        iterationController_wrCount <= iterationController_wrCount_next;
        iterationController_countLayer <= iterationController_countLayer_next;
        iterationController_betaRead <= iterationController_betaRead_next;
        iterationController_countIdx <= iterationController_countIdx_next;
        iterationController_validCount <= iterationController_validCount_next;
        iterationController_iterDone <= iterationController_iterDone_next;
        iterationController_dataSel <= iterationController_dataSel_next;
        iterationController_rdAddr <= iterationController_rdAddr_next;
        iterationController_rdAddrFinal <= iterationController_rdAddrFinal_next;
        iterationController_iterCount <= iterationController_iterCount_next;
        iterationController_noOp <= iterationController_noOp_next;
        iterationController_colCount <= iterationController_colCount_next;
        iterationController_rdEnb <= iterationController_rdEnb_next;
        iterationController_readValid <= iterationController_readValid_next;
        iterationController_finalEnb <= iterationController_finalEnb_next;
        iterationController_zCount <= iterationController_zCount_next;
        iterationController_rdCount <= iterationController_rdCount_next;
        iterationController_iterDoneReg <= iterationController_iterDoneReg_next;
        iterationController_indexCount <= iterationController_indexCount_next;
      END IF;
    END IF;
  END PROCESS iterationController_process;

  iterationController_output : PROCESS (dataReg, dataSel, iterationController_betaRead, iterationController_colCount,
       iterationController_countIdx, iterationController_countLayer,
       iterationController_dataSel, iterationController_finalEnb,
       iterationController_idxCount, iterationController_indexCount,
       iterationController_iterCount, iterationController_iterDone,
       iterationController_iterDoneReg, iterationController_noOp,
       iterationController_rdAddr, iterationController_rdAddrFinal,
       iterationController_rdCount, iterationController_rdEnb,
       iterationController_readValid, iterationController_validCount,
       iterationController_wrAddr, iterationController_wrCount,
       iterationController_wrData, iterationController_wrEnb,
       iterationController_zCount, layerDoneReg, numiter_unsigned, reset,
       sData_signed, softReset, termPassReg, validMC, validReg)
    VARIABLE resetcount : std_logic;
    VARIABLE trigger : std_logic;
    VARIABLE layerDone1 : std_logic;
    VARIABLE rdFinEnb : std_logic;
    VARIABLE countLayer_temp : unsigned(3 DOWNTO 0);
    VARIABLE countIdx_temp : unsigned(2 DOWNTO 0);
    VARIABLE validCount_temp : unsigned(2 DOWNTO 0);
    VARIABLE iterDone_temp : std_logic;
    VARIABLE dataSel_temp : std_logic;
    VARIABLE rdAddrFinal_temp : unsigned(4 DOWNTO 0);
    VARIABLE noOp_temp : std_logic;
    VARIABLE rdEnb_temp : std_logic;
    VARIABLE readValid_temp : std_logic;
    VARIABLE finalEnb_temp : std_logic;
    VARIABLE zCount_temp : unsigned(3 DOWNTO 0);
    VARIABLE rdCount_temp : unsigned(6 DOWNTO 0);
    VARIABLE add_temp : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(8 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
    VARIABLE add_temp_1 : vector_of_signed32(0 TO 13);
    VARIABLE cast : vector_of_unsigned4(0 TO 13);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 13);
    VARIABLE sub_cast_2 : vector_of_signed32(0 TO 13);
    VARIABLE sub_cast_3 : signed(31 DOWNTO 0);
  BEGIN
    add_temp := to_unsigned(16#000#, 9);
    add_temp_0 := to_unsigned(16#000#, 9);
    sub_cast := to_signed(16#00000000#, 32);
    countLayer_temp := iterationController_countLayer;
    validCount_temp := iterationController_validCount;
    rdAddrFinal_temp := iterationController_rdAddrFinal;
    noOp_temp := iterationController_noOp;
    rdEnb_temp := iterationController_rdEnb;
    readValid_temp := iterationController_readValid;
    finalEnb_temp := iterationController_finalEnb;
    zCount_temp := iterationController_zCount;
    rdCount_temp := iterationController_rdCount;
    iterationController_wrAddr_next <= iterationController_wrAddr;
    iterationController_wrData_next <= iterationController_wrData;
    iterationController_wrEnb_next <= iterationController_wrEnb;
    iterationController_idxCount_next <= iterationController_idxCount;
    iterationController_wrCount_next <= iterationController_wrCount;
    iterationController_betaRead_next <= iterationController_betaRead;
    iterationController_iterCount_next <= iterationController_iterCount;
    iterationController_colCount_next <= iterationController_colCount;
    iterationController_indexCount_next <= iterationController_indexCount;
    IF iterationController_dataSel = '1' THEN 
      IF iterationController_iterDone = '1' THEN 
        rdAddr <= iterationController_rdAddrFinal;
      ELSE 
        rdAddr <= iterationController_rdAddr;
      END IF;
    ELSE 
      rdAddr <= to_unsigned(16#01#, 5);
    END IF;
    layerDone1 := layerDoneReg;
    IF termPassReg /= '0' THEN 
      IF iterationController_iterCount = numiter_unsigned THEN 
        iterOut <= numiter_unsigned;
      ELSE 
        add_temp := resize(iterationController_iterCount, 9) + to_unsigned(16#001#, 9);
        IF add_temp(8) /= '0' THEN 
          iterOut <= "11111111";
        ELSE 
          iterOut <= add_temp(7 DOWNTO 0);
        END IF;
      END IF;
    ELSE 
      iterOut <= numiter_unsigned;
    END IF;
    IF reset /= '0' THEN 
      noOp_temp := '1';
    ELSIF softReset /= '0' THEN 
      noOp_temp := '0';
    END IF;
    IF noOp_temp = '1' THEN 
      dataSel_temp := '0';
    ELSE 
      dataSel_temp := dataSel;
    END IF;
    IF reset /= '0' THEN 
      iterDone_temp := '0';
      countLayer_temp := to_unsigned(16#1#, 4);
      iterationController_iterCount_next <= to_unsigned(16#00#, 8);
      iterationController_betaRead_next <= '0';
      resetcount := '1';
    ELSIF (iterationController_iterCount = numiter_unsigned) OR (termPassReg /= '0') THEN 
      iterDone_temp := '1';
      resetcount := '1';
    ELSE 
      iterDone_temp := '0';
      IF (layerDone1 AND dataSel_temp) = '1' THEN 
        IF iterationController_countLayer = to_unsigned(16#C#, 4) THEN 
          iterationController_betaRead_next <= '1';
          add_temp_0 := resize(iterationController_iterCount, 9) + to_unsigned(16#001#, 9);
          IF add_temp_0(8) /= '0' THEN 
            iterationController_iterCount_next <= "11111111";
          ELSE 
            iterationController_iterCount_next <= add_temp_0(7 DOWNTO 0);
          END IF;
          countLayer_temp := to_unsigned(16#1#, 4);
          resetcount := '1';
        ELSE 
          countLayer_temp := iterationController_countLayer + to_unsigned(16#1#, 4);
          resetcount := '0';
        END IF;
      ELSE 
        resetcount := '0';
      END IF;
    END IF;
    IF reset /= '0' THEN 
      iterationController_wrData_next <= (OTHERS => to_signed(16#000#, 10));
      iterationController_wrEnb_next <= (OTHERS => '0');
      iterationController_wrAddr_next <= to_unsigned(16#00#, 5);
      iterationController_idxCount_next <= to_unsigned(16#1#, 4);
      iterationController_indexCount_next <= to_unsigned(16#1#, 4);
      iterationController_wrCount_next <= to_unsigned(16#01#, 5);
      zCount_temp := to_unsigned(16#0#, 4);
      validCount_temp := to_unsigned(16#0#, 3);
      rdEnb_temp := '0';
      readValid_temp := '0';
      rdAddrFinal_temp := to_unsigned(16#01#, 5);
      rdCount_temp := to_unsigned(16#01#, 7);
      finalEnb_temp := '0';
      iterationController_colCount_next <= to_unsigned(16#01#, 7);
    ELSIF ( NOT dataSel_temp) = '1' THEN 
      IF validReg /= '0' THEN 
        iterationController_wrData_next <= (OTHERS => to_signed(16#000#, 10));
        iterationController_wrEnb_next <= (OTHERS => '0');

        FOR idx IN 0 TO 13 LOOP
          add_temp_1(idx) := to_signed(idx + 1, 32);
          cast(idx) := unsigned(add_temp_1(idx)(3 DOWNTO 0));
          IF iterationController_idxCount = cast(idx) THEN 
            sub_cast_1(idx) := signed(resize(iterationController_idxCount, 32));
            iterationController_wrEnb_next(to_integer(sub_cast_1(idx) - 1)) <= '1';
            sub_cast_2(idx) := signed(resize(iterationController_idxCount, 32));
            iterationController_wrData_next(to_integer(sub_cast_2(idx) - 1)) <= dataReg;
          END IF;
        END LOOP;

        iterationController_wrAddr_next <= iterationController_wrCount;
        IF iterationController_indexCount = to_unsigned(16#E#, 4) THEN 
          iterationController_idxCount_next <= to_unsigned(16#1#, 4);
          iterationController_indexCount_next <= to_unsigned(16#1#, 4);
          iterationController_wrCount_next <= iterationController_wrCount + to_unsigned(16#01#, 5);
        ELSE 
          iterationController_indexCount_next <= iterationController_indexCount + to_unsigned(16#1#, 4);
          iterationController_idxCount_next <= iterationController_idxCount + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    ELSE 
      IF validMC /= '0' THEN 
        iterationController_wrData_next <= sData_signed;
        iterationController_wrEnb_next <= (OTHERS => '1');
        sub_cast := signed(resize(iterationController_colCount, 32));
        iterationController_wrAddr_next <= iterationController_data(to_integer(sub_cast - 1));
      ELSE 
        iterationController_wrEnb_next <= (OTHERS => '0');
      END IF;
      IF resetcount = '1' THEN 
        iterationController_colCount_next <= to_unsigned(16#01#, 7);
      ELSIF validMC /= '0' THEN 
        iterationController_colCount_next <= iterationController_colCount + to_unsigned(16#01#, 7);
      END IF;
    END IF;
    sub_cast_0 := signed(resize(countLayer_temp, 32));
    countIdx_temp := iterationcontroller_data_0(to_integer(sub_cast_0 - 1)) - to_unsigned(16#1#, 3);
    trigger := softReset OR layerDone1;
    IF ((trigger AND ( NOT iterDone_temp)) AND dataSel_temp) = '1' THEN 
      rdEnb_temp := '1';
    ELSIF iterDone_temp = '1' THEN 
      rdEnb_temp := '0';
    END IF;
    IF dataSel_temp = '1' THEN 
      rdValid <= readValid_temp;
    ELSE 
      rdValid <= '0';
    END IF;
    readValid_temp := rdEnb_temp;
    IF (rdEnb_temp AND dataSel_temp) = '1' THEN 
      IF validCount_temp = countIdx_temp THEN 
        validCount_temp := to_unsigned(16#0#, 3);
        rdEnb_temp := '0';
      ELSE 
        validCount_temp := validCount_temp + to_unsigned(16#1#, 3);
      END IF;
    ELSE 
      validCount_temp := to_unsigned(16#0#, 3);
    END IF;
    sub_cast_3 := signed(resize(rdCount_temp, 32));
    iterationController_rdAddr_next <= iterationController_data(to_integer(sub_cast_3 - 1));
    IF dataSel_temp = '1' THEN 
      IF resetcount = '1' THEN 
        rdCount_temp := to_unsigned(16#02#, 7);
      ELSIF readValid_temp = '1' THEN 
        rdCount_temp := rdCount_temp + to_unsigned(16#01#, 7);
      END IF;
    ELSE 
      rdCount_temp := to_unsigned(16#01#, 7);
    END IF;
    IF iterationController_iterDoneReg = '1' THEN 
      finalEnb_temp := '1';
    END IF;
    IF reset /= '0' THEN 
      zCount_temp := to_unsigned(16#0#, 4);
      rdFinEnb := '0';
    ELSIF zCount_temp = to_unsigned(16#D#, 4) THEN 
      zCount_temp := to_unsigned(16#0#, 4);
      rdFinEnb := '1';
    ELSE 
      IF finalEnb_temp = '1' THEN 
        zCount_temp := zCount_temp + to_unsigned(16#1#, 4);
      END IF;
      rdFinEnb := '0';
    END IF;
    IF reset /= '0' THEN 
      finalEnb_temp := '0';
      rdAddrFinal_temp := to_unsigned(16#01#, 5);
    ELSIF finalEnb_temp = '1' THEN 
      IF rdAddrFinal_temp = to_unsigned(16#0C#, 5) THEN 
        finalEnb_temp := '0';
      ELSIF rdFinEnb = '1' THEN 
        rdAddrFinal_temp := rdAddrFinal_temp + to_unsigned(16#01#, 5);
      END IF;
    ELSE 
      rdAddrFinal_temp := to_unsigned(16#01#, 5);
    END IF;
    iterationController_iterDoneReg_next <= iterDone_temp;
    wrAddr <= iterationController_wrAddr;
    wrData <= iterationController_wrData;
    wrEnb <= iterationController_wrEnb;
    countLayer <= iterationController_countLayer;
    countIdx <= iterationController_countIdx;
    validCount <= iterationController_validCount;
    iterDone <= iterationController_iterDone;
    betaRead <= iterationController_betaRead;
    iterationController_countLayer_next <= countLayer_temp;
    iterationController_countIdx_next <= countIdx_temp;
    iterationController_validCount_next <= validCount_temp;
    iterationController_iterDone_next <= iterDone_temp;
    iterationController_dataSel_next <= dataSel_temp;
    iterationController_rdAddrFinal_next <= rdAddrFinal_temp;
    iterationController_noOp_next <= noOp_temp;
    iterationController_rdEnb_next <= rdEnb_temp;
    iterationController_readValid_next <= readValid_temp;
    iterationController_finalEnb_next <= finalEnb_temp;
    iterationController_zCount_next <= zCount_temp;
    iterationController_rdCount_next <= rdCount_temp;
  END PROCESS iterationController_output;


  colData(0) <= signed(data_array_1);
  colData(1) <= signed(data_array_2);
  colData(2) <= signed(data_array_3);
  colData(3) <= signed(data_array_4);
  colData(4) <= signed(data_array_5);
  colData(5) <= signed(data_array_6);
  colData(6) <= signed(data_array_7);
  colData(7) <= signed(data_array_8);
  colData(8) <= signed(data_array_9);
  colData(9) <= signed(data_array_10);
  colData(10) <= signed(data_array_11);
  colData(11) <= signed(data_array_12);
  colData(12) <= signed(data_array_13);
  colData(13) <= signed(data_array_14);

  outputgen: FOR k IN 0 TO 13 GENERATE
    colData_1(k) <= std_logic_vector(colData(k));
  END GENERATE;

  c_12_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      iterDoneReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        iterDoneReg <= iterDone;
      END IF;
    END IF;
  END PROCESS c_12_process;


  outputGeneration_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      outputGeneration_startReg <= '0';
      outputGeneration_validReg <= '0';
      outputGeneration_dataReg <= (OTHERS => '0');
      outputGeneration_startOut <= '0';
      outputGeneration_endOut <= '0';
      outputGeneration_validOut <= '0';
      outputGeneration_countIdx <= to_unsigned(16#1#, 4);
      outputGeneration_outCount <= to_unsigned(16#01#, 8);
      outputGeneration_dataOut <= '0';
      outputGeneration_countIndex <= to_unsigned(16#1#, 4);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        outputGeneration_dataOut <= outputGeneration_dataOut_next;
        outputGeneration_startOut <= outputGeneration_startOut_next;
        outputGeneration_endOut <= outputGeneration_endOut_next;
        outputGeneration_validOut <= outputGeneration_validOut_next;
        outputGeneration_countIdx <= outputGeneration_countIdx_next;
        outputGeneration_outCount <= outputGeneration_outCount_next;
        outputGeneration_startReg <= outputGeneration_startReg_next;
        outputGeneration_validReg <= outputGeneration_validReg_next;
        outputGeneration_dataReg <= outputGeneration_dataReg_next;
        outputGeneration_countIndex <= outputGeneration_countIndex_next;
      END IF;
    END IF;
  END PROCESS outputGeneration_process;

  outputGeneration_output : PROCESS (dataFinal, outputGeneration_countIdx, outputGeneration_countIndex,
       outputGeneration_dataOut, outputGeneration_dataReg,
       outputGeneration_endOut, outputGeneration_outCount,
       outputGeneration_startOut, outputGeneration_startReg,
       outputGeneration_validOut, outputGeneration_validReg, reset, startFinal,
       validFinal)
    VARIABLE countIdx_temp1 : unsigned(3 DOWNTO 0);
    VARIABLE sub_cast1 : signed(31 DOWNTO 0);
  BEGIN
    countIdx_temp1 := outputGeneration_countIdx;
    outputGeneration_endOut_next <= outputGeneration_endOut;
    outputGeneration_outCount_next <= outputGeneration_outCount;
    outputGeneration_dataReg_next <= outputGeneration_dataReg;
    outputGeneration_countIndex_next <= outputGeneration_countIndex;
    IF reset /= '0' THEN 
      countIdx_temp1 := to_unsigned(16#1#, 4);
      outputGeneration_countIndex_next <= to_unsigned(16#1#, 4);
      outputGeneration_startOut_next <= '0';
      outputGeneration_validOut_next <= '0';
      outputGeneration_outCount_next <= to_unsigned(16#01#, 8);
      outputGeneration_endOut_next <= '0';
    ELSIF (outputGeneration_startReg AND outputGeneration_validReg) = '1' THEN 
      countIdx_temp1 := to_unsigned(16#1#, 4);
      outputGeneration_countIndex_next <= to_unsigned(16#1#, 4);
      outputGeneration_startOut_next <= '1';
      outputGeneration_validOut_next <= '1';
      outputGeneration_outCount_next <= to_unsigned(16#01#, 8);
    ELSE 
      outputGeneration_startOut_next <= '0';
      IF (outputGeneration_validReg AND ( NOT outputGeneration_endOut)) = '1' THEN 
        IF outputGeneration_countIndex = to_unsigned(16#E#, 4) THEN 
          countIdx_temp1 := to_unsigned(16#1#, 4);
          outputGeneration_countIndex_next <= to_unsigned(16#1#, 4);
        ELSE 
          outputGeneration_countIndex_next <= outputGeneration_countIndex + to_unsigned(16#1#, 4);
          countIdx_temp1 := outputGeneration_countIdx + to_unsigned(16#1#, 4);
        END IF;
        outputGeneration_validOut_next <= '1';
        IF outputGeneration_outCount = to_unsigned(16#A7#, 8) THEN 
          outputGeneration_outCount_next <= to_unsigned(16#01#, 8);
          outputGeneration_endOut_next <= '1';
        ELSE 
          outputGeneration_outCount_next <= outputGeneration_outCount + to_unsigned(16#01#, 8);
          outputGeneration_endOut_next <= '0';
        END IF;
      ELSE 
        outputGeneration_validOut_next <= '0';
        outputGeneration_endOut_next <= '0';
      END IF;
    END IF;
    sub_cast1 := signed(resize(countIdx_temp1, 32));
    outputGeneration_dataOut_next <= outputGeneration_dataReg(to_integer(sub_cast1 - 1));
    IF ( NOT outputGeneration_validReg) = '1' THEN 
      outputGeneration_dataOut_next <= '0';
    END IF;
    IF reset /= '0' THEN 
      outputGeneration_startReg_next <= '0';
      outputGeneration_validReg_next <= '0';
      outputGeneration_dataReg_next <= (OTHERS => '0');
    ELSE 

      FOR t_0 IN 0 TO 13 LOOP
        outputGeneration_dataReg_next(t_0) <= dataFinal(t_0);
      END LOOP;

      outputGeneration_startReg_next <= startFinal;
      outputGeneration_validReg_next <= validFinal;
    END IF;
    dataO <= outputGeneration_dataOut;
    startO <= outputGeneration_startOut;
    endO <= outputGeneration_endOut;
    validO <= outputGeneration_validOut;
    outputGeneration_countIdx_next <= countIdx_temp1;
  END PROCESS outputGeneration_output;


  zeroData <= '0';

  
  dataTmp <= zeroData WHEN validO = '0' ELSE
      dataO;

  dataOut_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      data_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        data_2 <= dataTmp;
      END IF;
    END IF;
  END PROCESS dataOut_process;


  const0 <= '0';

  
  startTmp <= const0 WHEN validO = '0' ELSE
      startO;

  startOut_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      start <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        start <= startTmp;
      END IF;
    END IF;
  END PROCESS startOut_process;


  
  endTmp <= const0 WHEN validO = '0' ELSE
      endO;

  endOut_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      end_rsvd <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        end_rsvd <= endTmp;
      END IF;
    END IF;
  END PROCESS endOut_process;


  
  validTmp <= const0 WHEN validO = '0' ELSE
      validO;

  validOut_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      valid_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        valid_2 <= validTmp;
      END IF;
    END IF;
  END PROCESS validOut_process;


  data_1 <= data_2;

  valid_1 <= valid_2;

END rtl;

