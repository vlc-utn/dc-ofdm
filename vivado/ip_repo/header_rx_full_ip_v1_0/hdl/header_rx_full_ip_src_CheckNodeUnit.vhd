-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRxHeader/header_rx_full_ip_src_CheckNodeUnit.vhd
-- Created: 2024-10-03 10:46:52
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: header_rx_full_ip_src_CheckNodeUnit
-- Source Path: HDLRxHeader/h_rx_full/LDPC_Deco_Hc_12H/DecoderCore/FunctionalUnit/CheckNodeUnit
-- Hierarchy Level: 4
-- Model version: 1.36
-- 
-- Check Node Unit
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.header_rx_full_ip_src_h_rx_full_pac.ALL;

ENTITY header_rx_full_ip_src_CheckNodeUnit IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        data                              :   IN    vector_of_std_logic_vector4(0 TO 13);  -- sfix4 [14]
        valid                             :   IN    std_logic;  -- ufix1
        count                             :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
        reset                             :   IN    std_logic;  -- ufix1
        cnuDecomp1                        :   OUT   vector_of_std_logic_vector7(0 TO 13);  -- ufix7 [14]
        cnuDecomp2                        :   OUT   vector_of_std_logic_vector4(0 TO 13);  -- ufix4 [14]
        cnuDecomp3                        :   OUT   vector_of_std_logic_vector6(0 TO 13);  -- ufix6 [14]
        cnuvalid                          :   OUT   std_logic  -- ufix1
        );
END header_rx_full_ip_src_CheckNodeUnit;


ARCHITECTURE rtl OF header_rx_full_ip_src_CheckNodeUnit IS

  -- Constants
  CONSTANT minCalculation_data            : vector_of_unsigned7(0 TO 8) := 
    (to_unsigned(16#01#, 7), to_unsigned(16#40#, 7), to_unsigned(16#20#, 7), to_unsigned(16#10#, 7),
     to_unsigned(16#08#, 7), to_unsigned(16#04#, 7), to_unsigned(16#02#, 7), to_unsigned(16#01#, 7),
     to_unsigned(16#01#, 7));  -- ufix7 [9]

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;

  -- HDLCODER_TO_SIGNED
  FUNCTION hdlcoder_to_signed(arg: boolean; width: integer) RETURN signed IS
  BEGIN
    IF arg THEN
      RETURN to_signed(1, width);
    ELSE
      RETURN to_signed(0, width);
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL data_signed                      : vector_of_signed4(0 TO 13);  -- sfix4 [14]
  SIGNAL alpha_reg                        : vector_of_signed4(0 TO 27);  -- sfix4 [28]
  SIGNAL dataReg                          : vector_of_signed4(0 TO 13);  -- sfix4 [14]
  SIGNAL alpha_reg_1                      : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL validReg                         : std_logic;  -- ufix1
  SIGNAL count_unsigned                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL alpha_reg_2                      : vector_of_unsigned3(0 TO 1);  -- ufix3 [2]
  SIGNAL countReg                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL const1                           : std_logic;  -- ufix1
  SIGNAL AddComp_add_cast                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL countU                           : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL validD                           : std_logic;  -- ufix1
  SIGNAL validDNeg                        : std_logic;  -- ufix1
  SIGNAL intReset                         : std_logic;  -- ufix1
  SIGNAL extReset                         : std_logic;  -- ufix1
  SIGNAL dataAbs                          : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_minVal1           : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_minVal2           : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_dataAbs           : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_minIdx            : vector_of_unsigned3(0 TO 13);  -- ufix3 [14]
  SIGNAL minCalculation_countIdx          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL minCalculation_signsAll          : vector_of_unsigned7(0 TO 13);  -- ufix7 [14]
  SIGNAL minCalculation_prodSign          : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL minCalculation_validOut          : std_logic;
  SIGNAL minCalculation_validReg          : std_logic;
  SIGNAL minCalculation_countIdxReg1      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL minCalculation_minVal1_next      : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_minVal2_next      : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_dataAbs_next      : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minCalculation_minIdx_next       : vector_of_unsigned3(0 TO 13);  -- ufix3 [14]
  SIGNAL minCalculation_countIdx_next     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL minCalculation_signsAll_next     : vector_of_unsigned7(0 TO 13);  -- ufix7 [14]
  SIGNAL minCalculation_prodSign_next     : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL minCalculation_validOut_next     : std_logic;
  SIGNAL minCalculation_validReg_next     : std_logic;
  SIGNAL minCalculation_countIdxReg1_next : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL minVal1                          : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minVal2                          : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL minindex                         : vector_of_unsigned3(0 TO 13);  -- ufix3 [14]
  SIGNAL signs1                           : vector_of_unsigned7(0 TO 13);  -- ufix7 [14]
  SIGNAL prodsign                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL validD_1                         : std_logic;  -- ufix1
  SIGNAL prodsign_0                       : std_logic;  -- ufix1
  SIGNAL prodsign_1                       : std_logic;  -- ufix1
  SIGNAL prodsign_2                       : std_logic;  -- ufix1
  SIGNAL prodsign_3                       : std_logic;  -- ufix1
  SIGNAL prodsign_4                       : std_logic;  -- ufix1
  SIGNAL prodsign_5                       : std_logic;  -- ufix1
  SIGNAL prodsign_6                       : std_logic;  -- ufix1
  SIGNAL prodsign_7                       : std_logic;  -- ufix1
  SIGNAL prodsign_8                       : std_logic;  -- ufix1
  SIGNAL prodsign_9                       : std_logic;  -- ufix1
  SIGNAL prodsign_10                      : std_logic;  -- ufix1
  SIGNAL prodsign_11                      : std_logic;  -- ufix1
  SIGNAL prodsign_12                      : std_logic;  -- ufix1
  SIGNAL prodsign_13                      : std_logic;  -- ufix1
  SIGNAL minindex_0                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_1                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_1                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_2                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_2                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_3                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_3                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_4                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_4                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_5                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_5                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_6                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_6                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_7                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_7                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_8                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_8                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_9                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_9                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_10                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_10                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_11                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_11                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_12                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_12                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_13                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL minindex_13                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp2_arr_14                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL betacomp2D                       : vector_of_unsigned4(0 TO 13);  -- ufix4 [14]
  SIGNAL min1_DTC                         : vector_of_unsigned3(0 TO 13);  -- ufix3 [14]
  SIGNAL min1_DTC_0                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min2_DTC                         : vector_of_unsigned3(0 TO 13);  -- ufix3 [14]
  SIGNAL min1_DTC_1                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_2                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_3                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_4                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_5                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_6                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_7                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_8                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_9                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_10                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_11                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_12                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min1_DTC_13                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL min2_DTC_0                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_1                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_1                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_2                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_2                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_3                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_3                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_4                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_4                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_5                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_5                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_6                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_6                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_7                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_7                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_8                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_8                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_9                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_9                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_10                 : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_10                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_11                 : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_11                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_12                 : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_12                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_13                 : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL min2_DTC_13                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL betacomp3_arr_14                 : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL betacomp3D                       : vector_of_unsigned6(0 TO 13);  -- ufix6 [14]

BEGIN
  outputgen3: FOR k1 IN 0 TO 13 GENERATE
    data_signed(k1) <= signed(data(k1));
  END GENERATE;

  c_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_reg <= (OTHERS => to_signed(16#0#, 4));
      ELSIF enb = '1' THEN
        alpha_reg(0 TO 13) <= data_signed(0 TO 13);
        alpha_reg(14 TO 27) <= alpha_reg(0 TO 13);
      END IF;
    END IF;
  END PROCESS c_process;

  dataReg(0 TO 13) <= alpha_reg(14 TO 27);

  c_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_reg_1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        alpha_reg_1(0) <= valid;
        alpha_reg_1(1) <= alpha_reg_1(0);
      END IF;
    END IF;
  END PROCESS c_1_process;

  validReg <= alpha_reg_1(1);

  count_unsigned <= unsigned(count);

  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_reg_2 <= (OTHERS => to_unsigned(16#0#, 3));
      ELSIF enb = '1' THEN
        alpha_reg_2(0) <= count_unsigned;
        alpha_reg_2(1) <= alpha_reg_2(0);
      END IF;
    END IF;
  END PROCESS c_2_process;

  countReg <= alpha_reg_2(1);

  const1 <= '1';

  AddComp_add_cast <= '0' & '0' & const1;
  countU <= countReg + AddComp_add_cast;

  c_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validD <= '0';
      ELSIF enb = '1' THEN
        validD <= valid;
      END IF;
    END IF;
  END PROCESS c_3_process;


  validDNeg <=  NOT validD;

  intReset <= valid AND validDNeg;

  extReset <= reset OR intReset;

  abs_rsvd_output : PROCESS (dataReg)
    VARIABLE extend_temp : signed(4 DOWNTO 0);
  BEGIN
    extend_temp := to_signed(16#00#, 5);

    FOR k IN 0 TO 13 LOOP
      IF dataReg(k) < to_signed(16#0#, 4) THEN 
        extend_temp :=  - (resize(dataReg(k), 5));
      ELSE 
        extend_temp := resize(dataReg(k), 5);
      END IF;
      dataAbs(k) <= unsigned(extend_temp(3 DOWNTO 0));
    END LOOP;

  END PROCESS abs_rsvd_output;


  minCalculation_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        minCalculation_countIdx <= to_unsigned(16#0#, 3);
        minCalculation_minVal1 <= (OTHERS => to_unsigned(16#7#, 4));
        minCalculation_minVal2 <= (OTHERS => to_unsigned(16#7#, 4));
        minCalculation_dataAbs <= (OTHERS => to_unsigned(16#0#, 4));
        minCalculation_minIdx <= (OTHERS => to_unsigned(16#0#, 3));
        minCalculation_signsAll <= (OTHERS => to_unsigned(16#7F#, 7));
        minCalculation_prodSign <= (OTHERS => '1');
        minCalculation_validOut <= '0';
        minCalculation_validReg <= '0';
        minCalculation_countIdxReg1 <= to_unsigned(16#0#, 3);
      ELSIF enb = '1' THEN
        minCalculation_countIdx <= minCalculation_countIdx_next;
        minCalculation_minVal1 <= minCalculation_minVal1_next;
        minCalculation_minVal2 <= minCalculation_minVal2_next;
        minCalculation_dataAbs <= minCalculation_dataAbs_next;
        minCalculation_minIdx <= minCalculation_minIdx_next;
        minCalculation_signsAll <= minCalculation_signsAll_next;
        minCalculation_prodSign <= minCalculation_prodSign_next;
        minCalculation_validOut <= minCalculation_validOut_next;
        minCalculation_validReg <= minCalculation_validReg_next;
        minCalculation_countIdxReg1 <= minCalculation_countIdxReg1_next;
      END IF;
    END IF;
  END PROCESS minCalculation_process;

  minCalculation_output : PROCESS (countU, dataAbs, dataReg, extReset, minCalculation_countIdx,
       minCalculation_countIdxReg1, minCalculation_dataAbs,
       minCalculation_minIdx, minCalculation_minVal1, minCalculation_minVal2,
       minCalculation_prodSign, minCalculation_signsAll,
       minCalculation_validOut, minCalculation_validReg, validReg)
    VARIABLE xorval : unsigned(6 DOWNTO 0);
    VARIABLE signVal : std_logic;
    VARIABLE minVal1_temp : vector_of_unsigned4(0 TO 13);
    VARIABLE minVal2_temp : vector_of_unsigned4(0 TO 13);
    VARIABLE minIdx_temp : vector_of_unsigned3(0 TO 13);
    VARIABLE countIdx_temp : unsigned(2 DOWNTO 0);
    VARIABLE signsAll_temp : vector_of_unsigned7(0 TO 13);
    VARIABLE prodSign_temp : std_logic_vector(13 DOWNTO 0);
    VARIABLE add_temp : unsigned(3 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE cast : vector_of_signed32(0 TO 13);
  BEGIN
    signVal := '0';
    countIdx_temp := minCalculation_countIdx;
    minVal1_temp := minCalculation_minVal1;
    minVal2_temp := minCalculation_minVal2;
    minIdx_temp := minCalculation_minIdx;
    signsAll_temp := minCalculation_signsAll;
    prodSign_temp := minCalculation_prodSign;
    IF (extReset /= '0') OR (minCalculation_countIdxReg1 = countU) THEN 
      countIdx_temp := to_unsigned(16#0#, 3);
    ELSIF validReg /= '0' THEN 
      countIdx_temp := minCalculation_countIdx + to_unsigned(16#1#, 3);
    END IF;
    add_temp := resize(countIdx_temp, 4) + to_unsigned(16#1#, 4);
    sub_cast := signed(resize(add_temp, 32));
    xorval := minCalculation_data(to_integer(sub_cast - 1));
    IF extReset /= '0' THEN 
      countIdx_temp := to_unsigned(16#0#, 3);
      minVal1_temp := (OTHERS => to_unsigned(16#7#, 4));
      minVal2_temp := (OTHERS => to_unsigned(16#7#, 4));
      minIdx_temp := (OTHERS => to_unsigned(16#0#, 3));
      signsAll_temp := (OTHERS => to_unsigned(16#7F#, 7));
      prodSign_temp := (OTHERS => '1');
    ELSE 
      IF validReg /= '0' THEN 
        FOR index IN 0 TO 13 LOOP
          signVal := dataReg(index)(3);
          cast(index) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & signVal;
          prodSign_temp(index) := hdlcoder_to_stdlogic(hdlcoder_to_signed(prodSign_temp(index) /= '0', 32) /= cast(index));
          IF signVal = '1' THEN 
            signsAll_temp(index) := signsAll_temp(index) XOR xorval;
          END IF;
        END LOOP;
      END IF;
      IF minCalculation_validReg = '1' THEN 
        FOR index_0 IN 0 TO 13 LOOP
          IF minCalculation_dataAbs(index_0) < minVal1_temp(index_0) THEN 
            minVal2_temp(index_0) := minVal1_temp(index_0);
            minVal1_temp(index_0) := minCalculation_dataAbs(index_0);
            minIdx_temp(index_0) := minCalculation_countIdx;
          ELSIF minCalculation_dataAbs(index_0) < minVal2_temp(index_0) THEN 
            minVal2_temp(index_0) := minCalculation_dataAbs(index_0);
          END IF;
        END LOOP;
      END IF;
    END IF;
    minCalculation_dataAbs_next <= dataAbs;
    minCalculation_validReg_next <= validReg;
    IF validReg /= '0' THEN 
      minCalculation_validOut_next <= hdlcoder_to_stdlogic(countIdx_temp = countU);
    ELSE 
      minCalculation_validOut_next <= '0';
    END IF;
    validD_1 <= minCalculation_validOut;
    minCalculation_countIdx_next <= countIdx_temp;
    minVal1 <= minVal1_temp;
    minVal2 <= minVal2_temp;
    minindex <= minIdx_temp;
    signs1 <= minCalculation_signsAll;
    prodsign <= minCalculation_prodSign;
    minCalculation_minVal1_next <= minVal1_temp;
    minCalculation_minVal2_next <= minVal2_temp;
    minCalculation_minIdx_next <= minIdx_temp;
    minCalculation_signsAll_next <= signsAll_temp;
    minCalculation_prodSign_next <= prodSign_temp;
    minCalculation_countIdxReg1_next <= minCalculation_countIdx;
  END PROCESS minCalculation_output;


  outputgen2: FOR k1 IN 0 TO 13 GENERATE
    cnuDecomp1(k1) <= std_logic_vector(signs1(k1));
  END GENERATE;

  prodsign_0 <= prodsign(0);

  prodsign_1 <= prodsign(1);

  prodsign_2 <= prodsign(2);

  prodsign_3 <= prodsign(3);

  prodsign_4 <= prodsign(4);

  prodsign_5 <= prodsign(5);

  prodsign_6 <= prodsign(6);

  prodsign_7 <= prodsign(7);

  prodsign_8 <= prodsign(8);

  prodsign_9 <= prodsign(9);

  prodsign_10 <= prodsign(10);

  prodsign_11 <= prodsign(11);

  prodsign_12 <= prodsign(12);

  prodsign_13 <= prodsign(13);

  minindex_0 <= minindex(0);

  betacomp2_arr_1 <= prodsign_0 & minindex_0;

  minindex_1 <= minindex(1);

  betacomp2_arr_2 <= prodsign_1 & minindex_1;

  minindex_2 <= minindex(2);

  betacomp2_arr_3 <= prodsign_2 & minindex_2;

  minindex_3 <= minindex(3);

  betacomp2_arr_4 <= prodsign_3 & minindex_3;

  minindex_4 <= minindex(4);

  betacomp2_arr_5 <= prodsign_4 & minindex_4;

  minindex_5 <= minindex(5);

  betacomp2_arr_6 <= prodsign_5 & minindex_5;

  minindex_6 <= minindex(6);

  betacomp2_arr_7 <= prodsign_6 & minindex_6;

  minindex_7 <= minindex(7);

  betacomp2_arr_8 <= prodsign_7 & minindex_7;

  minindex_8 <= minindex(8);

  betacomp2_arr_9 <= prodsign_8 & minindex_8;

  minindex_9 <= minindex(9);

  betacomp2_arr_10 <= prodsign_9 & minindex_9;

  minindex_10 <= minindex(10);

  betacomp2_arr_11 <= prodsign_10 & minindex_10;

  minindex_11 <= minindex(11);

  betacomp2_arr_12 <= prodsign_11 & minindex_11;

  minindex_12 <= minindex(12);

  betacomp2_arr_13 <= prodsign_12 & minindex_12;

  minindex_13 <= minindex(13);

  betacomp2_arr_14 <= prodsign_13 & minindex_13;

  betacomp2D(0) <= betacomp2_arr_1;
  betacomp2D(1) <= betacomp2_arr_2;
  betacomp2D(2) <= betacomp2_arr_3;
  betacomp2D(3) <= betacomp2_arr_4;
  betacomp2D(4) <= betacomp2_arr_5;
  betacomp2D(5) <= betacomp2_arr_6;
  betacomp2D(6) <= betacomp2_arr_7;
  betacomp2D(7) <= betacomp2_arr_8;
  betacomp2D(8) <= betacomp2_arr_9;
  betacomp2D(9) <= betacomp2_arr_10;
  betacomp2D(10) <= betacomp2_arr_11;
  betacomp2D(11) <= betacomp2_arr_12;
  betacomp2D(12) <= betacomp2_arr_13;
  betacomp2D(13) <= betacomp2_arr_14;

  outputgen1: FOR k1 IN 0 TO 13 GENERATE
    cnuDecomp2(k1) <= std_logic_vector(betacomp2D(k1));
  END GENERATE;


  min1_DTC_gen: FOR ii IN 0 TO 13 GENERATE
    
    min1_DTC(ii) <= "111" WHEN minVal1(ii)(3) /= '0' ELSE
        minVal1(ii)(2 DOWNTO 0);
  END GENERATE min1_DTC_gen;


  min1_DTC_0 <= min1_DTC(0);


  min2_DTC_gen: FOR ii1 IN 0 TO 13 GENERATE
    
    min2_DTC(ii1) <= "111" WHEN minVal2(ii1)(3) /= '0' ELSE
        minVal2(ii1)(2 DOWNTO 0);
  END GENERATE min2_DTC_gen;


  min1_DTC_1 <= min1_DTC(1);

  min1_DTC_2 <= min1_DTC(2);

  min1_DTC_3 <= min1_DTC(3);

  min1_DTC_4 <= min1_DTC(4);

  min1_DTC_5 <= min1_DTC(5);

  min1_DTC_6 <= min1_DTC(6);

  min1_DTC_7 <= min1_DTC(7);

  min1_DTC_8 <= min1_DTC(8);

  min1_DTC_9 <= min1_DTC(9);

  min1_DTC_10 <= min1_DTC(10);

  min1_DTC_11 <= min1_DTC(11);

  min1_DTC_12 <= min1_DTC(12);

  min1_DTC_13 <= min1_DTC(13);

  min2_DTC_0 <= min2_DTC(0);

  betacomp3_arr_1 <= min1_DTC_0 & min2_DTC_0;

  min2_DTC_1 <= min2_DTC(1);

  betacomp3_arr_2 <= min1_DTC_1 & min2_DTC_1;

  min2_DTC_2 <= min2_DTC(2);

  betacomp3_arr_3 <= min1_DTC_2 & min2_DTC_2;

  min2_DTC_3 <= min2_DTC(3);

  betacomp3_arr_4 <= min1_DTC_3 & min2_DTC_3;

  min2_DTC_4 <= min2_DTC(4);

  betacomp3_arr_5 <= min1_DTC_4 & min2_DTC_4;

  min2_DTC_5 <= min2_DTC(5);

  betacomp3_arr_6 <= min1_DTC_5 & min2_DTC_5;

  min2_DTC_6 <= min2_DTC(6);

  betacomp3_arr_7 <= min1_DTC_6 & min2_DTC_6;

  min2_DTC_7 <= min2_DTC(7);

  betacomp3_arr_8 <= min1_DTC_7 & min2_DTC_7;

  min2_DTC_8 <= min2_DTC(8);

  betacomp3_arr_9 <= min1_DTC_8 & min2_DTC_8;

  min2_DTC_9 <= min2_DTC(9);

  betacomp3_arr_10 <= min1_DTC_9 & min2_DTC_9;

  min2_DTC_10 <= min2_DTC(10);

  betacomp3_arr_11 <= min1_DTC_10 & min2_DTC_10;

  min2_DTC_11 <= min2_DTC(11);

  betacomp3_arr_12 <= min1_DTC_11 & min2_DTC_11;

  min2_DTC_12 <= min2_DTC(12);

  betacomp3_arr_13 <= min1_DTC_12 & min2_DTC_12;

  min2_DTC_13 <= min2_DTC(13);

  betacomp3_arr_14 <= min1_DTC_13 & min2_DTC_13;

  betacomp3D(0) <= betacomp3_arr_1;
  betacomp3D(1) <= betacomp3_arr_2;
  betacomp3D(2) <= betacomp3_arr_3;
  betacomp3D(3) <= betacomp3_arr_4;
  betacomp3D(4) <= betacomp3_arr_5;
  betacomp3D(5) <= betacomp3_arr_6;
  betacomp3D(6) <= betacomp3_arr_7;
  betacomp3D(7) <= betacomp3_arr_8;
  betacomp3D(8) <= betacomp3_arr_9;
  betacomp3D(9) <= betacomp3_arr_10;
  betacomp3D(10) <= betacomp3_arr_11;
  betacomp3D(11) <= betacomp3_arr_12;
  betacomp3D(12) <= betacomp3_arr_13;
  betacomp3D(13) <= betacomp3_arr_14;

  outputgen: FOR k1 IN 0 TO 13 GENERATE
    cnuDecomp3(k1) <= std_logic_vector(betacomp3D(k1));
  END GENERATE;

  c_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        cnuvalid <= '0';
      ELSIF enb = '1' THEN
        cnuvalid <= validD_1;
      END IF;
    END IF;
  END PROCESS c_4_process;


END rtl;

