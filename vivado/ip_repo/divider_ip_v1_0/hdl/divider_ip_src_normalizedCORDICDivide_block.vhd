-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/test/divider_ip_src_normalizedCORDICDivide_block.vhd
-- Created: 2024-10-03 19:36:11
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: divider_ip_src_normalizedCORDICDivide_block
-- Source Path: test/divider/in_8_out_16/ForEach - Real Divide/Divide real numerator by denominator/normalizedCORDICDivide
-- Hierarchy Level: 4
-- Model version: 1.59
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.divider_ip_src_divider_pac.ALL;

ENTITY divider_ip_src_normalizedCORDICDivide_block IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        num                               :   IN    std_logic_vector(7 DOWNTO 0);  -- sfix8_En6
        den                               :   IN    std_logic_vector(7 DOWNTO 0);  -- sfix8_En6
        tNum                              :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33
        tDen                              :   IN    std_logic_vector(31 DOWNTO 0);  -- int32
        isNumNegative                     :   IN    std_logic;
        isDenNegative                     :   IN    std_logic;
        validIn                           :   IN    std_logic;
        y                                 :   OUT   std_logic_vector(7 DOWNTO 0);  -- sfix8_En6
        t                                 :   OUT   std_logic_vector(33 DOWNTO 0);  -- sfix34
        isDenZeroOut                      :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END divider_ip_src_normalizedCORDICDivide_block;


ARCHITECTURE rtl OF divider_ip_src_normalizedCORDICDivide_block IS

  -- Signals
  SIGNAL num_signed                       : signed(7 DOWNTO 0);  -- sfix8_En6
  SIGNAL den_signed                       : signed(7 DOWNTO 0);  -- sfix8_En6
  SIGNAL tNum_signed                      : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL tDen_signed                      : signed(31 DOWNTO 0);  -- int32
  SIGNAL y_tmp                            : signed(7 DOWNTO 0);  -- sfix8_En6
  SIGNAL t_tmp                            : signed(33 DOWNTO 0);  -- sfix34
  SIGNAL xReg                             : vector_of_signed8(0 TO 8);  -- sfix8 [9]
  SIGNAL yReg                             : vector_of_signed8(0 TO 8);  -- sfix8 [9]
  SIGNAL zReg                             : vector_of_signed8(0 TO 8);  -- sfix8 [9]
  SIGNAL validReg                         : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL tReg                             : vector_of_signed34(0 TO 8);  -- sfix34 [9]
  SIGNAL isNegativeReg                    : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL isNumZeroReg                     : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL isDenZeroReg                     : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL xReg_next                        : vector_of_signed8(0 TO 8);  -- sfix8_En6 [9]
  SIGNAL yReg_next                        : vector_of_signed8(0 TO 8);  -- sfix8_En6 [9]
  SIGNAL zReg_next                        : vector_of_signed8(0 TO 8);  -- sfix8_En6 [9]
  SIGNAL validReg_next                    : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL tReg_next                        : vector_of_signed34(0 TO 8);  -- sfix34 [9]
  SIGNAL isNegativeReg_next               : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL isNumZeroReg_next                : std_logic_vector(8 DOWNTO 0);  -- boolean [9]
  SIGNAL isDenZeroReg_next                : std_logic_vector(8 DOWNTO 0);  -- boolean [9]

BEGIN
  num_signed <= signed(num);

  den_signed <= signed(den);

  tNum_signed <= signed(tNum);

  tDen_signed <= signed(tDen);

  embreciprocals_c21_srsSxB03KYvCy8sHTtyrCcG_normalizedCORDICDivi_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        xReg <= (OTHERS => to_signed(16#00#, 8));
        yReg <= (OTHERS => to_signed(16#00#, 8));
        zReg <= (OTHERS => to_signed(16#00#, 8));
        validReg <= (OTHERS => '0');
        tReg <= (OTHERS => to_signed(0, 34));
        isNegativeReg <= (OTHERS => '0');
        isDenZeroReg <= (OTHERS => '0');
        isNumZeroReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        xReg <= xReg_next;
        yReg <= yReg_next;
        zReg <= zReg_next;
        validReg <= validReg_next;
        tReg <= tReg_next;
        isNegativeReg <= isNegativeReg_next;
        isNumZeroReg <= isNumZeroReg_next;
        isDenZeroReg <= isDenZeroReg_next;
      END IF;
    END IF;
  END PROCESS embreciprocals_c21_srsSxB03KYvCy8sHTtyrCcG_normalizedCORDICDivi_process;

  embreciprocals_c21_srsSxB03KYvCy8sHTtyrCcG_normalizedCORDICDivi_output : PROCESS (den_signed, isDenNegative, isDenZeroReg, isNegativeReg, isNumNegative,
       isNumZeroReg, num_signed, tDen_signed, tNum_signed, tReg, validIn,
       validReg, xReg, yReg, zReg)
    VARIABLE isDenZero : std_logic;
    VARIABLE isNumZero : std_logic;
    VARIABLE sub_temp : signed(7 DOWNTO 0);
    VARIABLE t_0 : signed(7 DOWNTO 0);
    VARIABLE a : signed(7 DOWNTO 0);
    VARIABLE c : signed(7 DOWNTO 0);
    VARIABLE a_0 : signed(7 DOWNTO 0);
    VARIABLE c_0 : signed(7 DOWNTO 0);
    VARIABLE a_1 : signed(7 DOWNTO 0);
    VARIABLE c_1 : signed(7 DOWNTO 0);
    VARIABLE a_2 : signed(7 DOWNTO 0);
    VARIABLE c_2 : signed(7 DOWNTO 0);
    VARIABLE a_3 : signed(7 DOWNTO 0);
    VARIABLE c_3 : signed(7 DOWNTO 0);
    VARIABLE a_4 : signed(7 DOWNTO 0);
    VARIABLE c_4 : signed(7 DOWNTO 0);
    VARIABLE a_5 : signed(7 DOWNTO 0);
    VARIABLE c_5 : signed(7 DOWNTO 0);
    VARIABLE a_6 : signed(7 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(7 DOWNTO 0);
    VARIABLE add_temp : signed(7 DOWNTO 0);
    VARIABLE sub_temp_1 : signed(7 DOWNTO 0);
    VARIABLE add_temp_0 : signed(7 DOWNTO 0);
    VARIABLE sub_temp_2 : signed(7 DOWNTO 0);
    VARIABLE add_temp_1 : signed(7 DOWNTO 0);
    VARIABLE sub_temp_3 : signed(7 DOWNTO 0);
    VARIABLE add_temp_2 : signed(7 DOWNTO 0);
    VARIABLE sub_temp_4 : signed(7 DOWNTO 0);
    VARIABLE add_temp_3 : signed(7 DOWNTO 0);
    VARIABLE sub_temp_5 : signed(7 DOWNTO 0);
    VARIABLE add_temp_4 : signed(7 DOWNTO 0);
    VARIABLE sub_temp_6 : signed(7 DOWNTO 0);
    VARIABLE add_temp_5 : signed(7 DOWNTO 0);
    VARIABLE cast : signed(8 DOWNTO 0);
    VARIABLE cast_0 : signed(8 DOWNTO 0);
  BEGIN
    cast_0 := to_signed(16#000#, 9);
    cast := to_signed(16#000#, 9);
    --   Copyright 2020 The MathWorks, Inc.
    IF den_signed = to_signed(16#00#, 8) THEN 
      isDenZero := '1';
    ELSE 
      isDenZero := '0';
    END IF;
    IF num_signed = to_signed(16#00#, 8) THEN 
      isNumZero := '1';
    ELSE 
      isNumZero := '0';
    END IF;
    -- CORDIC divide for fixed-point and scaled-double types
    -- Register variables for the CORDIC Divide Kernel
    -- CORDIC Divide Kernel
    validReg_next(8) <= validReg(7);
    tReg_next(8) <= tReg(7);
    validReg_next(7) <= validReg(6);
    tReg_next(7) <= tReg(6);
    validReg_next(6) <= validReg(5);
    tReg_next(6) <= tReg(5);
    validReg_next(5) <= validReg(4);
    tReg_next(5) <= tReg(4);
    validReg_next(4) <= validReg(3);
    tReg_next(4) <= tReg(3);
    validReg_next(3) <= validReg(2);
    tReg_next(3) <= tReg(2);
    validReg_next(2) <= validReg(1);
    tReg_next(2) <= tReg(1);
    validReg_next(1) <= validReg(0);
    tReg_next(1) <= tReg(0);
    validReg_next(0) <= validIn;
    tReg_next(0) <= resize(tDen_signed, 34) - resize(tNum_signed, 34);
    a := xReg(7);
    c := SHIFT_RIGHT(a, 7);
    IF yReg(7) < to_signed(16#00#, 8) THEN 
      sub_temp := yReg(7) + c;
      t_0 := zReg(7);
    ELSE 
      sub_temp := yReg(7) - c;
      t_0 := zReg(7);
    END IF;
    yReg_next(8) <= sub_temp;
    zReg_next(8) <= t_0;
    xReg_next(8) <= xReg(7);
    a_0 := xReg(6);
    c_0 := SHIFT_RIGHT(a_0, 6);
    IF yReg(6) < to_signed(16#00#, 8) THEN 
      sub_temp_0 := yReg(6) + c_0;
      add_temp := zReg(6) - to_signed(16#01#, 8);
    ELSE 
      sub_temp_0 := yReg(6) - c_0;
      add_temp := zReg(6) + to_signed(16#01#, 8);
    END IF;
    yReg_next(7) <= sub_temp_0;
    zReg_next(7) <= add_temp;
    xReg_next(7) <= xReg(6);
    a_1 := xReg(5);
    c_1 := SHIFT_RIGHT(a_1, 5);
    IF yReg(5) < to_signed(16#00#, 8) THEN 
      sub_temp_1 := yReg(5) + c_1;
      add_temp_0 := zReg(5) - to_signed(16#02#, 8);
    ELSE 
      sub_temp_1 := yReg(5) - c_1;
      add_temp_0 := zReg(5) + to_signed(16#02#, 8);
    END IF;
    yReg_next(6) <= sub_temp_1;
    zReg_next(6) <= add_temp_0;
    xReg_next(6) <= xReg(5);
    a_2 := xReg(4);
    c_2 := SHIFT_RIGHT(a_2, 4);
    IF yReg(4) < to_signed(16#00#, 8) THEN 
      sub_temp_2 := yReg(4) + c_2;
      add_temp_1 := zReg(4) - to_signed(16#04#, 8);
    ELSE 
      sub_temp_2 := yReg(4) - c_2;
      add_temp_1 := zReg(4) + to_signed(16#04#, 8);
    END IF;
    yReg_next(5) <= sub_temp_2;
    zReg_next(5) <= add_temp_1;
    xReg_next(5) <= xReg(4);
    a_3 := xReg(3);
    c_3 := SHIFT_RIGHT(a_3, 3);
    IF yReg(3) < to_signed(16#00#, 8) THEN 
      sub_temp_3 := yReg(3) + c_3;
      add_temp_2 := zReg(3) - to_signed(16#08#, 8);
    ELSE 
      sub_temp_3 := yReg(3) - c_3;
      add_temp_2 := zReg(3) + to_signed(16#08#, 8);
    END IF;
    yReg_next(4) <= sub_temp_3;
    zReg_next(4) <= add_temp_2;
    xReg_next(4) <= xReg(3);
    a_4 := xReg(2);
    c_4 := SHIFT_RIGHT(a_4, 2);
    IF yReg(2) < to_signed(16#00#, 8) THEN 
      sub_temp_4 := yReg(2) + c_4;
      add_temp_3 := zReg(2) - to_signed(16#10#, 8);
    ELSE 
      sub_temp_4 := yReg(2) - c_4;
      add_temp_3 := zReg(2) + to_signed(16#10#, 8);
    END IF;
    yReg_next(3) <= sub_temp_4;
    zReg_next(3) <= add_temp_3;
    xReg_next(3) <= xReg(2);
    a_5 := xReg(1);
    c_5 := SHIFT_RIGHT(a_5, 1);
    IF yReg(1) < to_signed(16#00#, 8) THEN 
      sub_temp_5 := yReg(1) + c_5;
      add_temp_4 := zReg(1) - to_signed(16#20#, 8);
    ELSE 
      sub_temp_5 := yReg(1) - c_5;
      add_temp_4 := zReg(1) + to_signed(16#20#, 8);
    END IF;
    yReg_next(2) <= sub_temp_5;
    zReg_next(2) <= add_temp_4;
    xReg_next(2) <= xReg(1);
    a_6 := xReg(0);
    IF yReg(0) < to_signed(16#00#, 8) THEN 
      sub_temp_6 := yReg(0) + a_6;
      add_temp_5 := zReg(0) - to_signed(16#40#, 8);
    ELSE 
      sub_temp_6 := yReg(0) - a_6;
      add_temp_5 := zReg(0) + to_signed(16#40#, 8);
    END IF;
    yReg_next(1) <= sub_temp_6;
    zReg_next(1) <= add_temp_5;
    xReg_next(1) <= xReg(0);
    xReg_next(0) <= den_signed;
    yReg_next(0) <= num_signed;
    zReg_next(0) <= to_signed(16#00#, 8);
    -- % Persistent variables
    -- Assign outputs from states
    -- Update isNegative states
    isNegativeReg_next(8) <= isNegativeReg(7);
    isNumZeroReg_next(8) <= isNumZeroReg(7);
    isDenZeroReg_next(8) <= isDenZeroReg(7);
    isNegativeReg_next(7) <= isNegativeReg(6);
    isNumZeroReg_next(7) <= isNumZeroReg(6);
    isDenZeroReg_next(7) <= isDenZeroReg(6);
    isNegativeReg_next(6) <= isNegativeReg(5);
    isNumZeroReg_next(6) <= isNumZeroReg(5);
    isDenZeroReg_next(6) <= isDenZeroReg(5);
    isNegativeReg_next(5) <= isNegativeReg(4);
    isNumZeroReg_next(5) <= isNumZeroReg(4);
    isDenZeroReg_next(5) <= isDenZeroReg(4);
    isNegativeReg_next(4) <= isNegativeReg(3);
    isNumZeroReg_next(4) <= isNumZeroReg(3);
    isDenZeroReg_next(4) <= isDenZeroReg(3);
    isNegativeReg_next(3) <= isNegativeReg(2);
    isNumZeroReg_next(3) <= isNumZeroReg(2);
    isDenZeroReg_next(3) <= isDenZeroReg(2);
    isNegativeReg_next(2) <= isNegativeReg(1);
    isNumZeroReg_next(2) <= isNumZeroReg(1);
    isDenZeroReg_next(2) <= isDenZeroReg(1);
    isNegativeReg_next(1) <= isNegativeReg(0);
    isNumZeroReg_next(1) <= isNumZeroReg(0);
    isDenZeroReg_next(1) <= isDenZeroReg(0);
    IF isNumNegative /= isDenNegative THEN 
      isNegativeReg_next(0) <= '1';
    ELSE 
      isNegativeReg_next(0) <= '0';
    END IF;
    isNumZeroReg_next(0) <= isNumZero;
    isDenZeroReg_next(0) <= isDenZero;
    y_tmp <= zReg(8);
    IF isNumZeroReg(8) = '1' THEN 
      -- Negate with saturate so the most negative value doesn't overflow.
      y_tmp <= to_signed(16#00#, 8);
    ELSIF isNegativeReg(8) = '1' THEN 
      -- Negate with saturate so the most negative value doesn't overflow.
      cast := resize(zReg(8), 9);
      cast_0 :=  - (cast);
      IF (cast_0(8) = '0') AND (cast_0(7) /= '0') THEN 
        y_tmp <= "01111111";
      ELSIF (cast_0(8) = '1') AND (cast_0(7) /= '1') THEN 
        y_tmp <= "10000000";
      ELSE 
        y_tmp <= cast_0(7 DOWNTO 0);
      END IF;
    END IF;
    t_tmp <= tReg(8);
    isDenZeroOut <= isDenZeroReg(8);
    validOut <= validReg(8);
  END PROCESS embreciprocals_c21_srsSxB03KYvCy8sHTtyrCcG_normalizedCORDICDivi_output;


  y <= std_logic_vector(y_tmp);

  t <= std_logic_vector(t_tmp);

END rtl;

