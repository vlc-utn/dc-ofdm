-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/test/divider_ip_src_Quadrant_compensation.vhd
-- Created: 2024-10-03 19:36:10
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: divider_ip_src_Quadrant_compensation
-- Source Path: test/divider/Complex Divide HDL Optimized/ForEach - Complex Divide/Rotate to real/Quadrant compensation
-- Hierarchy Level: 4
-- Model version: 1.59
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY divider_ip_src_Quadrant_compensation IS
  PORT( x                                 :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        y                                 :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        u                                 :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        v                                 :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        validIn                           :   IN    std_logic;
        xOut                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        yOut                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        uOut                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        vOut                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        validOut                          :   OUT   std_logic
        );
END divider_ip_src_Quadrant_compensation;


ARCHITECTURE rtl OF divider_ip_src_Quadrant_compensation IS

  -- Signals
  SIGNAL x_signed                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL y_signed                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL u_signed                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL v_signed                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL xOut_tmp                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL yOut_tmp                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL uOut_tmp                         : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL vOut_tmp                         : signed(15 DOWNTO 0);  -- sfix16_En10

BEGIN
  x_signed <= signed(x);

  y_signed <= signed(y);

  u_signed <= signed(u);

  v_signed <= signed(v);

  embreciprocals_c9_Quadrant_compensation_output : PROCESS (u_signed, v_signed, validIn, x_signed, y_signed)
    VARIABLE cast : signed(16 DOWNTO 0);
    VARIABLE cast_0 : signed(16 DOWNTO 0);
    VARIABLE cast_1 : signed(16 DOWNTO 0);
    VARIABLE cast_2 : signed(16 DOWNTO 0);
    VARIABLE cast_3 : signed(16 DOWNTO 0);
    VARIABLE cast_4 : signed(16 DOWNTO 0);
    VARIABLE cast_5 : signed(16 DOWNTO 0);
    VARIABLE cast_6 : signed(16 DOWNTO 0);
  BEGIN
    cast_0 := to_signed(16#00000#, 17);
    cast_2 := to_signed(16#00000#, 17);
    cast_4 := to_signed(16#00000#, 17);
    cast_6 := to_signed(16#00000#, 17);
    cast := to_signed(16#00000#, 17);
    cast_1 := to_signed(16#00000#, 17);
    cast_3 := to_signed(16#00000#, 17);
    cast_5 := to_signed(16#00000#, 17);
    IF x_signed < to_signed(16#0000#, 16) THEN 
      -- Compensation for 3rd and 4th quadrants
      cast := resize(x_signed, 17);
      cast_0 :=  - (cast);
      xOut_tmp <= cast_0(15 DOWNTO 0);
      cast_1 := resize(y_signed, 17);
      cast_2 :=  - (cast_1);
      yOut_tmp <= cast_2(15 DOWNTO 0);
      cast_3 := resize(u_signed, 17);
      cast_4 :=  - (cast_3);
      uOut_tmp <= cast_4(15 DOWNTO 0);
      cast_5 := resize(v_signed, 17);
      cast_6 :=  - (cast_5);
      vOut_tmp <= cast_6(15 DOWNTO 0);
    ELSE 
      xOut_tmp <= x_signed;
      yOut_tmp <= y_signed;
      uOut_tmp <= u_signed;
      vOut_tmp <= v_signed;
    END IF;
    validOut <= validIn;
  END PROCESS embreciprocals_c9_Quadrant_compensation_output;


  xOut <= std_logic_vector(xOut_tmp);

  yOut <= std_logic_vector(yOut_tmp);

  uOut <= std_logic_vector(uOut_tmp);

  vOut <= std_logic_vector(vOut_tmp);

END rtl;

