-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/test/divider_ip_src_positiveRealNormalizer_block.vhd
-- Created: 2024-10-03 19:36:11
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: divider_ip_src_positiveRealNormalizer_block
-- Source Path: test/divider/in_8_out_16/ForEach - Real Divide/Normalize numerator/positiveRealNormalizer
-- Hierarchy Level: 4
-- Model version: 1.59
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.divider_ip_src_divider_pac.ALL;

ENTITY divider_ip_src_positiveRealNormalizer_block IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        u                                 :   IN    std_logic_vector(7 DOWNTO 0);  -- sfix8_En6
        validIn                           :   IN    std_logic;
        x                                 :   OUT   std_logic_vector(7 DOWNTO 0);  -- sfix8_En6
        e                                 :   OUT   std_logic_vector(31 DOWNTO 0);  -- int32
        isNegative                        :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END divider_ip_src_positiveRealNormalizer_block;


ARCHITECTURE rtl OF divider_ip_src_positiveRealNormalizer_block IS

  -- Signals
  SIGNAL u_signed                         : signed(7 DOWNTO 0);  -- sfix8_En6
  SIGNAL x_tmp                            : signed(7 DOWNTO 0);  -- sfix8_En6
  SIGNAL e_tmp                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL validReg                         : std_logic_vector(3 DOWNTO 0);  -- boolean [4]
  SIGNAL tReg                             : vector_of_unsigned3(0 TO 3);  -- ufix3 [4]
  SIGNAL xReg                             : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL isNegativeReg                    : std_logic_vector(3 DOWNTO 0);  -- boolean [4]
  SIGNAL validReg_next                    : std_logic_vector(3 DOWNTO 0);  -- boolean [4]
  SIGNAL tReg_next                        : vector_of_unsigned3(0 TO 3);  -- ufix3 [4]
  SIGNAL xReg_next                        : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL isNegativeReg_next               : std_logic_vector(3 DOWNTO 0);  -- boolean [4]

BEGIN
  u_signed <= signed(u);

  embreciprocals_c3_sPlVndwBEMvNEF1WOv35za_positiveRealNormalizer_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validReg <= (OTHERS => '0');
        tReg <= (OTHERS => to_unsigned(16#0#, 3));
        xReg <= (OTHERS => to_unsigned(16#00#, 8));
        isNegativeReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        validReg <= validReg_next;
        tReg <= tReg_next;
        xReg <= xReg_next;
        isNegativeReg <= isNegativeReg_next;
      END IF;
    END IF;
  END PROCESS embreciprocals_c3_sPlVndwBEMvNEF1WOv35za_positiveRealNormalizer_process;

  embreciprocals_c3_sPlVndwBEMvNEF1WOv35za_positiveRealNormalizer_output : PROCESS (isNegativeReg, tReg, u_signed, validIn, validReg, xReg)
    VARIABLE u1 : signed(7 DOWNTO 0);
    VARIABLE isNegative1 : std_logic;
    VARIABLE a : unsigned(7 DOWNTO 0);
    VARIABLE c : unsigned(7 DOWNTO 0);
    VARIABLE xfi_stripped : unsigned(7 DOWNTO 0);
    VARIABLE yfi_trivial_scaling : signed(7 DOWNTO 0);
    VARIABLE a_0 : unsigned(7 DOWNTO 0);
    VARIABLE c_0 : unsigned(7 DOWNTO 0);
    VARIABLE a_1 : unsigned(7 DOWNTO 0);
    VARIABLE c_1 : unsigned(7 DOWNTO 0);
    VARIABLE a_2 : unsigned(7 DOWNTO 0);
    VARIABLE c_2 : unsigned(7 DOWNTO 0);
    VARIABLE cast : signed(8 DOWNTO 0);
    VARIABLE cast_0 : signed(8 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
  BEGIN
    c_2 := to_unsigned(16#00#, 8);
    c_1 := to_unsigned(16#00#, 8);
    c_0 := to_unsigned(16#00#, 8);
    a_2 := to_unsigned(16#00#, 8);
    a_1 := to_unsigned(16#00#, 8);
    a_0 := to_unsigned(16#00#, 8);
    cast_0 := to_signed(16#000#, 9);
    cast := to_signed(16#000#, 9);
    --realNormalizer Normalize real values.
    -- Given real scalar u ~= 0, this block produces x such that
    --    1 <= x < 2,
    -- e such that
    --    x = (2^e)*|u|,
    -- and isNegative = u<0.
    --
    --   When u = 0 and u is fixed-point or scaled-double, then x = 0 and
    --   e = (2^nextpow2(x.WordLength)) - x.WordLength - x.FractionLength.
    --
    --   When u = 0 and u is floating-point, then x = 0 and e = 1.
    --   Copyright 2019 The MathWorks, Inc.
    -- This function only works on scalars.
    -- Only operate on the real part
    -- Normalize in unsigned type.
    u1 := u_signed;
    IF u_signed < to_signed(16#00#, 8) THEN 
      isNegative1 := '1';
    ELSE 
      isNegative1 := '0';
    END IF;
    IF isNegative1 = '1' THEN 
      cast := resize(u_signed, 9);
      cast_0 :=  - (cast);
      IF (cast_0(8) = '0') AND (cast_0(7) /= '0') THEN 
        u1 := "01111111";
      ELSIF (cast_0(8) = '1') AND (cast_0(7) /= '1') THEN 
        u1 := "10000000";
      ELSE 
        u1 := cast_0(7 DOWNTO 0);
      END IF;
    END IF;
    -- Normalize fixed-point values
    -- Normalize fixed-point values.
    -- For fixed-point types, the normalization uses a binary search of
    -- length log2 of the word length of the input.
    validReg_next(3) <= validReg(2);
    validReg_next(2) <= validReg(1);
    validReg_next(1) <= validReg(0);
    validReg_next(0) <= validIn;
    IF (xReg(2) AND to_unsigned(16#80#, 8)) = to_unsigned(16#00#, 8) THEN 
      tReg_next(3) <= tReg(2) OR to_unsigned(16#1#, 3);
      a_0 := xReg(2);
      c_0 := a_0 sll 1;
      xReg_next(3) <= c_0;
    ELSE 
      tReg_next(3) <= tReg(2);
      xReg_next(3) <= xReg(2);
    END IF;
    IF (xReg(1) AND to_unsigned(16#C0#, 8)) = to_unsigned(16#00#, 8) THEN 
      tReg_next(2) <= tReg(1) OR to_unsigned(16#2#, 3);
      a_1 := xReg(1);
      c_1 := a_1 sll 2;
      xReg_next(2) <= c_1;
    ELSE 
      tReg_next(2) <= tReg(1);
      xReg_next(2) <= xReg(1);
    END IF;
    IF (xReg(0) AND to_unsigned(16#F0#, 8)) = to_unsigned(16#00#, 8) THEN 
      tReg_next(1) <= tReg(0) OR to_unsigned(16#4#, 3);
      a_2 := xReg(0);
      c_2 := a_2 sll 4;
      xReg_next(1) <= c_2;
    ELSE 
      tReg_next(1) <= tReg(0);
      xReg_next(1) <= xReg(0);
    END IF;
    tReg_next(0) <= to_unsigned(16#0#, 3);
    xReg_next(0) <= unsigned(u1);
    --  % Persistent
    -- Assign outputs from states
    -- Update isNegative states
    isNegativeReg_next(3) <= isNegativeReg(2);
    isNegativeReg_next(2) <= isNegativeReg(1);
    isNegativeReg_next(1) <= isNegativeReg(0);
    isNegativeReg_next(0) <= isNegative1;
    -- Cast the output to signed if the input was signed.
    a := xReg(3);
    c := SHIFT_RIGHT(a, 1);
    xfi_stripped := c;
    yfi_trivial_scaling := signed(xfi_stripped);
    -- Convert the normalized shift value based on the data type of the
    -- input U so that the output of the normalizer X is in real-world
    -- scale and X = (2^N)*U.
    x_tmp <= yfi_trivial_scaling;
    sub_cast := signed(resize(tReg(3), 32));
    e_tmp <= sub_cast - 1;
    isNegative <= isNegativeReg(3);
    validOut <= validReg(3);
  END PROCESS embreciprocals_c3_sPlVndwBEMvNEF1WOv35za_positiveRealNormalizer_output;


  x <= std_logic_vector(x_tmp);

  e <= std_logic_vector(e_tmp);

END rtl;

