-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/IEEE_8021513_TX_src_Calculate_Parity_block.vhd
-- Created: 2024-11-13 11:48:22
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IEEE_8021513_TX_src_Calculate_Parity_block
-- Source Path: HDLTx/full_tx/payload_full/reduced_ldpc/Hc_12S-B80/Calculate Parity
-- Hierarchy Level: 4
-- Model version: 4.212
-- 
-- Calculate Parity
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IEEE_8021513_TX_src_full_tx_pac.ALL;

ENTITY IEEE_8021513_TX_src_Calculate_Parity_block IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        reset                             :   IN    std_logic;  -- ufix1
        alpha                             :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        alphaValid                        :   IN    std_logic;  -- ufix1
        alphaAddr                         :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
        parity1                           :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        parityOut                         :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        parityValid                       :   OUT   std_logic;  -- ufix1
        parityAddr                        :   OUT   std_logic_vector(3 DOWNTO 0)  -- ufix4
        );
END IEEE_8021513_TX_src_Calculate_Parity_block;


ARCHITECTURE rtl OF IEEE_8021513_TX_src_Calculate_Parity_block IS

  -- Functions
  -- HDLCODER_TO_SIGNED
  FUNCTION hdlcoder_to_signed(arg: boolean; width: integer) RETURN signed IS
  BEGIN
    IF arg THEN
      RETURN to_signed(1, width);
    ELSE
      RETURN to_signed(0, width);
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL alphaReg                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL alphaValidReg                    : std_logic;  -- ufix1
  SIGNAL alphaAddr_unsigned               : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaAddrReg                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL parity1_1                        : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL parity1Reg                       : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL sParity                          : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL sParityReg                       : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL parityControllerDual_pOut        : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL parityControllerDual_pValid      : std_logic;
  SIGNAL parityControllerDual_pAddr       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL parityControllerDual_alphaReg    : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL parityControllerDual_pOut_next   : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL parityControllerDual_pValid_next : std_logic;
  SIGNAL parityControllerDual_pAddr_next  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL parityControllerDual_alphaReg_next : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL pOut                             : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL pValid                           : std_logic;  -- ufix1
  SIGNAL pAddr                            : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL parityAddr_tmp                   : unsigned(3 DOWNTO 0);  -- ufix4

BEGIN
  data_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alphaReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        alphaReg <= alpha;
      END IF;
    END IF;
  END PROCESS data_register_process;


  valid_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alphaValidReg <= '0';
      ELSIF enb = '1' THEN
        alphaValidReg <= alphaValid;
      END IF;
    END IF;
  END PROCESS valid_register_process;


  alphaAddr_unsigned <= unsigned(alphaAddr);

  addr_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alphaAddrReg <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        alphaAddrReg <= alphaAddr_unsigned;
      END IF;
    END IF;
  END PROCESS addr_register_process;


  parity1_1(0) <= parity1(0);
  parity1_1(1) <= parity1(1);
  parity1_1(2) <= parity1(2);
  parity1_1(3) <= parity1(3);
  parity1_1(4) <= parity1(4);
  parity1_1(5) <= parity1(5);
  parity1_1(6) <= parity1(6);
  parity1_1(7) <= parity1(7);
  parity1_1(8) <= parity1(8);
  parity1_1(9) <= parity1(9);
  parity1_1(10) <= parity1(10);
  parity1_1(11) <= parity1(11);
  parity1_1(12) <= parity1(12);
  parity1_1(13) <= parity1(13);

  parity_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parity1Reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        parity1Reg <= parity1_1;
      END IF;
    END IF;
  END PROCESS parity_process;


  sParity(0) <= parity1(4);
  sParity(1) <= parity1(5);
  sParity(2) <= parity1(6);
  sParity(3) <= parity1(7);
  sParity(4) <= parity1(8);
  sParity(5) <= parity1(9);
  sParity(6) <= parity1(10);
  sParity(7) <= parity1(11);
  sParity(8) <= parity1(12);
  sParity(9) <= parity1(13);
  sParity(10) <= parity1(0);
  sParity(11) <= parity1(1);
  sParity(12) <= parity1(2);
  sParity(13) <= parity1(3);

  parity_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        sParityReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        sParityReg <= sParity;
      END IF;
    END IF;
  END PROCESS parity_1_process;


  parityControllerDual_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parityControllerDual_pValid <= '0';
        parityControllerDual_pAddr <= to_unsigned(16#1#, 4);
        parityControllerDual_pOut <= (OTHERS => '0');
        parityControllerDual_alphaReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        parityControllerDual_pValid <= parityControllerDual_pValid_next;
        parityControllerDual_pAddr <= parityControllerDual_pAddr_next;
        parityControllerDual_pOut <= parityControllerDual_pOut_next;
        parityControllerDual_alphaReg <= parityControllerDual_alphaReg_next;
      END IF;
    END IF;
  END PROCESS parityControllerDual_process;

  parityControllerDual_output : PROCESS (alphaAddrReg, alphaReg, alphaValidReg, parity1Reg,
       parityControllerDual_alphaReg, parityControllerDual_pAddr,
       parityControllerDual_pOut, parityControllerDual_pValid, reset,
       sParityReg)
    VARIABLE cast : vector_of_signed32(0 TO 13);
    VARIABLE cast_0 : vector_of_signed32(0 TO 13);
  BEGIN
    parityControllerDual_pOut_next <= parityControllerDual_pOut;
    IF reset /= '0' THEN 
      parityControllerDual_pOut_next <= (OTHERS => '0');
      parityControllerDual_pValid_next <= '0';
      parityControllerDual_pAddr_next <= to_unsigned(16#1#, 4);
    ELSIF alphaValidReg /= '0' THEN 
      parityControllerDual_pValid_next <= '1';
      parityControllerDual_pAddr_next <= alphaAddrReg;
      IF alphaAddrReg = to_unsigned(16#1#, 4) THEN 
        FOR t_0 IN 0 TO 13 LOOP
          parityControllerDual_pOut_next(t_0) <= parity1Reg(t_0);
        END LOOP;
      ELSIF alphaAddrReg <= to_unsigned(16#B#, 4) THEN 
        IF alphaAddrReg = to_unsigned(16#2#, 4) THEN 
          FOR t_5 IN 0 TO 13 LOOP
            cast_0(t_5) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & parityControllerDual_alphaReg(t_5);
            IF hdlcoder_to_signed(sParityReg(t_5) /= '0', 32) /= cast_0(t_5) THEN 
              parityControllerDual_pOut_next(t_5) <= '1';
            ELSE 
              parityControllerDual_pOut_next(t_5) <= '0';
            END IF;
          END LOOP;
        ELSE 
          FOR t_4 IN 0 TO 13 LOOP
            parityControllerDual_pOut_next(t_4) <= parityControllerDual_pOut(t_4) XOR parityControllerDual_alphaReg(t_4);
          END LOOP;
        END IF;
      ELSIF alphaAddrReg = to_unsigned(16#C#, 4) THEN 
        FOR t_3 IN 0 TO 13 LOOP
          IF (sParityReg(t_3) /= '0') /= (alphaReg(t_3) /= '0') THEN 
            parityControllerDual_pOut_next(t_3) <= '1';
          ELSE 
            parityControllerDual_pOut_next(t_3) <= '0';
          END IF;
        END LOOP;
      ELSE 
        FOR t_2 IN 0 TO 13 LOOP
          cast(t_2) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & parityControllerDual_pOut(t_2);
          IF cast(t_2) /= hdlcoder_to_signed(alphaReg(t_2) /= '0', 32) THEN 
            parityControllerDual_pOut_next(t_2) <= '1';
          ELSE 
            parityControllerDual_pOut_next(t_2) <= '0';
          END IF;
        END LOOP;
      END IF;
    ELSE 
      parityControllerDual_pOut_next <= (OTHERS => '0');
      parityControllerDual_pValid_next <= '0';
      parityControllerDual_pAddr_next <= to_unsigned(16#1#, 4);
    END IF;

    FOR t_1 IN 0 TO 13 LOOP
      parityControllerDual_alphaReg_next(t_1) <= alphaReg(t_1);
      pOut(t_1) <= parityControllerDual_pOut(t_1);
    END LOOP;

    pValid <= parityControllerDual_pValid;
    pAddr <= parityControllerDual_pAddr;
  END PROCESS parityControllerDual_output;


  parity_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parityOut <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        parityOut <= pOut;
      END IF;
    END IF;
  END PROCESS parity_2_process;


  parity_valid_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parityValid <= '0';
      ELSIF enb = '1' THEN
        parityValid <= pValid;
      END IF;
    END IF;
  END PROCESS parity_valid_process;


  parity_addr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parityAddr_tmp <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        parityAddr_tmp <= pAddr;
      END IF;
    END IF;
  END PROCESS parity_addr_process;


  parityAddr <= std_logic_vector(parityAddr_tmp);

END rtl;

