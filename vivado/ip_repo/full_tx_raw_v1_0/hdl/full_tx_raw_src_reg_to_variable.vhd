-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/full_tx_raw_src_reg_to_variable.vhd
-- Created: 2024-08-31 20:20:58
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_tx_raw_src_reg_to_variable
-- Source Path: HDLTx/full_tx/reg_to_variable
-- Hierarchy Level: 1
-- Model version: 4.99
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY full_tx_raw_src_reg_to_variable IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_8_0                         :   IN    std_logic;
        new_frame_in                      :   IN    std_logic;
        reg0                              :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        reg1                              :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        reg2                              :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        reg3                              :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        new_frame_out                     :   OUT   std_logic;
        psdu_size                         :   OUT   std_logic_vector(23 DOWNTO 0);  -- boolean [24]
        msg_duration                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- boolean [16]
        block_size                        :   OUT   std_logic_vector(1 DOWNTO 0);  -- boolean [2]
        fec_rate                          :   OUT   std_logic_vector(2 DOWNTO 0);  -- boolean [3]
        rep_number                        :   OUT   std_logic_vector(2 DOWNTO 0);  -- boolean [3]
        concat_factor                     :   OUT   std_logic_vector(2 DOWNTO 0);  -- boolean [3]
        scrambler_init                    :   OUT   std_logic_vector(3 DOWNTO 0);  -- boolean [4]
        bat_id                            :   OUT   std_logic_vector(4 DOWNTO 0);  -- boolean [5]
        cp_id                             :   OUT   std_logic_vector(2 DOWNTO 0);  -- boolean [3]
        mimo_spacing                      :   OUT   std_logic_vector(2 DOWNTO 0);  -- boolean [3]
        mimo_number                       :   OUT   std_logic_vector(2 DOWNTO 0)  -- boolean [3]
        );
END full_tx_raw_src_reg_to_variable;


ARCHITECTURE rtl OF full_tx_raw_src_reg_to_variable IS

  -- Signals
  SIGNAL reg0_unsigned                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice_out1                   : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL Switch_out1                      : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL Unit_Delay_out1                  : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL y_1                              : std_logic;  -- ufix1
  SIGNAL y_2                              : std_logic;  -- ufix1
  SIGNAL y_3                              : std_logic;  -- ufix1
  SIGNAL y_4                              : std_logic;  -- ufix1
  SIGNAL y_5                              : std_logic;  -- ufix1
  SIGNAL y_6                              : std_logic;  -- ufix1
  SIGNAL y_7                              : std_logic;  -- ufix1
  SIGNAL y_8                              : std_logic;  -- ufix1
  SIGNAL y_9                              : std_logic;  -- ufix1
  SIGNAL y_10                             : std_logic;  -- ufix1
  SIGNAL y_11                             : std_logic;  -- ufix1
  SIGNAL y_12                             : std_logic;  -- ufix1
  SIGNAL y_13                             : std_logic;  -- ufix1
  SIGNAL y_14                             : std_logic;  -- ufix1
  SIGNAL y_15                             : std_logic;  -- ufix1
  SIGNAL y_16                             : std_logic;  -- ufix1
  SIGNAL y_17                             : std_logic;  -- ufix1
  SIGNAL y_18                             : std_logic;  -- ufix1
  SIGNAL y_19                             : std_logic;  -- ufix1
  SIGNAL y_20                             : std_logic;  -- ufix1
  SIGNAL y_21                             : std_logic;  -- ufix1
  SIGNAL y_22                             : std_logic;  -- ufix1
  SIGNAL y_23                             : std_logic;  -- ufix1
  SIGNAL y_24                             : std_logic;  -- ufix1
  SIGNAL y                                : std_logic_vector(23 DOWNTO 0);  -- ufix1 [24]
  SIGNAL Data_Type_Conversion10_out1      : std_logic_vector(23 DOWNTO 0);  -- boolean [24]
  SIGNAL reg1_unsigned                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Switch1_out1                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Unit_Delay1_out1                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL y_1_1                            : std_logic;  -- ufix1
  SIGNAL y_2_1                            : std_logic;  -- ufix1
  SIGNAL y_3_1                            : std_logic;  -- ufix1
  SIGNAL y_4_1                            : std_logic;  -- ufix1
  SIGNAL y_5_1                            : std_logic;  -- ufix1
  SIGNAL y_6_1                            : std_logic;  -- ufix1
  SIGNAL y_7_1                            : std_logic;  -- ufix1
  SIGNAL y_8_1                            : std_logic;  -- ufix1
  SIGNAL y_9_1                            : std_logic;  -- ufix1
  SIGNAL y_10_1                           : std_logic;  -- ufix1
  SIGNAL y_11_1                           : std_logic;  -- ufix1
  SIGNAL y_12_1                           : std_logic;  -- ufix1
  SIGNAL y_13_1                           : std_logic;  -- ufix1
  SIGNAL y_14_1                           : std_logic;  -- ufix1
  SIGNAL y_15_1                           : std_logic;  -- ufix1
  SIGNAL y_16_1                           : std_logic;  -- ufix1
  SIGNAL y_25                             : std_logic_vector(15 DOWNTO 0);  -- ufix1 [16]
  SIGNAL Data_Type_Conversion11_out1      : std_logic_vector(15 DOWNTO 0);  -- boolean [16]
  SIGNAL reg2_unsigned                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice2_out1                  : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Switch2_out1                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Unit_Delay2_out1                 : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL y_1_2                            : std_logic;  -- ufix1
  SIGNAL y_2_2                            : std_logic;  -- ufix1
  SIGNAL y_27                             : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Data_Type_Conversion9_out1       : std_logic_vector(1 DOWNTO 0);  -- boolean [2]
  SIGNAL Bit_Slice3_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch3_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Unit_Delay3_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL y_1_3                            : std_logic;  -- ufix1
  SIGNAL y_2_3                            : std_logic;  -- ufix1
  SIGNAL y_3_2                            : std_logic;  -- ufix1
  SIGNAL y_29                             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Data_Type_Conversion8_out1       : std_logic_vector(2 DOWNTO 0);  -- boolean [3]
  SIGNAL Bit_Slice4_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch4_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Unit_Delay4_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL y_1_4                            : std_logic;  -- ufix1
  SIGNAL y_2_4                            : std_logic;  -- ufix1
  SIGNAL y_3_3                            : std_logic;  -- ufix1
  SIGNAL y_31                             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Data_Type_Conversion7_out1       : std_logic_vector(2 DOWNTO 0);  -- boolean [3]
  SIGNAL Bit_Slice5_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch5_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Unit_Delay5_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL y_1_5                            : std_logic;  -- ufix1
  SIGNAL y_2_5                            : std_logic;  -- ufix1
  SIGNAL y_3_4                            : std_logic;  -- ufix1
  SIGNAL y_33                             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Data_Type_Conversion6_out1       : std_logic_vector(2 DOWNTO 0);  -- boolean [3]
  SIGNAL reg3_unsigned                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice6_out1                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Switch6_out1                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Unit_Delay6_out1                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL y_1_6                            : std_logic;  -- ufix1
  SIGNAL y_2_6                            : std_logic;  -- ufix1
  SIGNAL y_3_5                            : std_logic;  -- ufix1
  SIGNAL y_4_2                            : std_logic;  -- ufix1
  SIGNAL y_35                             : std_logic_vector(3 DOWNTO 0);  -- ufix1 [4]
  SIGNAL Data_Type_Conversion5_out1       : std_logic_vector(3 DOWNTO 0);  -- boolean [4]
  SIGNAL Bit_Slice7_out1                  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Switch7_out1                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Unit_Delay7_out1                 : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL y_1_7                            : std_logic;  -- ufix1
  SIGNAL y_2_7                            : std_logic;  -- ufix1
  SIGNAL y_3_6                            : std_logic;  -- ufix1
  SIGNAL y_4_3                            : std_logic;  -- ufix1
  SIGNAL y_5_2                            : std_logic;  -- ufix1
  SIGNAL y_37                             : std_logic_vector(4 DOWNTO 0);  -- ufix1 [5]
  SIGNAL Data_Type_Conversion4_out1       : std_logic_vector(4 DOWNTO 0);  -- boolean [5]
  SIGNAL Bit_Slice8_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch8_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Unit_Delay8_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL y_1_8                            : std_logic;  -- ufix1
  SIGNAL y_2_8                            : std_logic;  -- ufix1
  SIGNAL y_3_7                            : std_logic;  -- ufix1
  SIGNAL y_39                             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Data_Type_Conversion3_out1       : std_logic_vector(2 DOWNTO 0);  -- boolean [3]
  SIGNAL Bit_Slice9_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch9_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Unit_Delay9_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL y_1_9                            : std_logic;  -- ufix1
  SIGNAL y_2_9                            : std_logic;  -- ufix1
  SIGNAL y_3_8                            : std_logic;  -- ufix1
  SIGNAL y_41                             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Data_Type_Conversion2_out1       : std_logic_vector(2 DOWNTO 0);  -- boolean [3]
  SIGNAL Bit_Slice10_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch10_out1                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Unit_Delay10_out1                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL y_1_10                           : std_logic;  -- ufix1
  SIGNAL y_2_10                           : std_logic;  -- ufix1
  SIGNAL y_3_9                            : std_logic;  -- ufix1
  SIGNAL y_43                             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Data_Type_Conversion1_out1       : std_logic_vector(2 DOWNTO 0);  -- boolean [3]

BEGIN
  -- All outputs are LSB first

  reg0_unsigned <= unsigned(reg0);

  Bit_Slice_out1 <= reg0_unsigned(23 DOWNTO 0);

  Unit_Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay_out1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay_out1 <= Switch_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_process;


  
  Switch_out1 <= Unit_Delay_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice_out1;

  y_1 <= Switch_out1(0);

  y_2 <= Switch_out1(1);

  y_3 <= Switch_out1(2);

  y_4 <= Switch_out1(3);

  y_5 <= Switch_out1(4);

  y_6 <= Switch_out1(5);

  y_7 <= Switch_out1(6);

  y_8 <= Switch_out1(7);

  y_9 <= Switch_out1(8);

  y_10 <= Switch_out1(9);

  y_11 <= Switch_out1(10);

  y_12 <= Switch_out1(11);

  y_13 <= Switch_out1(12);

  y_14 <= Switch_out1(13);

  y_15 <= Switch_out1(14);

  y_16 <= Switch_out1(15);

  y_17 <= Switch_out1(16);

  y_18 <= Switch_out1(17);

  y_19 <= Switch_out1(18);

  y_20 <= Switch_out1(19);

  y_21 <= Switch_out1(20);

  y_22 <= Switch_out1(21);

  y_23 <= Switch_out1(22);

  y_24 <= Switch_out1(23);

  y(0) <= y_1;
  y(1) <= y_2;
  y(2) <= y_3;
  y(3) <= y_4;
  y(4) <= y_5;
  y(5) <= y_6;
  y(6) <= y_7;
  y(7) <= y_8;
  y(8) <= y_9;
  y(9) <= y_10;
  y(10) <= y_11;
  y(11) <= y_12;
  y(12) <= y_13;
  y(13) <= y_14;
  y(14) <= y_15;
  y(15) <= y_16;
  y(16) <= y_17;
  y(17) <= y_18;
  y(18) <= y_19;
  y(19) <= y_20;
  y(20) <= y_21;
  y(21) <= y_22;
  y(22) <= y_23;
  y(23) <= y_24;

  Data_Type_Conversion10_output : PROCESS (y)
    VARIABLE y1 : std_logic;
  BEGIN
    y1 := '0';

    FOR ii IN 0 TO 23 LOOP
      IF y(ii) /= '0' THEN 
        y1 := '1';
      ELSE 
        y1 := '0';
      END IF;
      Data_Type_Conversion10_out1(ii) <= y1;
    END LOOP;

  END PROCESS Data_Type_Conversion10_output;


  reg1_unsigned <= unsigned(reg1);

  Bit_Slice1_out1 <= reg1_unsigned(15 DOWNTO 0);

  Unit_Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay1_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay1_out1 <= Switch1_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay1_process;


  
  Switch1_out1 <= Unit_Delay1_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice1_out1;

  y_1_1 <= Switch1_out1(0);

  y_2_1 <= Switch1_out1(1);

  y_3_1 <= Switch1_out1(2);

  y_4_1 <= Switch1_out1(3);

  y_5_1 <= Switch1_out1(4);

  y_6_1 <= Switch1_out1(5);

  y_7_1 <= Switch1_out1(6);

  y_8_1 <= Switch1_out1(7);

  y_9_1 <= Switch1_out1(8);

  y_10_1 <= Switch1_out1(9);

  y_11_1 <= Switch1_out1(10);

  y_12_1 <= Switch1_out1(11);

  y_13_1 <= Switch1_out1(12);

  y_14_1 <= Switch1_out1(13);

  y_15_1 <= Switch1_out1(14);

  y_16_1 <= Switch1_out1(15);

  y_25(0) <= y_1_1;
  y_25(1) <= y_2_1;
  y_25(2) <= y_3_1;
  y_25(3) <= y_4_1;
  y_25(4) <= y_5_1;
  y_25(5) <= y_6_1;
  y_25(6) <= y_7_1;
  y_25(7) <= y_8_1;
  y_25(8) <= y_9_1;
  y_25(9) <= y_10_1;
  y_25(10) <= y_11_1;
  y_25(11) <= y_12_1;
  y_25(12) <= y_13_1;
  y_25(13) <= y_14_1;
  y_25(14) <= y_15_1;
  y_25(15) <= y_16_1;

  Data_Type_Conversion11_output : PROCESS (y_25)
    VARIABLE y26 : std_logic;
  BEGIN
    y26 := '0';

    FOR ii1 IN 0 TO 15 LOOP
      IF y_25(ii1) /= '0' THEN 
        y26 := '1';
      ELSE 
        y26 := '0';
      END IF;
      Data_Type_Conversion11_out1(ii1) <= y26;
    END LOOP;

  END PROCESS Data_Type_Conversion11_output;


  reg2_unsigned <= unsigned(reg2);

  Bit_Slice2_out1 <= reg2_unsigned(1 DOWNTO 0);

  Unit_Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay2_out1 <= to_unsigned(16#0#, 2);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay2_out1 <= Switch2_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay2_process;


  
  Switch2_out1 <= Unit_Delay2_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice2_out1;

  y_1_2 <= Switch2_out1(0);

  y_2_2 <= Switch2_out1(1);

  y_27(0) <= y_1_2;
  y_27(1) <= y_2_2;

  Data_Type_Conversion9_output : PROCESS (y_27)
    VARIABLE y28 : std_logic;
  BEGIN
    y28 := '0';

    FOR ii2 IN 0 TO 1 LOOP
      IF y_27(ii2) /= '0' THEN 
        y28 := '1';
      ELSE 
        y28 := '0';
      END IF;
      Data_Type_Conversion9_out1(ii2) <= y28;
    END LOOP;

  END PROCESS Data_Type_Conversion9_output;


  Bit_Slice3_out1 <= reg2_unsigned(10 DOWNTO 8);

  Unit_Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay3_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay3_out1 <= Switch3_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay3_process;


  
  Switch3_out1 <= Unit_Delay3_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice3_out1;

  y_1_3 <= Switch3_out1(0);

  y_2_3 <= Switch3_out1(1);

  y_3_2 <= Switch3_out1(2);

  y_29(0) <= y_1_3;
  y_29(1) <= y_2_3;
  y_29(2) <= y_3_2;

  Data_Type_Conversion8_output : PROCESS (y_29)
    VARIABLE y30 : std_logic;
  BEGIN
    y30 := '0';

    FOR ii3 IN 0 TO 2 LOOP
      IF y_29(ii3) /= '0' THEN 
        y30 := '1';
      ELSE 
        y30 := '0';
      END IF;
      Data_Type_Conversion8_out1(ii3) <= y30;
    END LOOP;

  END PROCESS Data_Type_Conversion8_output;


  Bit_Slice4_out1 <= reg2_unsigned(18 DOWNTO 16);

  Unit_Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay4_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay4_out1 <= Switch4_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay4_process;


  
  Switch4_out1 <= Unit_Delay4_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice4_out1;

  y_1_4 <= Switch4_out1(0);

  y_2_4 <= Switch4_out1(1);

  y_3_3 <= Switch4_out1(2);

  y_31(0) <= y_1_4;
  y_31(1) <= y_2_4;
  y_31(2) <= y_3_3;

  Data_Type_Conversion7_output : PROCESS (y_31)
    VARIABLE y32 : std_logic;
  BEGIN
    y32 := '0';

    FOR ii4 IN 0 TO 2 LOOP
      IF y_31(ii4) /= '0' THEN 
        y32 := '1';
      ELSE 
        y32 := '0';
      END IF;
      Data_Type_Conversion7_out1(ii4) <= y32;
    END LOOP;

  END PROCESS Data_Type_Conversion7_output;


  Bit_Slice5_out1 <= reg2_unsigned(26 DOWNTO 24);

  Unit_Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay5_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay5_out1 <= Switch5_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay5_process;


  
  Switch5_out1 <= Unit_Delay5_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice5_out1;

  y_1_5 <= Switch5_out1(0);

  y_2_5 <= Switch5_out1(1);

  y_3_4 <= Switch5_out1(2);

  y_33(0) <= y_1_5;
  y_33(1) <= y_2_5;
  y_33(2) <= y_3_4;

  Data_Type_Conversion6_output : PROCESS (y_33)
    VARIABLE y34 : std_logic;
  BEGIN
    y34 := '0';

    FOR ii5 IN 0 TO 2 LOOP
      IF y_33(ii5) /= '0' THEN 
        y34 := '1';
      ELSE 
        y34 := '0';
      END IF;
      Data_Type_Conversion6_out1(ii5) <= y34;
    END LOOP;

  END PROCESS Data_Type_Conversion6_output;


  reg3_unsigned <= unsigned(reg3);

  Bit_Slice6_out1 <= reg3_unsigned(3 DOWNTO 0);

  Unit_Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay6_out1 <= to_unsigned(16#0#, 4);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay6_out1 <= Switch6_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay6_process;


  
  Switch6_out1 <= Unit_Delay6_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice6_out1;

  y_1_6 <= Switch6_out1(0);

  y_2_6 <= Switch6_out1(1);

  y_3_5 <= Switch6_out1(2);

  y_4_2 <= Switch6_out1(3);

  y_35(0) <= y_1_6;
  y_35(1) <= y_2_6;
  y_35(2) <= y_3_5;
  y_35(3) <= y_4_2;

  Data_Type_Conversion5_output : PROCESS (y_35)
    VARIABLE y36 : std_logic;
  BEGIN
    y36 := '0';

    FOR ii6 IN 0 TO 3 LOOP
      IF y_35(ii6) /= '0' THEN 
        y36 := '1';
      ELSE 
        y36 := '0';
      END IF;
      Data_Type_Conversion5_out1(ii6) <= y36;
    END LOOP;

  END PROCESS Data_Type_Conversion5_output;


  Bit_Slice7_out1 <= reg3_unsigned(12 DOWNTO 8);

  Unit_Delay7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay7_out1 <= to_unsigned(16#00#, 5);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay7_out1 <= Switch7_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay7_process;


  
  Switch7_out1 <= Unit_Delay7_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice7_out1;

  y_1_7 <= Switch7_out1(0);

  y_2_7 <= Switch7_out1(1);

  y_3_6 <= Switch7_out1(2);

  y_4_3 <= Switch7_out1(3);

  y_5_2 <= Switch7_out1(4);

  y_37(0) <= y_1_7;
  y_37(1) <= y_2_7;
  y_37(2) <= y_3_6;
  y_37(3) <= y_4_3;
  y_37(4) <= y_5_2;

  Data_Type_Conversion4_output : PROCESS (y_37)
    VARIABLE y38 : std_logic;
  BEGIN
    y38 := '0';

    FOR ii7 IN 0 TO 4 LOOP
      IF y_37(ii7) /= '0' THEN 
        y38 := '1';
      ELSE 
        y38 := '0';
      END IF;
      Data_Type_Conversion4_out1(ii7) <= y38;
    END LOOP;

  END PROCESS Data_Type_Conversion4_output;


  Bit_Slice8_out1 <= reg3_unsigned(18 DOWNTO 16);

  Unit_Delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay8_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay8_out1 <= Switch8_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay8_process;


  
  Switch8_out1 <= Unit_Delay8_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice8_out1;

  y_1_8 <= Switch8_out1(0);

  y_2_8 <= Switch8_out1(1);

  y_3_7 <= Switch8_out1(2);

  y_39(0) <= y_1_8;
  y_39(1) <= y_2_8;
  y_39(2) <= y_3_7;

  Data_Type_Conversion3_output : PROCESS (y_39)
    VARIABLE y40 : std_logic;
  BEGIN
    y40 := '0';

    FOR ii8 IN 0 TO 2 LOOP
      IF y_39(ii8) /= '0' THEN 
        y40 := '1';
      ELSE 
        y40 := '0';
      END IF;
      Data_Type_Conversion3_out1(ii8) <= y40;
    END LOOP;

  END PROCESS Data_Type_Conversion3_output;


  Bit_Slice9_out1 <= reg3_unsigned(26 DOWNTO 24);

  Unit_Delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay9_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay9_out1 <= Switch9_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay9_process;


  
  Switch9_out1 <= Unit_Delay9_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice9_out1;

  y_1_9 <= Switch9_out1(0);

  y_2_9 <= Switch9_out1(1);

  y_3_8 <= Switch9_out1(2);

  y_41(0) <= y_1_9;
  y_41(1) <= y_2_9;
  y_41(2) <= y_3_8;

  Data_Type_Conversion2_output : PROCESS (y_41)
    VARIABLE y42 : std_logic;
  BEGIN
    y42 := '0';

    FOR ii9 IN 0 TO 2 LOOP
      IF y_41(ii9) /= '0' THEN 
        y42 := '1';
      ELSE 
        y42 := '0';
      END IF;
      Data_Type_Conversion2_out1(ii9) <= y42;
    END LOOP;

  END PROCESS Data_Type_Conversion2_output;


  Bit_Slice10_out1 <= reg3_unsigned(29 DOWNTO 27);

  Unit_Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay10_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_8_0 = '1' THEN
        Unit_Delay10_out1 <= Switch10_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay10_process;


  
  Switch10_out1 <= Unit_Delay10_out1 WHEN new_frame_in = '0' ELSE
      Bit_Slice10_out1;

  y_1_10 <= Switch10_out1(0);

  y_2_10 <= Switch10_out1(1);

  y_3_9 <= Switch10_out1(2);

  y_43(0) <= y_1_10;
  y_43(1) <= y_2_10;
  y_43(2) <= y_3_9;

  Data_Type_Conversion1_output : PROCESS (y_43)
    VARIABLE y44 : std_logic;
  BEGIN
    y44 := '0';

    FOR ii10 IN 0 TO 2 LOOP
      IF y_43(ii10) /= '0' THEN 
        y44 := '1';
      ELSE 
        y44 := '0';
      END IF;
      Data_Type_Conversion1_out1(ii10) <= y44;
    END LOOP;

  END PROCESS Data_Type_Conversion1_output;


  new_frame_out <= new_frame_in;

  psdu_size <= Data_Type_Conversion10_out1;

  msg_duration <= Data_Type_Conversion11_out1;

  block_size <= Data_Type_Conversion9_out1;

  fec_rate <= Data_Type_Conversion8_out1;

  rep_number <= Data_Type_Conversion7_out1;

  concat_factor <= Data_Type_Conversion6_out1;

  scrambler_init <= Data_Type_Conversion5_out1;

  bat_id <= Data_Type_Conversion4_out1;

  cp_id <= Data_Type_Conversion3_out1;

  mimo_spacing <= Data_Type_Conversion2_out1;

  mimo_number <= Data_Type_Conversion1_out1;

END rtl;

