-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/full_rx_ip_src_FIRDecimInteg.vhd
-- Created: 2024-08-11 11:00:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_rx_ip_src_FIRDecimInteg
-- Source Path: HDLRx/full_rx/rx_demodulator_full/decimator/FIR Decimator/FIRDecimInteg
-- Hierarchy Level: 4
-- Model version: 1.44
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_rx_ip_src_full_rx_pac.ALL;

ENTITY full_rx_ip_src_FIRDecimInteg IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_2_0                         :   IN    std_logic;
        filterOut_cmplx_re                :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33_En28
        filterOut_cmplx_im                :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33_En28
        filterOut_vld                     :   IN    std_logic;
        dataOut_re                        :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
        dataOut_im                        :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
        validOut                          :   OUT   std_logic
        );
END full_rx_ip_src_FIRDecimInteg;


ARCHITECTURE rtl OF full_rx_ip_src_FIRDecimInteg IS

  -- Signals
  SIGNAL filterOut_cmplx_re_signed        : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL filterOut_cmplx_im_signed        : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL FIRdDecimInteg_state             : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_cnt               : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_integReg_re       : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL FIRdDecimInteg_integReg_im       : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL FIRdDecimInteg_integVldReg       : std_logic;
  SIGNAL FIRdDecimInteg_doutReg_re        : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL FIRdDecimInteg_doutReg_im        : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL FIRdDecimInteg_doutVldReg        : std_logic;
  SIGNAL FIRdDecimInteg_state_next        : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_cnt_next          : std_logic;  -- ufix1
  SIGNAL FIRdDecimInteg_integReg_next_re  : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL FIRdDecimInteg_integReg_next_im  : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL FIRdDecimInteg_integVldReg_next  : std_logic;
  SIGNAL FIRdDecimInteg_doutReg_next_re   : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL FIRdDecimInteg_doutReg_next_im   : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL FIRdDecimInteg_doutVldReg_next   : std_logic;
  SIGNAL dataOut_re_tmp                   : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL dataOut_im_tmp                   : signed(15 DOWNTO 0);  -- sfix16_En12

BEGIN
  filterOut_cmplx_re_signed <= signed(filterOut_cmplx_re);

  filterOut_cmplx_im_signed <= signed(filterOut_cmplx_im);

  -- FIRDecimInteg
  FIRdDecimInteg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        FIRdDecimInteg_state <= '0';
        FIRdDecimInteg_integVldReg <= '0';
        FIRdDecimInteg_doutVldReg <= '0';
        FIRdDecimInteg_cnt <= '1';
        FIRdDecimInteg_integReg_re <= to_signed(0, 33);
        FIRdDecimInteg_integReg_im <= to_signed(0, 33);
        FIRdDecimInteg_doutReg_re <= to_signed(16#0000#, 16);
        FIRdDecimInteg_doutReg_im <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        FIRdDecimInteg_state <= FIRdDecimInteg_state_next;
        FIRdDecimInteg_cnt <= FIRdDecimInteg_cnt_next;
        FIRdDecimInteg_integReg_re <= FIRdDecimInteg_integReg_next_re;
        FIRdDecimInteg_integReg_im <= FIRdDecimInteg_integReg_next_im;
        FIRdDecimInteg_integVldReg <= FIRdDecimInteg_integVldReg_next;
        FIRdDecimInteg_doutReg_re <= FIRdDecimInteg_doutReg_next_re;
        FIRdDecimInteg_doutReg_im <= FIRdDecimInteg_doutReg_next_im;
        FIRdDecimInteg_doutVldReg <= FIRdDecimInteg_doutVldReg_next;
      END IF;
    END IF;
  END PROCESS FIRdDecimInteg_process;

  FIRdDecimInteg_output : PROCESS (FIRdDecimInteg_cnt, FIRdDecimInteg_doutReg_im, FIRdDecimInteg_doutReg_re,
       FIRdDecimInteg_doutVldReg, FIRdDecimInteg_integReg_im,
       FIRdDecimInteg_integReg_re, FIRdDecimInteg_integVldReg,
       FIRdDecimInteg_state, filterOut_cmplx_im_signed,
       filterOut_cmplx_re_signed, filterOut_vld)
    VARIABLE sub_cast : unsigned(1 DOWNTO 0);
    VARIABLE sub_temp : unsigned(1 DOWNTO 0);
  BEGIN
    sub_temp := to_unsigned(16#0#, 2);
    sub_cast := to_unsigned(16#0#, 2);
    FIRdDecimInteg_cnt_next <= FIRdDecimInteg_cnt;
    FIRdDecimInteg_integReg_next_re <= FIRdDecimInteg_integReg_re;
    FIRdDecimInteg_integReg_next_im <= FIRdDecimInteg_integReg_im;
    FIRdDecimInteg_integVldReg_next <= FIRdDecimInteg_integVldReg;
    IF FIRdDecimInteg_integVldReg = '1' THEN 
      FIRdDecimInteg_doutReg_next_re <= FIRdDecimInteg_integReg_re(31 DOWNTO 16);
      FIRdDecimInteg_doutReg_next_im <= FIRdDecimInteg_integReg_im(31 DOWNTO 16);
    ELSE 
      FIRdDecimInteg_doutReg_next_re <= to_signed(16#0000#, 16);
      FIRdDecimInteg_doutReg_next_im <= to_signed(16#0000#, 16);
    END IF;
    FIRdDecimInteg_doutVldReg_next <= FIRdDecimInteg_integVldReg;
    CASE FIRdDecimInteg_state IS
      WHEN '0' =>
        FIRdDecimInteg_state_next <= '0';
        FIRdDecimInteg_cnt_next <= '1';
        FIRdDecimInteg_integReg_next_re <= to_signed(0, 33);
        FIRdDecimInteg_integReg_next_im <= to_signed(0, 33);
        FIRdDecimInteg_integVldReg_next <= '0';
        IF filterOut_vld = '1' THEN 
          FIRdDecimInteg_state_next <= '1';
          FIRdDecimInteg_integReg_next_re <= filterOut_cmplx_re_signed;
          FIRdDecimInteg_integReg_next_im <= filterOut_cmplx_im_signed;
          FIRdDecimInteg_cnt_next <= '0';
        END IF;
      WHEN '1' =>
        FIRdDecimInteg_state_next <= '1';
        IF filterOut_vld = '1' THEN 
          FIRdDecimInteg_integReg_next_re <= FIRdDecimInteg_integReg_re + filterOut_cmplx_re_signed;
          FIRdDecimInteg_integReg_next_im <= FIRdDecimInteg_integReg_im + filterOut_cmplx_im_signed;
          IF FIRdDecimInteg_cnt = '0' THEN 
            FIRdDecimInteg_state_next <= '0';
            FIRdDecimInteg_integVldReg_next <= '1';
            FIRdDecimInteg_cnt_next <= '1';
          ELSE 
            sub_cast := '0' & FIRdDecimInteg_cnt;
            sub_temp := sub_cast - to_unsigned(16#1#, 2);
            FIRdDecimInteg_cnt_next <= sub_temp(0);
          END IF;
        END IF;
      WHEN OTHERS => 
        FIRdDecimInteg_state_next <= '0';
        FIRdDecimInteg_cnt_next <= '1';
        FIRdDecimInteg_integReg_next_re <= to_signed(0, 33);
        FIRdDecimInteg_integReg_next_im <= to_signed(0, 33);
        FIRdDecimInteg_integVldReg_next <= '0';
    END CASE;
    dataOut_re_tmp <= FIRdDecimInteg_doutReg_re;
    dataOut_im_tmp <= FIRdDecimInteg_doutReg_im;
    validOut <= FIRdDecimInteg_doutVldReg;
  END PROCESS FIRdDecimInteg_output;


  dataOut_re <= std_logic_vector(dataOut_re_tmp);

  dataOut_im <= std_logic_vector(dataOut_im_tmp);

END rtl;

