-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRx/IEEE_8021513_RX_src_normalizedCORDICDivide_block1.vhd
-- Created: 2024-11-23 11:22:02
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IEEE_8021513_RX_src_normalizedCORDICDivide_block1
-- Source Path: HDLRx/full_rx/rx_demodulator_full/ofdm_symbol_sync/m_cox/Real Divide HDL Optimized/ForEach - Real 
-- Divide/Divide real numerator by denominator/normalizedCORDICDivid
-- Hierarchy Level: 7
-- Model version: 1.147
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IEEE_8021513_RX_src_full_rx_pac.ALL;

ENTITY IEEE_8021513_RX_src_normalizedCORDICDivide_block1 IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_2_0                         :   IN    std_logic;
        num                               :   IN    std_logic_vector(24 DOWNTO 0);  -- sfix25_En23
        den                               :   IN    std_logic_vector(24 DOWNTO 0);  -- sfix25_En23
        tNum                              :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33
        tDen                              :   IN    std_logic_vector(31 DOWNTO 0);  -- int32
        isNumNegative                     :   IN    std_logic;
        isDenNegative                     :   IN    std_logic;
        validIn                           :   IN    std_logic;
        y                                 :   OUT   std_logic_vector(24 DOWNTO 0);  -- sfix25_En23
        t                                 :   OUT   std_logic_vector(33 DOWNTO 0);  -- sfix34
        isDenZeroOut                      :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END IEEE_8021513_RX_src_normalizedCORDICDivide_block1;


ARCHITECTURE rtl OF IEEE_8021513_RX_src_normalizedCORDICDivide_block1 IS

  -- Signals
  SIGNAL num_signed                       : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL den_signed                       : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL tNum_signed                      : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL tDen_signed                      : signed(31 DOWNTO 0);  -- int32
  SIGNAL y_tmp                            : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL t_tmp                            : signed(33 DOWNTO 0);  -- sfix34
  SIGNAL xReg                             : vector_of_signed25(0 TO 25);  -- sfix25 [26]
  SIGNAL yReg                             : vector_of_signed25(0 TO 25);  -- sfix25 [26]
  SIGNAL zReg                             : vector_of_signed25(0 TO 25);  -- sfix25 [26]
  SIGNAL validReg                         : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL tReg                             : vector_of_signed34(0 TO 25);  -- sfix34 [26]
  SIGNAL isNegativeReg                    : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL isNumZeroReg                     : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL isDenZeroReg                     : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL xReg_next                        : vector_of_signed25(0 TO 25);  -- sfix25_En23 [26]
  SIGNAL yReg_next                        : vector_of_signed25(0 TO 25);  -- sfix25_En23 [26]
  SIGNAL zReg_next                        : vector_of_signed25(0 TO 25);  -- sfix25_En23 [26]
  SIGNAL validReg_next                    : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL tReg_next                        : vector_of_signed34(0 TO 25);  -- sfix34 [26]
  SIGNAL isNegativeReg_next               : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL isNumZeroReg_next                : std_logic_vector(25 DOWNTO 0);  -- boolean [26]
  SIGNAL isDenZeroReg_next                : std_logic_vector(25 DOWNTO 0);  -- boolean [26]

BEGIN
  num_signed <= signed(num);

  den_signed <= signed(den);

  tNum_signed <= signed(tNum);

  tDen_signed <= signed(tDen);

  embreciprocals_c21_sj6UbcgrIwOfHv5tI9jPSMG_normalizedCORDICDivi_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        xReg <= (OTHERS => to_signed(16#0000000#, 25));
        yReg <= (OTHERS => to_signed(16#0000000#, 25));
        zReg <= (OTHERS => to_signed(16#0000000#, 25));
        validReg <= (OTHERS => '0');
        tReg <= (OTHERS => to_signed(0, 34));
        isNegativeReg <= (OTHERS => '0');
        isDenZeroReg <= (OTHERS => '0');
        isNumZeroReg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        xReg <= xReg_next;
        yReg <= yReg_next;
        zReg <= zReg_next;
        validReg <= validReg_next;
        tReg <= tReg_next;
        isNegativeReg <= isNegativeReg_next;
        isNumZeroReg <= isNumZeroReg_next;
        isDenZeroReg <= isDenZeroReg_next;
      END IF;
    END IF;
  END PROCESS embreciprocals_c21_sj6UbcgrIwOfHv5tI9jPSMG_normalizedCORDICDivi_process;

  embreciprocals_c21_sj6UbcgrIwOfHv5tI9jPSMG_normalizedCORDICDivi_output : PROCESS (den_signed, isDenNegative, isDenZeroReg, isNegativeReg, isNumNegative,
       isNumZeroReg, num_signed, tDen_signed, tNum_signed, tReg, validIn,
       validReg, xReg, yReg, zReg)
    VARIABLE isDenZero : std_logic;
    VARIABLE isNumZero : std_logic;
    VARIABLE sub_temp : signed(24 DOWNTO 0);
    VARIABLE t_0 : signed(24 DOWNTO 0);
    VARIABLE a : signed(24 DOWNTO 0);
    VARIABLE c : signed(24 DOWNTO 0);
    VARIABLE a_0 : signed(24 DOWNTO 0);
    VARIABLE c_0 : signed(24 DOWNTO 0);
    VARIABLE a_1 : signed(24 DOWNTO 0);
    VARIABLE c_1 : signed(24 DOWNTO 0);
    VARIABLE a_2 : signed(24 DOWNTO 0);
    VARIABLE c_2 : signed(24 DOWNTO 0);
    VARIABLE a_3 : signed(24 DOWNTO 0);
    VARIABLE c_3 : signed(24 DOWNTO 0);
    VARIABLE a_4 : signed(24 DOWNTO 0);
    VARIABLE c_4 : signed(24 DOWNTO 0);
    VARIABLE a_5 : signed(24 DOWNTO 0);
    VARIABLE c_5 : signed(24 DOWNTO 0);
    VARIABLE a_6 : signed(24 DOWNTO 0);
    VARIABLE c_6 : signed(24 DOWNTO 0);
    VARIABLE a_7 : signed(24 DOWNTO 0);
    VARIABLE c_7 : signed(24 DOWNTO 0);
    VARIABLE a_8 : signed(24 DOWNTO 0);
    VARIABLE c_8 : signed(24 DOWNTO 0);
    VARIABLE a_9 : signed(24 DOWNTO 0);
    VARIABLE c_9 : signed(24 DOWNTO 0);
    VARIABLE a_10 : signed(24 DOWNTO 0);
    VARIABLE c_10 : signed(24 DOWNTO 0);
    VARIABLE a_11 : signed(24 DOWNTO 0);
    VARIABLE c_11 : signed(24 DOWNTO 0);
    VARIABLE a_12 : signed(24 DOWNTO 0);
    VARIABLE c_12 : signed(24 DOWNTO 0);
    VARIABLE a_13 : signed(24 DOWNTO 0);
    VARIABLE c_13 : signed(24 DOWNTO 0);
    VARIABLE a_14 : signed(24 DOWNTO 0);
    VARIABLE c_14 : signed(24 DOWNTO 0);
    VARIABLE a_15 : signed(24 DOWNTO 0);
    VARIABLE c_15 : signed(24 DOWNTO 0);
    VARIABLE a_16 : signed(24 DOWNTO 0);
    VARIABLE c_16 : signed(24 DOWNTO 0);
    VARIABLE a_17 : signed(24 DOWNTO 0);
    VARIABLE c_17 : signed(24 DOWNTO 0);
    VARIABLE a_18 : signed(24 DOWNTO 0);
    VARIABLE c_18 : signed(24 DOWNTO 0);
    VARIABLE a_19 : signed(24 DOWNTO 0);
    VARIABLE c_19 : signed(24 DOWNTO 0);
    VARIABLE a_20 : signed(24 DOWNTO 0);
    VARIABLE c_20 : signed(24 DOWNTO 0);
    VARIABLE a_21 : signed(24 DOWNTO 0);
    VARIABLE c_21 : signed(24 DOWNTO 0);
    VARIABLE a_22 : signed(24 DOWNTO 0);
    VARIABLE c_22 : signed(24 DOWNTO 0);
    VARIABLE a_23 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(24 DOWNTO 0);
    VARIABLE add_temp : signed(24 DOWNTO 0);
    VARIABLE sub_temp_1 : signed(24 DOWNTO 0);
    VARIABLE add_temp_0 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_2 : signed(24 DOWNTO 0);
    VARIABLE add_temp_1 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_3 : signed(24 DOWNTO 0);
    VARIABLE add_temp_2 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_4 : signed(24 DOWNTO 0);
    VARIABLE add_temp_3 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_5 : signed(24 DOWNTO 0);
    VARIABLE add_temp_4 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_6 : signed(24 DOWNTO 0);
    VARIABLE add_temp_5 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_7 : signed(24 DOWNTO 0);
    VARIABLE add_temp_6 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_8 : signed(24 DOWNTO 0);
    VARIABLE add_temp_7 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_9 : signed(24 DOWNTO 0);
    VARIABLE add_temp_8 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_10 : signed(24 DOWNTO 0);
    VARIABLE add_temp_9 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_11 : signed(24 DOWNTO 0);
    VARIABLE add_temp_10 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_12 : signed(24 DOWNTO 0);
    VARIABLE add_temp_11 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_13 : signed(24 DOWNTO 0);
    VARIABLE add_temp_12 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_14 : signed(24 DOWNTO 0);
    VARIABLE add_temp_13 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_15 : signed(24 DOWNTO 0);
    VARIABLE add_temp_14 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_16 : signed(24 DOWNTO 0);
    VARIABLE add_temp_15 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_17 : signed(24 DOWNTO 0);
    VARIABLE add_temp_16 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_18 : signed(24 DOWNTO 0);
    VARIABLE add_temp_17 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_19 : signed(24 DOWNTO 0);
    VARIABLE add_temp_18 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_20 : signed(24 DOWNTO 0);
    VARIABLE add_temp_19 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_21 : signed(24 DOWNTO 0);
    VARIABLE add_temp_20 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_22 : signed(24 DOWNTO 0);
    VARIABLE add_temp_21 : signed(24 DOWNTO 0);
    VARIABLE sub_temp_23 : signed(24 DOWNTO 0);
    VARIABLE add_temp_22 : signed(24 DOWNTO 0);
    VARIABLE cast : signed(25 DOWNTO 0);
    VARIABLE cast_0 : signed(25 DOWNTO 0);
  BEGIN
    cast_0 := to_signed(16#0000000#, 26);
    cast := to_signed(16#0000000#, 26);
    --   Copyright 2020 The MathWorks, Inc.
    IF den_signed = to_signed(16#0000000#, 25) THEN 
      isDenZero := '1';
    ELSE 
      isDenZero := '0';
    END IF;
    IF num_signed = to_signed(16#0000000#, 25) THEN 
      isNumZero := '1';
    ELSE 
      isNumZero := '0';
    END IF;
    -- CORDIC divide for fixed-point and scaled-double types
    -- Register variables for the CORDIC Divide Kernel
    -- CORDIC Divide Kernel
    validReg_next(25) <= validReg(24);
    tReg_next(25) <= tReg(24);
    validReg_next(24) <= validReg(23);
    tReg_next(24) <= tReg(23);
    validReg_next(23) <= validReg(22);
    tReg_next(23) <= tReg(22);
    validReg_next(22) <= validReg(21);
    tReg_next(22) <= tReg(21);
    validReg_next(21) <= validReg(20);
    tReg_next(21) <= tReg(20);
    validReg_next(20) <= validReg(19);
    tReg_next(20) <= tReg(19);
    validReg_next(19) <= validReg(18);
    tReg_next(19) <= tReg(18);
    validReg_next(18) <= validReg(17);
    tReg_next(18) <= tReg(17);
    validReg_next(17) <= validReg(16);
    tReg_next(17) <= tReg(16);
    validReg_next(16) <= validReg(15);
    tReg_next(16) <= tReg(15);
    validReg_next(15) <= validReg(14);
    tReg_next(15) <= tReg(14);
    validReg_next(14) <= validReg(13);
    tReg_next(14) <= tReg(13);
    validReg_next(13) <= validReg(12);
    tReg_next(13) <= tReg(12);
    validReg_next(12) <= validReg(11);
    tReg_next(12) <= tReg(11);
    validReg_next(11) <= validReg(10);
    tReg_next(11) <= tReg(10);
    validReg_next(10) <= validReg(9);
    tReg_next(10) <= tReg(9);
    validReg_next(9) <= validReg(8);
    tReg_next(9) <= tReg(8);
    validReg_next(8) <= validReg(7);
    tReg_next(8) <= tReg(7);
    validReg_next(7) <= validReg(6);
    tReg_next(7) <= tReg(6);
    validReg_next(6) <= validReg(5);
    tReg_next(6) <= tReg(5);
    validReg_next(5) <= validReg(4);
    tReg_next(5) <= tReg(4);
    validReg_next(4) <= validReg(3);
    tReg_next(4) <= tReg(3);
    validReg_next(3) <= validReg(2);
    tReg_next(3) <= tReg(2);
    validReg_next(2) <= validReg(1);
    tReg_next(2) <= tReg(1);
    validReg_next(1) <= validReg(0);
    tReg_next(1) <= tReg(0);
    validReg_next(0) <= validIn;
    tReg_next(0) <= resize(tDen_signed, 34) - resize(tNum_signed, 34);
    a := xReg(24);
    c := SHIFT_RIGHT(a, 24);
    IF yReg(24) < to_signed(16#0000000#, 25) THEN 
      sub_temp := yReg(24) + c;
      t_0 := zReg(24);
    ELSE 
      sub_temp := yReg(24) - c;
      t_0 := zReg(24);
    END IF;
    yReg_next(25) <= sub_temp;
    zReg_next(25) <= t_0;
    xReg_next(25) <= xReg(24);
    a_0 := xReg(23);
    c_0 := SHIFT_RIGHT(a_0, 23);
    IF yReg(23) < to_signed(16#0000000#, 25) THEN 
      sub_temp_0 := yReg(23) + c_0;
      add_temp := zReg(23) - to_signed(16#0000001#, 25);
    ELSE 
      sub_temp_0 := yReg(23) - c_0;
      add_temp := zReg(23) + to_signed(16#0000001#, 25);
    END IF;
    yReg_next(24) <= sub_temp_0;
    zReg_next(24) <= add_temp;
    xReg_next(24) <= xReg(23);
    a_1 := xReg(22);
    c_1 := SHIFT_RIGHT(a_1, 22);
    IF yReg(22) < to_signed(16#0000000#, 25) THEN 
      sub_temp_1 := yReg(22) + c_1;
      add_temp_0 := zReg(22) - to_signed(16#0000002#, 25);
    ELSE 
      sub_temp_1 := yReg(22) - c_1;
      add_temp_0 := zReg(22) + to_signed(16#0000002#, 25);
    END IF;
    yReg_next(23) <= sub_temp_1;
    zReg_next(23) <= add_temp_0;
    xReg_next(23) <= xReg(22);
    a_2 := xReg(21);
    c_2 := SHIFT_RIGHT(a_2, 21);
    IF yReg(21) < to_signed(16#0000000#, 25) THEN 
      sub_temp_2 := yReg(21) + c_2;
      add_temp_1 := zReg(21) - to_signed(16#0000004#, 25);
    ELSE 
      sub_temp_2 := yReg(21) - c_2;
      add_temp_1 := zReg(21) + to_signed(16#0000004#, 25);
    END IF;
    yReg_next(22) <= sub_temp_2;
    zReg_next(22) <= add_temp_1;
    xReg_next(22) <= xReg(21);
    a_3 := xReg(20);
    c_3 := SHIFT_RIGHT(a_3, 20);
    IF yReg(20) < to_signed(16#0000000#, 25) THEN 
      sub_temp_3 := yReg(20) + c_3;
      add_temp_2 := zReg(20) - to_signed(16#0000008#, 25);
    ELSE 
      sub_temp_3 := yReg(20) - c_3;
      add_temp_2 := zReg(20) + to_signed(16#0000008#, 25);
    END IF;
    yReg_next(21) <= sub_temp_3;
    zReg_next(21) <= add_temp_2;
    xReg_next(21) <= xReg(20);
    a_4 := xReg(19);
    c_4 := SHIFT_RIGHT(a_4, 19);
    IF yReg(19) < to_signed(16#0000000#, 25) THEN 
      sub_temp_4 := yReg(19) + c_4;
      add_temp_3 := zReg(19) - to_signed(16#0000010#, 25);
    ELSE 
      sub_temp_4 := yReg(19) - c_4;
      add_temp_3 := zReg(19) + to_signed(16#0000010#, 25);
    END IF;
    yReg_next(20) <= sub_temp_4;
    zReg_next(20) <= add_temp_3;
    xReg_next(20) <= xReg(19);
    a_5 := xReg(18);
    c_5 := SHIFT_RIGHT(a_5, 18);
    IF yReg(18) < to_signed(16#0000000#, 25) THEN 
      sub_temp_5 := yReg(18) + c_5;
      add_temp_4 := zReg(18) - to_signed(16#0000020#, 25);
    ELSE 
      sub_temp_5 := yReg(18) - c_5;
      add_temp_4 := zReg(18) + to_signed(16#0000020#, 25);
    END IF;
    yReg_next(19) <= sub_temp_5;
    zReg_next(19) <= add_temp_4;
    xReg_next(19) <= xReg(18);
    a_6 := xReg(17);
    c_6 := SHIFT_RIGHT(a_6, 17);
    IF yReg(17) < to_signed(16#0000000#, 25) THEN 
      sub_temp_6 := yReg(17) + c_6;
      add_temp_5 := zReg(17) - to_signed(16#0000040#, 25);
    ELSE 
      sub_temp_6 := yReg(17) - c_6;
      add_temp_5 := zReg(17) + to_signed(16#0000040#, 25);
    END IF;
    yReg_next(18) <= sub_temp_6;
    zReg_next(18) <= add_temp_5;
    xReg_next(18) <= xReg(17);
    a_7 := xReg(16);
    c_7 := SHIFT_RIGHT(a_7, 16);
    IF yReg(16) < to_signed(16#0000000#, 25) THEN 
      sub_temp_7 := yReg(16) + c_7;
      add_temp_6 := zReg(16) - to_signed(16#0000080#, 25);
    ELSE 
      sub_temp_7 := yReg(16) - c_7;
      add_temp_6 := zReg(16) + to_signed(16#0000080#, 25);
    END IF;
    yReg_next(17) <= sub_temp_7;
    zReg_next(17) <= add_temp_6;
    xReg_next(17) <= xReg(16);
    a_8 := xReg(15);
    c_8 := SHIFT_RIGHT(a_8, 15);
    IF yReg(15) < to_signed(16#0000000#, 25) THEN 
      sub_temp_8 := yReg(15) + c_8;
      add_temp_7 := zReg(15) - to_signed(16#0000100#, 25);
    ELSE 
      sub_temp_8 := yReg(15) - c_8;
      add_temp_7 := zReg(15) + to_signed(16#0000100#, 25);
    END IF;
    yReg_next(16) <= sub_temp_8;
    zReg_next(16) <= add_temp_7;
    xReg_next(16) <= xReg(15);
    a_9 := xReg(14);
    c_9 := SHIFT_RIGHT(a_9, 14);
    IF yReg(14) < to_signed(16#0000000#, 25) THEN 
      sub_temp_9 := yReg(14) + c_9;
      add_temp_8 := zReg(14) - to_signed(16#0000200#, 25);
    ELSE 
      sub_temp_9 := yReg(14) - c_9;
      add_temp_8 := zReg(14) + to_signed(16#0000200#, 25);
    END IF;
    yReg_next(15) <= sub_temp_9;
    zReg_next(15) <= add_temp_8;
    xReg_next(15) <= xReg(14);
    a_10 := xReg(13);
    c_10 := SHIFT_RIGHT(a_10, 13);
    IF yReg(13) < to_signed(16#0000000#, 25) THEN 
      sub_temp_10 := yReg(13) + c_10;
      add_temp_9 := zReg(13) - to_signed(16#0000400#, 25);
    ELSE 
      sub_temp_10 := yReg(13) - c_10;
      add_temp_9 := zReg(13) + to_signed(16#0000400#, 25);
    END IF;
    yReg_next(14) <= sub_temp_10;
    zReg_next(14) <= add_temp_9;
    xReg_next(14) <= xReg(13);
    a_11 := xReg(12);
    c_11 := SHIFT_RIGHT(a_11, 12);
    IF yReg(12) < to_signed(16#0000000#, 25) THEN 
      sub_temp_11 := yReg(12) + c_11;
      add_temp_10 := zReg(12) - to_signed(16#0000800#, 25);
    ELSE 
      sub_temp_11 := yReg(12) - c_11;
      add_temp_10 := zReg(12) + to_signed(16#0000800#, 25);
    END IF;
    yReg_next(13) <= sub_temp_11;
    zReg_next(13) <= add_temp_10;
    xReg_next(13) <= xReg(12);
    a_12 := xReg(11);
    c_12 := SHIFT_RIGHT(a_12, 11);
    IF yReg(11) < to_signed(16#0000000#, 25) THEN 
      sub_temp_12 := yReg(11) + c_12;
      add_temp_11 := zReg(11) - to_signed(16#0001000#, 25);
    ELSE 
      sub_temp_12 := yReg(11) - c_12;
      add_temp_11 := zReg(11) + to_signed(16#0001000#, 25);
    END IF;
    yReg_next(12) <= sub_temp_12;
    zReg_next(12) <= add_temp_11;
    xReg_next(12) <= xReg(11);
    a_13 := xReg(10);
    c_13 := SHIFT_RIGHT(a_13, 10);
    IF yReg(10) < to_signed(16#0000000#, 25) THEN 
      sub_temp_13 := yReg(10) + c_13;
      add_temp_12 := zReg(10) - to_signed(16#0002000#, 25);
    ELSE 
      sub_temp_13 := yReg(10) - c_13;
      add_temp_12 := zReg(10) + to_signed(16#0002000#, 25);
    END IF;
    yReg_next(11) <= sub_temp_13;
    zReg_next(11) <= add_temp_12;
    xReg_next(11) <= xReg(10);
    a_14 := xReg(9);
    c_14 := SHIFT_RIGHT(a_14, 9);
    IF yReg(9) < to_signed(16#0000000#, 25) THEN 
      sub_temp_14 := yReg(9) + c_14;
      add_temp_13 := zReg(9) - to_signed(16#0004000#, 25);
    ELSE 
      sub_temp_14 := yReg(9) - c_14;
      add_temp_13 := zReg(9) + to_signed(16#0004000#, 25);
    END IF;
    yReg_next(10) <= sub_temp_14;
    zReg_next(10) <= add_temp_13;
    xReg_next(10) <= xReg(9);
    a_15 := xReg(8);
    c_15 := SHIFT_RIGHT(a_15, 8);
    IF yReg(8) < to_signed(16#0000000#, 25) THEN 
      sub_temp_15 := yReg(8) + c_15;
      add_temp_14 := zReg(8) - to_signed(16#0008000#, 25);
    ELSE 
      sub_temp_15 := yReg(8) - c_15;
      add_temp_14 := zReg(8) + to_signed(16#0008000#, 25);
    END IF;
    yReg_next(9) <= sub_temp_15;
    zReg_next(9) <= add_temp_14;
    xReg_next(9) <= xReg(8);
    a_16 := xReg(7);
    c_16 := SHIFT_RIGHT(a_16, 7);
    IF yReg(7) < to_signed(16#0000000#, 25) THEN 
      sub_temp_16 := yReg(7) + c_16;
      add_temp_15 := zReg(7) - to_signed(16#0010000#, 25);
    ELSE 
      sub_temp_16 := yReg(7) - c_16;
      add_temp_15 := zReg(7) + to_signed(16#0010000#, 25);
    END IF;
    yReg_next(8) <= sub_temp_16;
    zReg_next(8) <= add_temp_15;
    xReg_next(8) <= xReg(7);
    a_17 := xReg(6);
    c_17 := SHIFT_RIGHT(a_17, 6);
    IF yReg(6) < to_signed(16#0000000#, 25) THEN 
      sub_temp_17 := yReg(6) + c_17;
      add_temp_16 := zReg(6) - to_signed(16#0020000#, 25);
    ELSE 
      sub_temp_17 := yReg(6) - c_17;
      add_temp_16 := zReg(6) + to_signed(16#0020000#, 25);
    END IF;
    yReg_next(7) <= sub_temp_17;
    zReg_next(7) <= add_temp_16;
    xReg_next(7) <= xReg(6);
    a_18 := xReg(5);
    c_18 := SHIFT_RIGHT(a_18, 5);
    IF yReg(5) < to_signed(16#0000000#, 25) THEN 
      sub_temp_18 := yReg(5) + c_18;
      add_temp_17 := zReg(5) - to_signed(16#0040000#, 25);
    ELSE 
      sub_temp_18 := yReg(5) - c_18;
      add_temp_17 := zReg(5) + to_signed(16#0040000#, 25);
    END IF;
    yReg_next(6) <= sub_temp_18;
    zReg_next(6) <= add_temp_17;
    xReg_next(6) <= xReg(5);
    a_19 := xReg(4);
    c_19 := SHIFT_RIGHT(a_19, 4);
    IF yReg(4) < to_signed(16#0000000#, 25) THEN 
      sub_temp_19 := yReg(4) + c_19;
      add_temp_18 := zReg(4) - to_signed(16#0080000#, 25);
    ELSE 
      sub_temp_19 := yReg(4) - c_19;
      add_temp_18 := zReg(4) + to_signed(16#0080000#, 25);
    END IF;
    yReg_next(5) <= sub_temp_19;
    zReg_next(5) <= add_temp_18;
    xReg_next(5) <= xReg(4);
    a_20 := xReg(3);
    c_20 := SHIFT_RIGHT(a_20, 3);
    IF yReg(3) < to_signed(16#0000000#, 25) THEN 
      sub_temp_20 := yReg(3) + c_20;
      add_temp_19 := zReg(3) - to_signed(16#0100000#, 25);
    ELSE 
      sub_temp_20 := yReg(3) - c_20;
      add_temp_19 := zReg(3) + to_signed(16#0100000#, 25);
    END IF;
    yReg_next(4) <= sub_temp_20;
    zReg_next(4) <= add_temp_19;
    xReg_next(4) <= xReg(3);
    a_21 := xReg(2);
    c_21 := SHIFT_RIGHT(a_21, 2);
    IF yReg(2) < to_signed(16#0000000#, 25) THEN 
      sub_temp_21 := yReg(2) + c_21;
      add_temp_20 := zReg(2) - to_signed(16#0200000#, 25);
    ELSE 
      sub_temp_21 := yReg(2) - c_21;
      add_temp_20 := zReg(2) + to_signed(16#0200000#, 25);
    END IF;
    yReg_next(3) <= sub_temp_21;
    zReg_next(3) <= add_temp_20;
    xReg_next(3) <= xReg(2);
    a_22 := xReg(1);
    c_22 := SHIFT_RIGHT(a_22, 1);
    IF yReg(1) < to_signed(16#0000000#, 25) THEN 
      sub_temp_22 := yReg(1) + c_22;
      add_temp_21 := zReg(1) - to_signed(16#0400000#, 25);
    ELSE 
      sub_temp_22 := yReg(1) - c_22;
      add_temp_21 := zReg(1) + to_signed(16#0400000#, 25);
    END IF;
    yReg_next(2) <= sub_temp_22;
    zReg_next(2) <= add_temp_21;
    xReg_next(2) <= xReg(1);
    a_23 := xReg(0);
    IF yReg(0) < to_signed(16#0000000#, 25) THEN 
      sub_temp_23 := yReg(0) + a_23;
      add_temp_22 := zReg(0) - to_signed(16#0800000#, 25);
    ELSE 
      sub_temp_23 := yReg(0) - a_23;
      add_temp_22 := zReg(0) + to_signed(16#0800000#, 25);
    END IF;
    yReg_next(1) <= sub_temp_23;
    zReg_next(1) <= add_temp_22;
    xReg_next(1) <= xReg(0);
    xReg_next(0) <= den_signed;
    yReg_next(0) <= num_signed;
    zReg_next(0) <= to_signed(16#0000000#, 25);
    -- % Persistent variables
    -- Assign outputs from states
    -- Update isNegative states
    isNegativeReg_next(25) <= isNegativeReg(24);
    isNumZeroReg_next(25) <= isNumZeroReg(24);
    isDenZeroReg_next(25) <= isDenZeroReg(24);
    isNegativeReg_next(24) <= isNegativeReg(23);
    isNumZeroReg_next(24) <= isNumZeroReg(23);
    isDenZeroReg_next(24) <= isDenZeroReg(23);
    isNegativeReg_next(23) <= isNegativeReg(22);
    isNumZeroReg_next(23) <= isNumZeroReg(22);
    isDenZeroReg_next(23) <= isDenZeroReg(22);
    isNegativeReg_next(22) <= isNegativeReg(21);
    isNumZeroReg_next(22) <= isNumZeroReg(21);
    isDenZeroReg_next(22) <= isDenZeroReg(21);
    isNegativeReg_next(21) <= isNegativeReg(20);
    isNumZeroReg_next(21) <= isNumZeroReg(20);
    isDenZeroReg_next(21) <= isDenZeroReg(20);
    isNegativeReg_next(20) <= isNegativeReg(19);
    isNumZeroReg_next(20) <= isNumZeroReg(19);
    isDenZeroReg_next(20) <= isDenZeroReg(19);
    isNegativeReg_next(19) <= isNegativeReg(18);
    isNumZeroReg_next(19) <= isNumZeroReg(18);
    isDenZeroReg_next(19) <= isDenZeroReg(18);
    isNegativeReg_next(18) <= isNegativeReg(17);
    isNumZeroReg_next(18) <= isNumZeroReg(17);
    isDenZeroReg_next(18) <= isDenZeroReg(17);
    isNegativeReg_next(17) <= isNegativeReg(16);
    isNumZeroReg_next(17) <= isNumZeroReg(16);
    isDenZeroReg_next(17) <= isDenZeroReg(16);
    isNegativeReg_next(16) <= isNegativeReg(15);
    isNumZeroReg_next(16) <= isNumZeroReg(15);
    isDenZeroReg_next(16) <= isDenZeroReg(15);
    isNegativeReg_next(15) <= isNegativeReg(14);
    isNumZeroReg_next(15) <= isNumZeroReg(14);
    isDenZeroReg_next(15) <= isDenZeroReg(14);
    isNegativeReg_next(14) <= isNegativeReg(13);
    isNumZeroReg_next(14) <= isNumZeroReg(13);
    isDenZeroReg_next(14) <= isDenZeroReg(13);
    isNegativeReg_next(13) <= isNegativeReg(12);
    isNumZeroReg_next(13) <= isNumZeroReg(12);
    isDenZeroReg_next(13) <= isDenZeroReg(12);
    isNegativeReg_next(12) <= isNegativeReg(11);
    isNumZeroReg_next(12) <= isNumZeroReg(11);
    isDenZeroReg_next(12) <= isDenZeroReg(11);
    isNegativeReg_next(11) <= isNegativeReg(10);
    isNumZeroReg_next(11) <= isNumZeroReg(10);
    isDenZeroReg_next(11) <= isDenZeroReg(10);
    isNegativeReg_next(10) <= isNegativeReg(9);
    isNumZeroReg_next(10) <= isNumZeroReg(9);
    isDenZeroReg_next(10) <= isDenZeroReg(9);
    isNegativeReg_next(9) <= isNegativeReg(8);
    isNumZeroReg_next(9) <= isNumZeroReg(8);
    isDenZeroReg_next(9) <= isDenZeroReg(8);
    isNegativeReg_next(8) <= isNegativeReg(7);
    isNumZeroReg_next(8) <= isNumZeroReg(7);
    isDenZeroReg_next(8) <= isDenZeroReg(7);
    isNegativeReg_next(7) <= isNegativeReg(6);
    isNumZeroReg_next(7) <= isNumZeroReg(6);
    isDenZeroReg_next(7) <= isDenZeroReg(6);
    isNegativeReg_next(6) <= isNegativeReg(5);
    isNumZeroReg_next(6) <= isNumZeroReg(5);
    isDenZeroReg_next(6) <= isDenZeroReg(5);
    isNegativeReg_next(5) <= isNegativeReg(4);
    isNumZeroReg_next(5) <= isNumZeroReg(4);
    isDenZeroReg_next(5) <= isDenZeroReg(4);
    isNegativeReg_next(4) <= isNegativeReg(3);
    isNumZeroReg_next(4) <= isNumZeroReg(3);
    isDenZeroReg_next(4) <= isDenZeroReg(3);
    isNegativeReg_next(3) <= isNegativeReg(2);
    isNumZeroReg_next(3) <= isNumZeroReg(2);
    isDenZeroReg_next(3) <= isDenZeroReg(2);
    isNegativeReg_next(2) <= isNegativeReg(1);
    isNumZeroReg_next(2) <= isNumZeroReg(1);
    isDenZeroReg_next(2) <= isDenZeroReg(1);
    isNegativeReg_next(1) <= isNegativeReg(0);
    isNumZeroReg_next(1) <= isNumZeroReg(0);
    isDenZeroReg_next(1) <= isDenZeroReg(0);
    IF isNumNegative /= isDenNegative THEN 
      isNegativeReg_next(0) <= '1';
    ELSE 
      isNegativeReg_next(0) <= '0';
    END IF;
    isNumZeroReg_next(0) <= isNumZero;
    isDenZeroReg_next(0) <= isDenZero;
    y_tmp <= zReg(25);
    IF isNumZeroReg(25) = '1' THEN 
      -- Negate with saturate so the most negative value doesn't overflow.
      y_tmp <= to_signed(16#0000000#, 25);
    ELSIF isNegativeReg(25) = '1' THEN 
      -- Negate with saturate so the most negative value doesn't overflow.
      cast := resize(zReg(25), 26);
      cast_0 :=  - (cast);
      IF (cast_0(25) = '0') AND (cast_0(24) /= '0') THEN 
        y_tmp <= "0111111111111111111111111";
      ELSIF (cast_0(25) = '1') AND (cast_0(24) /= '1') THEN 
        y_tmp <= "1000000000000000000000000";
      ELSE 
        y_tmp <= cast_0(24 DOWNTO 0);
      END IF;
    END IF;
    t_tmp <= tReg(25);
    isDenZeroOut <= isDenZeroReg(25);
    validOut <= validReg(25);
  END PROCESS embreciprocals_c21_sj6UbcgrIwOfHv5tI9jPSMG_normalizedCORDICDivi_output;


  y <= std_logic_vector(y_tmp);

  t <= std_logic_vector(t_tmp);

END rtl;

