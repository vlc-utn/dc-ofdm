-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/IEEE_8021513_TX_src_Hc_12S_B80.vhd
-- Created: 2024-10-06 13:51:04
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IEEE_8021513_TX_src_Hc_12S_B80
-- Source Path: HDLTx/full_tx/payload_full/reduced_ldpc/Hc_12S-B80
-- Hierarchy Level: 3
-- Model version: 4.149
-- 
-- LDPC Encoder
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IEEE_8021513_TX_src_full_tx_pac.ALL;

ENTITY IEEE_8021513_TX_src_Hc_12S_B80 IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic;
        in1_start                         :   IN    std_logic;
        in1_end                           :   IN    std_logic;
        in1_valid                         :   IN    std_logic;
        out0                              :   OUT   std_logic;
        out1_start                        :   OUT   std_logic;
        out1_end                          :   OUT   std_logic;
        out1_valid                        :   OUT   std_logic;
        out2                              :   OUT   std_logic
        );
END IEEE_8021513_TX_src_Hc_12S_B80;


ARCHITECTURE rtl OF IEEE_8021513_TX_src_Hc_12S_B80 IS

  -- Component Declarations
  COMPONENT IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic;  -- ufix1
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT IEEE_8021513_TX_src_Calculate_Alpha_block
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          data                            :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          reset                           :   IN    std_logic;  -- ufix1
          encEnable                       :   IN    std_logic;  -- ufix1
          alpha                           :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          alphaValid                      :   OUT   std_logic;  -- ufix1
          alphaAddr                       :   OUT   std_logic_vector(3 DOWNTO 0);  -- ufix4
          columnVal                       :   OUT   std_logic_vector(4 DOWNTO 0);  -- ufix5
          parity1                         :   OUT   std_logic_vector(13 DOWNTO 0)  -- ufix1 [14]
          );
  END COMPONENT;

  COMPONENT IEEE_8021513_TX_src_Calculate_Parity_block
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          reset                           :   IN    std_logic;  -- ufix1
          alpha                           :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          alphaValid                      :   IN    std_logic;  -- ufix1
          alphaAddr                       :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          parity1                         :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          parityOut                       :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          parityValid                     :   OUT   std_logic;  -- ufix1
          parityAddr                      :   OUT   std_logic_vector(3 DOWNTO 0)  -- ufix4
          );
  END COMPONENT;

  COMPONENT IEEE_8021513_TX_src_Final_Output_block
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          reset                           :   IN    std_logic;  -- ufix1
          inputData                       :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          inputValid                      :   IN    std_logic;  -- ufix1
          parity                          :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          parityAddr                      :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          parityValid                     :   IN    std_logic;  -- ufix1
          dataOut                         :   OUT   std_logic;
          startOut                        :   OUT   std_logic;  -- ufix1
          endOut                          :   OUT   std_logic;  -- ufix1
          validOut                        :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    USE ENTITY work.IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block(rtl);

  FOR ALL : IEEE_8021513_TX_src_Calculate_Alpha_block
    USE ENTITY work.IEEE_8021513_TX_src_Calculate_Alpha_block(rtl);

  FOR ALL : IEEE_8021513_TX_src_Calculate_Parity_block
    USE ENTITY work.IEEE_8021513_TX_src_Calculate_Parity_block(rtl);

  FOR ALL : IEEE_8021513_TX_src_Final_Output_block
    USE ENTITY work.IEEE_8021513_TX_src_Final_Output_block(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL dataIn                           : std_logic;
  SIGNAL sofVld                           : std_logic;
  SIGNAL const1                           : std_logic;  -- ufix1
  SIGNAL const1Reg                        : std_logic;  -- ufix1
  SIGNAL const_2                          : std_logic;  -- ufix1
  SIGNAL sofVldNeg                        : std_logic;  -- ufix1
  SIGNAL eofVld                           : std_logic;
  SIGNAL constReg                         : std_logic;  -- ufix1
  SIGNAL frame_switch_delay               : std_logic;  -- ufix1
  SIGNAL fValidTmp                        : std_logic;  -- ufix1
  SIGNAL fValidReg                        : std_logic;  -- ufix1
  SIGNAL fValid                           : std_logic;  -- ufix1
  SIGNAL endTrigger                       : std_logic;  -- ufix1
  SIGNAL endTrigger2                      : std_logic;  -- ufix1
  SIGNAL end_trigger_reg                  : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL endTriggerReg                    : std_logic;  -- ufix1
  SIGNAL vFrame                           : std_logic;  -- ufix1
  SIGNAL countVal                         : unsigned(19 DOWNTO 0);  -- ufix20
  SIGNAL maxCount                         : unsigned(19 DOWNTO 0);  -- ufix20
  SIGNAL rel_count                        : std_logic;  -- ufix1
  SIGNAL invalid_length_switch_delay      : std_logic;  -- ufix1
  SIGNAL invalidLength                    : std_logic;  -- ufix1
  SIGNAL sofVldReg                        : std_logic;  -- ufix1
  SIGNAL validO                           : std_logic;  -- ufix1
  SIGNAL validout_reg                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL validOReg                        : std_logic;
  SIGNAL rFrameReg                        : std_logic;  -- ufix1
  SIGNAL validOut_1                       : std_logic;
  SIGNAL rdValid                          : std_logic;  -- ufix1
  SIGNAL rdValidReg                       : std_logic;  -- ufix1
  SIGNAL startO                           : std_logic;  -- ufix1
  SIGNAL startout_reg                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL startOReg                        : std_logic;
  SIGNAL extReset                         : std_logic;  -- ufix1
  SIGNAL nFrame                           : std_logic;  -- ufix1
  SIGNAL resetTmp                         : std_logic;  -- ufix1
  SIGNAL encEnb                           : std_logic;  -- ufix1
  SIGNAL alpha_switch_delay               : std_logic;  -- ufix1
  SIGNAL encEnbReg                        : std_logic;  -- ufix1
  SIGNAL rdAddrTmp                        : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL wrEnbReg                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL wrAddrReg                        : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL wrDataReg                        : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL colVal                           : std_logic_vector(4 DOWNTO 0);  -- ufix5
  SIGNAL colVal_unsigned                  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inRead                           : std_logic;  -- ufix1
  SIGNAL rdAddr                           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL wrEnb                            : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL wrAddr                           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL wrData                           : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL dataRAM                          : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL alpha                            : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL alphaValid                       : std_logic;  -- ufix1
  SIGNAL alphaAddr                        : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL parity1                          : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL parity                           : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL parityValid                      : std_logic;  -- ufix1
  SIGNAL parityAddr                       : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL parityAddr_unsigned              : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL isNumRows                        : std_logic;  -- ufix1
  SIGNAL startTmp                         : std_logic;  -- ufix1
  SIGNAL startRead                        : std_logic;  -- ufix1
  SIGNAL startReadReg                     : std_logic;  -- ufix1
  SIGNAL startReadNeg                     : std_logic;  -- ufix1
  SIGNAL inputController_wrData           : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL inputController_wrAddr           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_wrEnb            : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL inputController_frameValid       : std_logic;
  SIGNAL inputController_encEnb           : std_logic;
  SIGNAL inputController_endReg           : std_logic;
  SIGNAL inputController_validReg         : std_logic;
  SIGNAL inputController_dataReg          : std_logic;  -- ufix1
  SIGNAL inputController_idxCount         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL inputController_wrCount          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_rdAddr           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_inRead           : std_logic;
  SIGNAL inputController_rdValid          : std_logic;
  SIGNAL inputController_jdxCount         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL inputController_rdCount          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_wrData_next      : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL inputController_wrAddr_next      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_wrEnb_next       : std_logic_vector(13 DOWNTO 0);  -- boolean [14]
  SIGNAL inputController_frameValid_next  : std_logic;
  SIGNAL inputController_encEnb_next      : std_logic;
  SIGNAL inputController_endReg_next      : std_logic;
  SIGNAL inputController_validReg_next    : std_logic;
  SIGNAL inputController_dataReg_next     : std_logic;  -- ufix1
  SIGNAL inputController_idxCount_next    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL inputController_wrCount_next     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_rdAddr_next      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL inputController_inRead_next      : std_logic;
  SIGNAL inputController_rdValid_next     : std_logic;
  SIGNAL inputController_jdxCount_next    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL inputController_rdCount_next     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL parReset                         : std_logic;  -- ufix1
  SIGNAL dataO                            : std_logic;
  SIGNAL endO                             : std_logic;  -- ufix1
  SIGNAL endout_reg                       : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL endOReg                          : std_logic;
  SIGNAL endOut_1                         : std_logic;
  SIGNAL endOutVld                        : std_logic;  -- ufix1
  SIGNAL endOutVldTmp                     : std_logic;  -- ufix1
  SIGNAL endOutVldReg                     : std_logic;  -- ufix1
  SIGNAL invFrameTmp                      : std_logic;  -- ufix1
  SIGNAL nFrameEnb                        : std_logic;  -- ufix1
  SIGNAL nextFrame_switch_delay           : std_logic;  -- ufix1
  SIGNAL nFrameTmp                        : std_logic;  -- ufix1
  SIGNAL resetFrame                       : std_logic;  -- ufix1
  SIGNAL dataout_reg                      : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL dataOReg                         : std_logic;
  SIGNAL zData                            : std_logic;
  SIGNAL dataOut_1                        : std_logic;
  SIGNAL startOut_1                       : std_logic;

BEGIN
  u_Input_RAM : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(13),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(13),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(13)  -- ufix1
              );

  u_Input_RAM_1 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(12),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(12),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(12)  -- ufix1
              );

  u_Input_RAM_2 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(11),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(11),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(11)  -- ufix1
              );

  u_Input_RAM_3 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(10),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(10),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(10)  -- ufix1
              );

  u_Input_RAM_4 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(9),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(9),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(9)  -- ufix1
              );

  u_Input_RAM_5 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(8),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(8),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(8)  -- ufix1
              );

  u_Input_RAM_6 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(7),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(7),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(7)  -- ufix1
              );

  u_Input_RAM_7 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(6),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(6),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(6)  -- ufix1
              );

  u_Input_RAM_8 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(5),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(5),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(5)  -- ufix1
              );

  u_Input_RAM_9 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(4),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(4),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(4)  -- ufix1
              );

  u_Input_RAM_10 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(3),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(3),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(3)  -- ufix1
              );

  u_Input_RAM_11 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(2),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(2),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(2)  -- ufix1
              );

  u_Input_RAM_12 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(1),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(1),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(1)  -- ufix1
              );

  u_Input_RAM_13 : IEEE_8021513_TX_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrDataReg(0),  -- ufix1
              wr_addr => std_logic_vector(wrAddrReg),
              wr_en => wrEnbReg(0),  -- ufix1
              rd_addr => std_logic_vector(rdAddrTmp),
              dout => dataRAM(0)  -- ufix1
              );

  u_Calculate_Alpha : IEEE_8021513_TX_src_Calculate_Alpha_block
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              data => dataRAM,  -- ufix1 [14]
              reset => extReset,  -- ufix1
              encEnable => encEnbReg,  -- ufix1
              alpha => alpha,  -- ufix1 [14]
              alphaValid => alphaValid,  -- ufix1
              alphaAddr => alphaAddr,  -- ufix4
              columnVal => colVal,  -- ufix5
              parity1 => parity1  -- ufix1 [14]
              );

  u_Calculate_Parity : IEEE_8021513_TX_src_Calculate_Parity_block
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              reset => extReset,  -- ufix1
              alpha => alpha,  -- ufix1 [14]
              alphaValid => alphaValid,  -- ufix1
              alphaAddr => alphaAddr,  -- ufix4
              parity1 => parity1,  -- ufix1 [14]
              parityOut => parity,  -- ufix1 [14]
              parityValid => parityValid,  -- ufix1
              parityAddr => parityAddr  -- ufix4
              );

  u_Final_output : IEEE_8021513_TX_src_Final_Output_block
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => enb,
              reset => extReset,  -- ufix1
              inputData => dataRAM,  -- ufix1 [14]
              inputValid => rdValidReg,  -- ufix1
              parity => parity,  -- ufix1 [14]
              parityAddr => parityAddr,  -- ufix4
              parityValid => parityValid,  -- ufix1
              dataOut => dataO,
              startOut => startO,  -- ufix1
              endOut => endO,  -- ufix1
              validOut => validO  -- ufix1
              );

  dataIn <= in0;

  sofVld <= in1_valid AND in1_start;

  const1 <= '1';

  c_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        const1Reg <= '0';
      ELSIF enb = '1' AND in1_valid = '1' THEN
        const1Reg <= const1;
      END IF;
    END IF;
  END PROCESS c_process;


  const_2 <= '0';

  sofVldNeg <=  NOT sofVld;

  eofVld <= in1_valid AND in1_end;

  c_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        constReg <= '0';
      ELSIF enb = '1' AND in1_valid = '1' THEN
        constReg <= const_2;
      END IF;
    END IF;
  END PROCESS c_1_process;


  frame_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        frame_switch_delay <= '1';
      ELSIF enb = '1' THEN
        IF sofVld = '1' THEN
          frame_switch_delay <= '1';
        ELSIF eofVld = '1' THEN
          frame_switch_delay <= constReg;
        END IF;
      END IF;
    END IF;
  END PROCESS frame_process;

  
  fValidTmp <= '1' WHEN sofVld = '1' ELSE
      frame_switch_delay;

  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        fValidReg <= '0';
      ELSIF enb = '1' THEN
        fValidReg <= fValidTmp;
      END IF;
    END IF;
  END PROCESS c_2_process;


  fValid <= fValidReg OR eofVld;

  endTrigger <= eofVld AND fValid;

  endTrigger2 <= endTrigger AND sofVldNeg;

  end_trigger_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        end_trigger_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        end_trigger_reg(0) <= endTrigger2;
        end_trigger_reg(1) <= end_trigger_reg(0);
      END IF;
    END IF;
  END PROCESS end_trigger_process;

  endTriggerReg <= end_trigger_reg(1);

  vFrame <= in1_valid AND fValid;

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 524287
  -- Counter for input data length
  Counting_Data_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        countVal <= to_unsigned(16#00001#, 20);
      ELSIF enb = '1' THEN
        IF sofVld = '1' THEN 
          countVal <= to_unsigned(16#00001#, 20);
        ELSIF vFrame = '1' THEN 
          IF countVal >= to_unsigned(16#7FFFF#, 20) THEN 
            countVal <= to_unsigned(16#00001#, 20);
          ELSE 
            countVal <= countVal + to_unsigned(16#00001#, 20);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS Counting_Data_process;


  maxCount <= to_unsigned(16#000A7#, 20);

  -- Comparison of counter to max count
  
  rel_count <= '1' WHEN countVal /= maxCount ELSE
      '0';

  invalid_length_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        invalid_length_switch_delay <= '0';
      ELSIF enb = '1' THEN
        IF endTriggerReg = '1' THEN
          invalid_length_switch_delay <= '0';
        ELSIF endTrigger2 = '1' THEN
          invalid_length_switch_delay <= rel_count;
        END IF;
      END IF;
    END IF;
  END PROCESS invalid_length_process;

  
  invalidLength <= '0' WHEN endTriggerReg = '1' ELSE
      invalid_length_switch_delay;

  c_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        sofVldReg <= '0';
      ELSIF enb = '1' THEN
        sofVldReg <= sofVld;
      END IF;
    END IF;
  END PROCESS c_3_process;


  validout_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validout_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        validout_reg(0) <= validO;
        validout_reg(1) <= validout_reg(0);
      END IF;
    END IF;
  END PROCESS validout_process;

  validOReg <= validout_reg(1);

  
  validOut_1 <= validOReg WHEN rFrameReg = '0' ELSE
      const_2;

  c_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdValidReg <= '0';
      ELSIF enb = '1' THEN
        rdValidReg <= rdValid;
      END IF;
    END IF;
  END PROCESS c_4_process;


  startout_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        startout_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        startout_reg(0) <= startO;
        startout_reg(1) <= startout_reg(0);
      END IF;
    END IF;
  END PROCESS startout_process;

  startOReg <= startout_reg(1);

  resetTmp <= extReset OR nFrame;

  c_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_switch_delay <= '0';
      ELSIF enb = '1' THEN
        IF resetTmp = '1' THEN
          alpha_switch_delay <= '0';
        ELSIF const1Reg = '1' THEN
          alpha_switch_delay <= encEnb;
        END IF;
      END IF;
    END IF;
  END PROCESS c_5_process;

  
  encEnbReg <= '0' WHEN resetTmp = '1' ELSE
      alpha_switch_delay;

  colVal_unsigned <= unsigned(colVal);

  
  rdAddrTmp <= colVal_unsigned WHEN inRead = '0' ELSE
      rdAddr;

  c_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrEnbReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        wrEnbReg <= wrEnb;
      END IF;
    END IF;
  END PROCESS c_6_process;


  c_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrAddrReg <= to_unsigned(16#00#, 5);
      ELSIF enb = '1' THEN
        wrAddrReg <= wrAddr;
      END IF;
    END IF;
  END PROCESS c_7_process;


  c_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrDataReg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        wrDataReg <= wrData;
      END IF;
    END IF;
  END PROCESS c_8_process;



  parityAddr_unsigned <= unsigned(parityAddr);

  
  isNumRows <= '1' WHEN parityAddr_unsigned = to_unsigned(16#C#, 4) ELSE
      '0';

  startTmp <= isNumRows AND parityValid;

  c_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        startReadReg <= '0';
      ELSIF enb = '1' THEN
        startReadReg <= startRead;
      END IF;
    END IF;
  END PROCESS c_9_process;


  startReadNeg <=  NOT startReadReg;

  startRead <= startReadNeg AND startTmp;

  inputController_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        inputController_wrAddr <= to_unsigned(16#00#, 5);
        inputController_wrData <= (OTHERS => '0');
        inputController_wrEnb <= (OTHERS => '0');
        inputController_frameValid <= '0';
        inputController_encEnb <= '0';
        inputController_endReg <= '0';
        inputController_validReg <= '0';
        inputController_dataReg <= '0';
        inputController_idxCount <= to_unsigned(16#0#, 4);
        inputController_wrCount <= to_unsigned(16#01#, 5);
        inputController_rdAddr <= to_unsigned(16#00#, 5);
        inputController_inRead <= '0';
        inputController_rdValid <= '0';
        inputController_jdxCount <= to_unsigned(16#0#, 4);
        inputController_rdCount <= to_unsigned(16#01#, 5);
      ELSIF enb = '1' THEN
        inputController_wrAddr <= inputController_wrAddr_next;
        inputController_wrData <= inputController_wrData_next;
        inputController_wrEnb <= inputController_wrEnb_next;
        inputController_frameValid <= inputController_frameValid_next;
        inputController_encEnb <= inputController_encEnb_next;
        inputController_endReg <= inputController_endReg_next;
        inputController_validReg <= inputController_validReg_next;
        inputController_dataReg <= inputController_dataReg_next;
        inputController_idxCount <= inputController_idxCount_next;
        inputController_wrCount <= inputController_wrCount_next;
        inputController_rdAddr <= inputController_rdAddr_next;
        inputController_inRead <= inputController_inRead_next;
        inputController_rdValid <= inputController_rdValid_next;
        inputController_jdxCount <= inputController_jdxCount_next;
        inputController_rdCount <= inputController_rdCount_next;
      END IF;
    END IF;
  END PROCESS inputController_process;

  inputController_output : PROCESS (dataIn, in1_end, in1_start, in1_valid, inputController_dataReg,
       inputController_encEnb, inputController_endReg,
       inputController_frameValid, inputController_idxCount,
       inputController_inRead, inputController_jdxCount, inputController_rdAddr,
       inputController_rdCount, inputController_rdValid,
       inputController_validReg, inputController_wrAddr,
       inputController_wrCount, inputController_wrData, inputController_wrEnb,
       startOReg, startRead)
    VARIABLE reset : std_logic;
    VARIABLE inRead_temp : std_logic;
    VARIABLE cast : vector_of_unsigned4(0 TO 13);
  BEGIN
    inRead_temp := inputController_inRead;
    inputController_wrAddr_next <= inputController_wrAddr;
    inputController_wrData_next <= inputController_wrData;
    inputController_wrEnb_next <= inputController_wrEnb;
    inputController_frameValid_next <= inputController_frameValid;
    inputController_encEnb_next <= inputController_encEnb;
    inputController_idxCount_next <= inputController_idxCount;
    inputController_wrCount_next <= inputController_wrCount;
    inputController_rdAddr_next <= inputController_rdAddr;
    inputController_rdValid_next <= inputController_rdValid;
    inputController_jdxCount_next <= inputController_jdxCount;
    inputController_rdCount_next <= inputController_rdCount;
    reset := hdlcoder_to_stdlogic((in1_start /= '0') AND (in1_valid /= '0'));
    IF reset = '1' THEN 
      extReset <= '1';
      inputController_wrData_next <= (OTHERS => '0');
      inputController_wrEnb_next <= (OTHERS => '0');
      inputController_wrAddr_next <= to_unsigned(16#00#, 5);
      inputController_idxCount_next <= to_unsigned(16#0#, 4);
      inputController_wrCount_next <= to_unsigned(16#01#, 5);
      inputController_frameValid_next <= '1';
    ELSE 
      extReset <= '0';
      IF (inputController_frameValid AND inputController_validReg) = '1' THEN 

        FOR idx IN 0 TO 13 LOOP
          cast(idx) := unsigned(to_signed(idx, 32)(3 DOWNTO 0));
          IF inputController_idxCount = cast(idx) THEN 
            inputController_wrEnb_next(idx) <= '1';
            inputController_wrData_next(idx) <= inputController_dataReg;
          ELSE 
            inputController_wrEnb_next(idx) <= '0';
            inputController_wrData_next(idx) <= '0';
          END IF;
        END LOOP;

        inputController_wrAddr_next <= inputController_wrCount;
        IF inputController_idxCount = to_unsigned(16#D#, 4) THEN 
          inputController_idxCount_next <= to_unsigned(16#0#, 4);
          inputController_wrCount_next <= inputController_wrCount + to_unsigned(16#01#, 5);
        ELSE 
          inputController_idxCount_next <= inputController_idxCount + to_unsigned(16#1#, 4);
        END IF;
      ELSE 
        inputController_wrData_next <= (OTHERS => '0');
        inputController_wrEnb_next <= (OTHERS => '0');
      END IF;
      IF (inputController_endReg AND inputController_validReg) = '1' THEN 
        inputController_frameValid_next <= '0';
      END IF;
    END IF;
    IF reset = '1' OR (startOReg /= '0') THEN 
      inputController_encEnb_next <= '0';
    ELSIF (inputController_endReg AND inputController_validReg) = '1' THEN 
      inputController_encEnb_next <= '1';
    END IF;
    inputController_dataReg_next <= dataIn;
    inputController_endReg_next <= in1_end;
    inputController_validReg_next <= in1_valid;
    IF reset = '1' THEN 
      inRead_temp := '0';
      inputController_rdAddr_next <= to_unsigned(16#01#, 5);
      inputController_rdValid_next <= '0';
      inputController_rdCount_next <= to_unsigned(16#01#, 5);
      inputController_jdxCount_next <= to_unsigned(16#0#, 4);
    ELSE 
      IF startRead /= '0' THEN 
        inRead_temp := '1';
      END IF;
      IF inRead_temp = '1' THEN 
        IF inputController_rdCount = to_unsigned(16#0D#, 5) THEN 
          inputController_rdAddr_next <= inputController_rdCount;
          inputController_rdValid_next <= '0';
          inRead_temp := '0';
        ELSE 
          inputController_rdValid_next <= '1';
          inputController_rdAddr_next <= inputController_rdCount;
        END IF;
        IF inputController_jdxCount = to_unsigned(16#D#, 4) THEN 
          inputController_jdxCount_next <= to_unsigned(16#0#, 4);
          inputController_rdCount_next <= inputController_rdCount + to_unsigned(16#01#, 5);
        ELSE 
          inputController_jdxCount_next <= inputController_jdxCount + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
    wrAddr <= inputController_wrAddr;
    wrData <= inputController_wrData;
    wrEnb <= inputController_wrEnb;
    inRead <= inputController_inRead;
    rdAddr <= inputController_rdAddr;
    encEnb <= inputController_encEnb;
    rdValid <= inputController_rdValid;
    parReset <= inputController_frameValid;
    inputController_inRead_next <= inRead_temp;
  END PROCESS inputController_output;


  endout_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        endout_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        endout_reg(0) <= endO;
        endout_reg(1) <= endout_reg(0);
      END IF;
    END IF;
  END PROCESS endout_process;

  endOReg <= endout_reg(1);

  
  endOut_1 <= endOReg WHEN rFrameReg = '0' ELSE
      const_2;

  endOutVld <= endOut_1 AND validOut_1;

  endOutVldTmp <= endOutVld AND sofVldNeg;

  c_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        endOutVldReg <= '0';
      ELSIF enb = '1' THEN
        endOutVldReg <= endOutVldTmp;
      END IF;
    END IF;
  END PROCESS c_10_process;


  invFrameTmp <= endOutVldReg OR invalidLength;

  nFrameEnb <= invFrameTmp AND sofVldNeg;

  nextFrame_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        nextFrame_switch_delay <= '1';
      ELSIF enb = '1' THEN
        IF nFrameEnb = '1' THEN
          nextFrame_switch_delay <= '1';
        ELSIF sofVld = '1' THEN
          nextFrame_switch_delay <= constReg;
        END IF;
      END IF;
    END IF;
  END PROCESS nextFrame_process;

  
  nFrameTmp <= '1' WHEN nFrameEnb = '1' ELSE
      nextFrame_switch_delay;

  nFrame <= nFrameTmp OR invFrameTmp;

  resetFrame <= nFrame OR fValid;

  rFrameReg <= resetFrame OR sofVldReg;

  dataout_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dataout_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        dataout_reg(0) <= dataO;
        dataout_reg(1) <= dataout_reg(0);
      END IF;
    END IF;
  END PROCESS dataout_process;

  dataOReg <= dataout_reg(1);

  zData <= '0';

  
  dataOut_1 <= dataOReg WHEN rFrameReg = '0' ELSE
      zData;

  
  startOut_1 <= startOReg WHEN rFrameReg = '0' ELSE
      const_2;

  out1_start <= startOut_1;

  out1_end <= endOut_1;

  out1_valid <= validOut_1;

  out0 <= dataOut_1;

  out2 <= nFrame;

END rtl;

