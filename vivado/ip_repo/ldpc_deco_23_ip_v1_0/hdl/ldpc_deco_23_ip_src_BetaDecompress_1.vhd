-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/test/ldpc_deco_23_ip_src_BetaDecompress_1.vhd
-- Created: 2024-10-03 14:23:14
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ldpc_deco_23_ip_src_BetaDecompress_1
-- Source Path: test/ldpc_deco_23/LDPC Decoder/DecoderCore/FunctionalUnit/BetaDecompress_1
-- Hierarchy Level: 4
-- Model version: 1.55
-- 
-- Beta_Decompress_Unit_1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ldpc_deco_23_ip_src_ldpc_deco_23_pac.ALL;

ENTITY ldpc_deco_23_ip_src_BetaDecompress_1 IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        betacomp1                         :   IN    vector_of_std_logic_vector21(0 TO 47);  -- ufix21 [48]
        betacomp2                         :   IN    vector_of_std_logic_vector6(0 TO 47);  -- ufix6 [48]
        betacomp3                         :   IN    vector_of_std_logic_vector6(0 TO 47);  -- ufix6 [48]
        validin                           :   IN    std_logic;  -- ufix1
        count                             :   IN    std_logic_vector(4 DOWNTO 0);  -- ufix5
        reset                             :   IN    std_logic;  -- ufix1
        beta                              :   OUT   vector_of_std_logic_vector4(0 TO 47);  -- sfix4 [48]
        valid                             :   OUT   std_logic  -- ufix1
        );
END ldpc_deco_23_ip_src_BetaDecompress_1;


ARCHITECTURE rtl OF ldpc_deco_23_ip_src_BetaDecompress_1 IS

  -- Component Declarations
  COMPONENT ldpc_deco_23_ip_src_BetaCalculation_1
    PORT( signs                           :   IN    std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
          prodsign                        :   IN    std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
          minidx                          :   IN    vector_of_std_logic_vector5(0 TO 47);  -- ufix5 [48]
          min1                            :   IN    vector_of_std_logic_vector4(0 TO 47);  -- ufix4 [48]
          min2                            :   IN    vector_of_std_logic_vector4(0 TO 47);  -- ufix4 [48]
          count                           :   IN    std_logic_vector(4 DOWNTO 0);  -- ufix5
          beta                            :   OUT   vector_of_std_logic_vector4(0 TO 47)  -- sfix4 [48]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : ldpc_deco_23_ip_src_BetaCalculation_1
    USE ENTITY work.ldpc_deco_23_ip_src_BetaCalculation_1(rtl);

  -- Signals
  SIGNAL count_unsigned                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL const1                           : std_logic;  -- ufix1
  SIGNAL AddComp_add_cast                 : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL countIdx                         : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL resetCount                       : std_logic;  -- ufix1
  SIGNAL alpha_switch_delay               : std_logic;  -- ufix1
  SIGNAL enbCount                         : std_logic;  -- ufix1
  SIGNAL enbCountReg                      : std_logic;  -- ufix1
  SIGNAL countVal                         : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL countValReg                      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL countMax                         : std_logic;  -- ufix1
  SIGNAL betacomp1_unsigned               : vector_of_unsigned21(0 TO 47);  -- ufix21 [48]
  SIGNAL sign_1                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_2                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_3                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_4                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_5                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_6                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_7                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_8                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_9                           : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_10                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_11                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_12                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_13                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_14                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_15                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_16                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_17                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_18                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_19                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_20                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL sign_21                          : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL signs                            : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL betacomp2_unsigned               : vector_of_unsigned6(0 TO 47);  -- ufix6 [48]
  SIGNAL betacomp3_unsigned               : vector_of_unsigned6(0 TO 47);  -- ufix6 [48]
  SIGNAL prodsign                         : std_logic_vector(47 DOWNTO 0);  -- ufix1 [48]
  SIGNAL min_index                        : vector_of_unsigned5(0 TO 47);  -- ufix5 [48]
  SIGNAL min_index_1                      : vector_of_std_logic_vector5(0 TO 47);  -- ufix5 [48]
  SIGNAL min1_dtc                         : vector_of_unsigned3(0 TO 47);  -- ufix3 [48]
  SIGNAL sMin1                            : vector_of_unsigned4(0 TO 47);  -- ufix4 [48]
  SIGNAL sMin1_1                          : vector_of_std_logic_vector4(0 TO 47);  -- ufix4 [48]
  SIGNAL min2_dtc                         : vector_of_unsigned3(0 TO 47);  -- ufix3 [48]
  SIGNAL sMin2                            : vector_of_unsigned4(0 TO 47);  -- ufix4 [48]
  SIGNAL sMin2_1                          : vector_of_std_logic_vector4(0 TO 47);  -- ufix4 [48]
  SIGNAL betaReg                          : vector_of_std_logic_vector4(0 TO 47);  -- ufix4 [48]
  SIGNAL betaReg_signed                   : vector_of_signed4(0 TO 47);  -- sfix4 [48]
  SIGNAL beta_tmp                         : vector_of_signed4(0 TO 47);  -- sfix4 [48]

BEGIN
  u_BetaCalUnit : ldpc_deco_23_ip_src_BetaCalculation_1
    PORT MAP( signs => signs,  -- ufix1 [48]
              prodsign => prodsign,  -- ufix1 [48]
              minidx => min_index_1,  -- ufix5 [48]
              min1 => sMin1_1,  -- ufix4 [48]
              min2 => sMin2_1,  -- ufix4 [48]
              count => std_logic_vector(countVal),  -- ufix5
              beta => betaReg  -- sfix4 [48]
              );

  count_unsigned <= unsigned(count);

  const1 <= '1';

  AddComp_add_cast <= '0' & '0' & '0' & '0' & const1;
  countIdx <= count_unsigned + AddComp_add_cast;

  c_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_switch_delay <= '0';
      ELSIF enb = '1' THEN
        IF resetCount = '1' THEN
          alpha_switch_delay <= '0';
        ELSIF validin = '1' THEN
          alpha_switch_delay <= validin;
        END IF;
      END IF;
    END IF;
  END PROCESS c_process;

  
  enbCount <= '0' WHEN resetCount = '1' ELSE
      alpha_switch_delay;

  enbCountReg <= validin OR enbCount;

  c_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        countValReg <= to_unsigned(16#00#, 5);
      ELSIF enb = '1' THEN
        countValReg <= countVal;
      END IF;
    END IF;
  END PROCESS c_1_process;


  
  countMax <= '1' WHEN countIdx = countValReg ELSE
      '0';

  resetCount <= countMax OR reset;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 21
  counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        countVal <= to_unsigned(16#00#, 5);
      ELSIF enb = '1' THEN
        IF resetCount = '1' THEN 
          countVal <= to_unsigned(16#00#, 5);
        ELSIF enbCountReg = '1' THEN 
          IF countVal >= to_unsigned(16#15#, 5) THEN 
            countVal <= to_unsigned(16#00#, 5);
          ELSE 
            countVal <= countVal + to_unsigned(16#01#, 5);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS counter_process;


  outputgen7: FOR k32 IN 0 TO 47 GENERATE
    betacomp1_unsigned(k32) <= unsigned(betacomp1(k32));
  END GENERATE;


  sign_1_gen: FOR k IN 0 TO 47 GENERATE
    sign_1(k) <= betacomp1_unsigned(k)(20);
  END GENERATE sign_1_gen;



  sign_2_gen: FOR k1 IN 0 TO 47 GENERATE
    sign_2(k1) <= betacomp1_unsigned(k1)(19);
  END GENERATE sign_2_gen;



  sign_3_gen: FOR k2 IN 0 TO 47 GENERATE
    sign_3(k2) <= betacomp1_unsigned(k2)(18);
  END GENERATE sign_3_gen;



  sign_4_gen: FOR k3 IN 0 TO 47 GENERATE
    sign_4(k3) <= betacomp1_unsigned(k3)(17);
  END GENERATE sign_4_gen;



  sign_5_gen: FOR k4 IN 0 TO 47 GENERATE
    sign_5(k4) <= betacomp1_unsigned(k4)(16);
  END GENERATE sign_5_gen;



  sign_6_gen: FOR k5 IN 0 TO 47 GENERATE
    sign_6(k5) <= betacomp1_unsigned(k5)(15);
  END GENERATE sign_6_gen;



  sign_7_gen: FOR k6 IN 0 TO 47 GENERATE
    sign_7(k6) <= betacomp1_unsigned(k6)(14);
  END GENERATE sign_7_gen;



  sign_8_gen: FOR k7 IN 0 TO 47 GENERATE
    sign_8(k7) <= betacomp1_unsigned(k7)(13);
  END GENERATE sign_8_gen;



  sign_9_gen: FOR k8 IN 0 TO 47 GENERATE
    sign_9(k8) <= betacomp1_unsigned(k8)(12);
  END GENERATE sign_9_gen;



  sign_10_gen: FOR k9 IN 0 TO 47 GENERATE
    sign_10(k9) <= betacomp1_unsigned(k9)(11);
  END GENERATE sign_10_gen;



  sign_11_gen: FOR k10 IN 0 TO 47 GENERATE
    sign_11(k10) <= betacomp1_unsigned(k10)(10);
  END GENERATE sign_11_gen;



  sign_12_gen: FOR k11 IN 0 TO 47 GENERATE
    sign_12(k11) <= betacomp1_unsigned(k11)(9);
  END GENERATE sign_12_gen;



  sign_13_gen: FOR k12 IN 0 TO 47 GENERATE
    sign_13(k12) <= betacomp1_unsigned(k12)(8);
  END GENERATE sign_13_gen;



  sign_14_gen: FOR k13 IN 0 TO 47 GENERATE
    sign_14(k13) <= betacomp1_unsigned(k13)(7);
  END GENERATE sign_14_gen;



  sign_15_gen: FOR k14 IN 0 TO 47 GENERATE
    sign_15(k14) <= betacomp1_unsigned(k14)(6);
  END GENERATE sign_15_gen;



  sign_16_gen: FOR k15 IN 0 TO 47 GENERATE
    sign_16(k15) <= betacomp1_unsigned(k15)(5);
  END GENERATE sign_16_gen;



  sign_17_gen: FOR k16 IN 0 TO 47 GENERATE
    sign_17(k16) <= betacomp1_unsigned(k16)(4);
  END GENERATE sign_17_gen;



  sign_18_gen: FOR k17 IN 0 TO 47 GENERATE
    sign_18(k17) <= betacomp1_unsigned(k17)(3);
  END GENERATE sign_18_gen;



  sign_19_gen: FOR k18 IN 0 TO 47 GENERATE
    sign_19(k18) <= betacomp1_unsigned(k18)(2);
  END GENERATE sign_19_gen;



  sign_20_gen: FOR k19 IN 0 TO 47 GENERATE
    sign_20(k19) <= betacomp1_unsigned(k19)(1);
  END GENERATE sign_20_gen;



  sign_21_gen: FOR k20 IN 0 TO 47 GENERATE
    sign_21(k20) <= betacomp1_unsigned(k20)(0);
  END GENERATE sign_21_gen;


  multiportswitch_output : PROCESS (countVal, sign_1, sign_10, sign_11, sign_12, sign_13, sign_14, sign_15,
       sign_16, sign_17, sign_18, sign_19, sign_2, sign_20, sign_21, sign_3,
       sign_4, sign_5, sign_6, sign_7, sign_8, sign_9)
  BEGIN
    IF countVal = to_unsigned(16#00#, 5) THEN 
      signs <= sign_1;
    ELSIF countVal = to_unsigned(16#01#, 5) THEN 
      signs <= sign_2;
    ELSIF countVal = to_unsigned(16#02#, 5) THEN 
      signs <= sign_3;
    ELSIF countVal = to_unsigned(16#03#, 5) THEN 
      signs <= sign_4;
    ELSIF countVal = to_unsigned(16#04#, 5) THEN 
      signs <= sign_5;
    ELSIF countVal = to_unsigned(16#05#, 5) THEN 
      signs <= sign_6;
    ELSIF countVal = to_unsigned(16#06#, 5) THEN 
      signs <= sign_7;
    ELSIF countVal = to_unsigned(16#07#, 5) THEN 
      signs <= sign_8;
    ELSIF countVal = to_unsigned(16#08#, 5) THEN 
      signs <= sign_9;
    ELSIF countVal = to_unsigned(16#09#, 5) THEN 
      signs <= sign_10;
    ELSIF countVal = to_unsigned(16#0A#, 5) THEN 
      signs <= sign_11;
    ELSIF countVal = to_unsigned(16#0B#, 5) THEN 
      signs <= sign_12;
    ELSIF countVal = to_unsigned(16#0C#, 5) THEN 
      signs <= sign_13;
    ELSIF countVal = to_unsigned(16#0D#, 5) THEN 
      signs <= sign_14;
    ELSIF countVal = to_unsigned(16#0E#, 5) THEN 
      signs <= sign_15;
    ELSIF countVal = to_unsigned(16#0F#, 5) THEN 
      signs <= sign_16;
    ELSIF countVal = to_unsigned(16#10#, 5) THEN 
      signs <= sign_17;
    ELSIF countVal = to_unsigned(16#11#, 5) THEN 
      signs <= sign_18;
    ELSIF countVal = to_unsigned(16#12#, 5) THEN 
      signs <= sign_19;
    ELSIF countVal = to_unsigned(16#13#, 5) THEN 
      signs <= sign_20;
    ELSIF countVal = to_unsigned(16#14#, 5) THEN 
      signs <= sign_21;
    ELSE 
      signs <= sign_1;
    END IF;
  END PROCESS multiportswitch_output;


  outputgen6: FOR k31 IN 0 TO 47 GENERATE
    betacomp2_unsigned(k31) <= unsigned(betacomp2(k31));
  END GENERATE;

  outputgen5: FOR k30 IN 0 TO 47 GENERATE
    betacomp3_unsigned(k30) <= unsigned(betacomp3(k30));
  END GENERATE;


  prodsign_gen: FOR k21 IN 0 TO 47 GENERATE
    prodsign(k21) <= betacomp2_unsigned(k21)(5);
  END GENERATE prodsign_gen;



  min_index_gen: FOR k22 IN 0 TO 47 GENERATE
    min_index(k22) <= betacomp2_unsigned(k22)(4 DOWNTO 0);
  END GENERATE min_index_gen;


  outputgen4: FOR k29 IN 0 TO 47 GENERATE
    min_index_1(k29) <= std_logic_vector(min_index(k29));
  END GENERATE;


  min1_dtc_gen: FOR k23 IN 0 TO 47 GENERATE
    min1_dtc(k23) <= betacomp3_unsigned(k23)(5 DOWNTO 3);
  END GENERATE min1_dtc_gen;



  sMin1_gen: FOR ii IN 0 TO 47 GENERATE
    sMin1(ii) <= resize(min1_dtc(ii), 4);
  END GENERATE sMin1_gen;


  outputgen3: FOR k28 IN 0 TO 47 GENERATE
    sMin1_1(k28) <= std_logic_vector(sMin1(k28));
  END GENERATE;


  min2_dtc_gen: FOR k24 IN 0 TO 47 GENERATE
    min2_dtc(k24) <= betacomp3_unsigned(k24)(2 DOWNTO 0);
  END GENERATE min2_dtc_gen;



  sMin2_gen: FOR ii1 IN 0 TO 47 GENERATE
    sMin2(ii1) <= resize(min2_dtc(ii1), 4);
  END GENERATE sMin2_gen;


  outputgen2: FOR k27 IN 0 TO 47 GENERATE
    sMin2_1(k27) <= std_logic_vector(sMin2(k27));
  END GENERATE;

  outputgen1: FOR k26 IN 0 TO 47 GENERATE
    betaReg_signed(k26) <= signed(betaReg(k26));
  END GENERATE;

  beta_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        beta_tmp <= (OTHERS => to_signed(16#0#, 4));
      ELSIF enb = '1' THEN
        beta_tmp <= betaReg_signed;
      END IF;
    END IF;
  END PROCESS beta_1_process;


  outputgen: FOR k25 IN 0 TO 47 GENERATE
    beta(k25) <= std_logic_vector(beta_tmp(k25));
  END GENERATE;

  valid <= enbCount;

END rtl;

