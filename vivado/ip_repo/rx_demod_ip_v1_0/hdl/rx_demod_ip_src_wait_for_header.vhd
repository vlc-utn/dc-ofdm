-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRxDemodulator/rx_demod_ip_src_wait_for_header.vhd
-- Created: 2024-09-22 18:53:32
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: rx_demod_ip_src_wait_for_header
-- Source Path: HDLRxDemodulator/rx_demodulator_full/ofdm_separator/wait_for_header
-- Hierarchy Level: 2
-- Model version: 1.58
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY rx_demod_ip_src_wait_for_header IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_2_0                         :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_2_1                         :   IN    std_logic;
        data_in_re                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        data_in_im                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        header_ready                      :   IN    std_logic;
        valid_payload                     :   IN    std_logic;
        zero_payload                      :   IN    std_logic;
        one_payload                       :   IN    std_logic;
        ofdm_samples                      :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        data_out_re                       :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        data_out_im                       :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        valid_payload_out                 :   OUT   std_logic
        );
END rx_demod_ip_src_wait_for_header;


ARCHITECTURE rtl OF rx_demod_ip_src_wait_for_header IS

  -- Component Declarations
  COMPONENT rx_demod_ip_src_rising_edge_detector1_block1
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          enb_1_2_1                       :   IN    std_logic;
          In_rsvd                         :   IN    std_logic;
          Out_rsvd                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT rx_demod_ip_src_HDL_FIFO
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          In_re                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          In_im                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          Push                            :   IN    std_logic;
          Pop                             :   IN    std_logic;
          rst                             :   IN    std_logic;
          Out_re                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          Out_im                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          Empty                           :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT rx_demod_ip_src_rising_edge_detector_block3
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          In_rsvd                         :   IN    std_logic;
          Out_rsvd                        :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : rx_demod_ip_src_rising_edge_detector1_block1
    USE ENTITY work.rx_demod_ip_src_rising_edge_detector1_block1(rtl);

  FOR ALL : rx_demod_ip_src_HDL_FIFO
    USE ENTITY work.rx_demod_ip_src_HDL_FIFO(rtl);

  FOR ALL : rx_demod_ip_src_rising_edge_detector_block3
    USE ENTITY work.rx_demod_ip_src_rising_edge_detector_block3(rtl);

  -- Signals
  SIGNAL data_in_re_1                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL data_in_im_1                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL data_in_re_2                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL data_in_im_2                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay12_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay12_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL valid_payload_1                  : std_logic;
  SIGNAL Delay13_bypass_reg               : std_logic;  -- ufix1
  SIGNAL Delay13_out1                     : std_logic;
  SIGNAL rising_edge_detector1_out1       : std_logic;
  SIGNAL OR_out1                          : std_logic;
  SIGNAL header_ready_1                   : std_logic;
  SIGNAL rd_3_reg                         : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL header_ready_2                   : std_logic;
  SIGNAL one_payload_1                    : std_logic;
  SIGNAL one_payload_2                    : std_logic;
  SIGNAL count_step                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_reset                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count                            : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_1                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_2                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_3                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_4                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_5                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_6                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_7                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL HDL_Counter_bypass_reg           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL count_8                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL ofdm_samples_unsigned            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL hit_zero                         : std_logic;
  SIGNAL OR2_out1                         : std_logic;
  SIGNAL pop                              : std_logic;
  SIGNAL Unit_Delay_out1                  : std_logic;
  SIGNAL HDL_FIFO_out1_re                 : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL HDL_FIFO_out1_im                 : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL HDL_FIFO_out2                    : std_logic;
  SIGNAL rising_edge_detector_out1        : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;
  SIGNAL Delay14_out1                     : std_logic;
  SIGNAL NOT_out1                         : std_logic;
  SIGNAL AND_out1                         : std_logic;
  SIGNAL data_in_re_signed                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL data_in_im_signed                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL HDL_FIFO_out1_re_signed          : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL HDL_FIFO_out1_im_signed          : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch3_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch3_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14

BEGIN
  -- Store payload OFDM symbols until header parameters are known (cyclic prefix has to be known before demodulating 
  -- the OFDM symbol
  -- The RAM value should be large enough to wait for the header to be processed.
  -- Th e LDPC decoder of the header has a delay > 2500, so a value of 3000 is chosen for an extra margin.

  u_rising_edge_detector1 : rx_demod_ip_src_rising_edge_detector1_block1
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb_1_2_0 => enb_1_2_0,
              enb_1_2_1 => enb_1_2_1,
              In_rsvd => valid_payload,
              Out_rsvd => rising_edge_detector1_out1
              );

  u_HDL_FIFO : rx_demod_ip_src_HDL_FIFO
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb_1_2_0 => enb_1_2_0,
              In_re => std_logic_vector(Delay12_out1_re),  -- sfix16_En14
              In_im => std_logic_vector(Delay12_out1_im),  -- sfix16_En14
              Push => Delay13_out1,
              Pop => pop,
              rst => OR2_out1,
              Out_re => HDL_FIFO_out1_re,  -- sfix16_En14
              Out_im => HDL_FIFO_out1_im,  -- sfix16_En14
              Empty => HDL_FIFO_out2
              );

  u_rising_edge_detector : rx_demod_ip_src_rising_edge_detector_block3
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb_1_2_0 => enb_1_2_0,
              In_rsvd => HDL_FIFO_out2,
              Out_rsvd => rising_edge_detector_out1
              );

  data_in_re_1 <= signed(data_in_re);

  data_in_im_1 <= signed(data_in_im);

  Delay121_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        data_in_re_2 <= to_signed(16#0000#, 16);
        data_in_im_2 <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_1 = '1' THEN
        data_in_re_2 <= data_in_re_1;
        data_in_im_2 <= data_in_im_1;
      END IF;
    END IF;
  END PROCESS Delay121_output_process;


  Delay12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay12_out1_re <= to_signed(16#0000#, 16);
        Delay12_out1_im <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        Delay12_out1_re <= data_in_re_2;
        Delay12_out1_im <= data_in_im_2;
      END IF;
    END IF;
  END PROCESS Delay12_process;


  crp_out_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        valid_payload_1 <= '0';
      ELSIF enb = '1' THEN
        valid_payload_1 <= valid_payload;
      END IF;
    END IF;
  END PROCESS crp_out_delay_process;


  Delay13_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay13_bypass_reg <= '0';
      ELSIF enb_1_2_1 = '1' THEN
        Delay13_bypass_reg <= valid_payload_1;
      END IF;
    END IF;
  END PROCESS Delay13_bypass_process;

  
  Delay13_out1 <= valid_payload_1 WHEN enb_1_2_1 = '1' ELSE
      Delay13_bypass_reg;

  OR_out1 <= rising_edge_detector1_out1 OR zero_payload;

  header_ready_1 <= header_ready;

  rd_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rd_3_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        rd_3_reg(0) <= header_ready_1;
        rd_3_reg(1) <= rd_3_reg(0);
      END IF;
    END IF;
  END PROCESS rd_3_process;

  header_ready_2 <= rd_3_reg(1);

  one_payload_1 <= one_payload;

  rd_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        one_payload_2 <= '0';
      ELSIF enb = '1' THEN
        one_payload_2 <= one_payload_1;
      END IF;
    END IF;
  END PROCESS rd_2_process;


  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  count_step <= to_unsigned(16#0001#, 16);

  count_reset <= to_unsigned(16#0000#, 16);

  count_1 <= count + count_step;

  rd_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count_2 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        count_2 <= count_1;
      END IF;
    END IF;
  END PROCESS rd_5_process;


  count <= count_3;

  rd_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count_4 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        count_4 <= count;
      END IF;
    END IF;
  END PROCESS rd_4_process;


  
  count_5 <= count_4 WHEN one_payload_2 = '0' ELSE
      count_2;

  rd_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count_6 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        count_6 <= count_5;
      END IF;
    END IF;
  END PROCESS rd_6_process;


  
  count_7 <= count_6 WHEN header_ready_2 = '0' ELSE
      count_reset;

  HDL_Counter_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        HDL_Counter_bypass_reg <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_1 = '1' THEN
        HDL_Counter_bypass_reg <= count_7;
      END IF;
    END IF;
  END PROCESS HDL_Counter_bypass_process;

  
  count_3 <= count_7 WHEN enb_1_2_1 = '1' ELSE
      HDL_Counter_bypass_reg;

  count_8 <= count_3;

  ofdm_samples_unsigned <= unsigned(ofdm_samples);

  
  hit_zero <= '1' WHEN resize(count_8, 32) = ofdm_samples_unsigned ELSE
      '0';

  OR2_out1 <= OR_out1 OR hit_zero;

  Unit_Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Unit_Delay_out1 <= pop;
      END IF;
    END IF;
  END PROCESS Unit_Delay_process;


  Logical_Operator1_out1 <= hit_zero OR (rising_edge_detector_out1 OR header_ready);

  
  pop <= Unit_Delay_out1 WHEN Logical_Operator1_out1 = '0' ELSE
      header_ready;

  Delay14_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay14_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay14_out1 <= pop;
      END IF;
    END IF;
  END PROCESS Delay14_process;


  NOT_out1 <=  NOT hit_zero;

  AND_out1 <= Delay14_out1 AND NOT_out1;

  data_in_re_signed <= signed(data_in_re);

  data_in_im_signed <= signed(data_in_im);

  HDL_FIFO_out1_re_signed <= signed(HDL_FIFO_out1_re);

  HDL_FIFO_out1_im_signed <= signed(HDL_FIFO_out1_im);

  
  Switch3_out1_re <= data_in_re_signed WHEN AND_out1 = '0' ELSE
      HDL_FIFO_out1_re_signed;
  
  Switch3_out1_im <= data_in_im_signed WHEN AND_out1 = '0' ELSE
      HDL_FIFO_out1_im_signed;

  data_out_re <= std_logic_vector(Switch3_out1_re);

  data_out_im <= std_logic_vector(Switch3_out1_im);

  valid_payload_out <= AND_out1;

END rtl;

