// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_tone_mapping.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_tone_mapping
// Source Path: HDLTx/full_tx/payload_full/tone_mapping
// Hierarchy Level: 2
// Model version: 4.114
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_tone_mapping
          (clk,
           reset_x,
           enb,
           data_in,
           ctrl_in_start,
           ctrl_in_end,
           ctrl_in_valid,
           bits_per_subcarrier,
           len_in_ofdm_symbols,
           new_frame,
           data_out,
           ctrl_out_start,
           ctrl_out_end,
           ctrl_out_valid);


  input   clk;
  input   reset_x;
  input   enb;
  input   data_in;
  input   ctrl_in_start;
  input   ctrl_in_end;
  input   ctrl_in_valid;
  input   [3:0] bits_per_subcarrier;  // ufix4
  input   [15:0] len_in_ofdm_symbols;  // uint16
  input   new_frame;
  output  data_out;
  output  ctrl_out_start;
  output  ctrl_out_end;
  output  ctrl_out_valid;


  wire [7:0] Data_Type_Conversion_out1;  // uint8
  reg [7:0] Delay11_out1;  // uint8
  wire [15:0] Gain_mul_temp;  // ufix16
  wire [9:0] Gain_out1;  // ufix10
  reg [9:0] Delay8_reg [0:1];  // ufix10 [2]
  wire [9:0] Delay8_reg_next [0:1];  // ufix10 [2]
  wire [9:0] Delay8_out1;  // ufix10
  reg [15:0] Delay12_out1;  // uint16
  reg [15:0] Delay9_reg [0:1];  // ufix16 [2]
  wire [15:0] Delay9_reg_next [0:1];  // ufix16 [2]
  wire [15:0] Delay9_out1;  // uint16
  wire [25:0] Product1_out1;  // ufix26
  reg [25:0] Delay5_reg [0:1];  // ufix26 [2]
  wire [25:0] Delay5_reg_next [0:1];  // ufix26 [2]
  wire [25:0] count_hit;  // ufix26
  wire [25:0] count_hit_1;  // ufix26
  reg  Delay7_out1_valid;
  wire valid;
  reg  Delay10_out1;
  wire [31:0] count_step;  // uint32
  wire [31:0] count_reset;  // uint32
  reg  Delay7_out1_end;
  wire end_rsvd;
  wire Switch2_out1;
  reg  Unit_Delay1_out1;
  wire [25:0] Subtract_out1;  // ufix26
  wire [25:0] Relational_Operator_1;  // ufix26
  wire Relational_Operator_out1;
  wire Logical_Operator_out1;
  reg [31:0] count;  // uint32
  wire [31:0] count_1;  // uint32
  reg  hold_end;
  wire hold_end_1;
  wire enable;
  wire [31:0] count_2;  // uint32
  wire [31:0] count_3;  // uint32
  wire signed [32:0] Subtract_sub_temp;  // sfix33
  wire signed [32:0] Subtract_1;  // sfix33
  wire signed [32:0] Subtract_2;  // sfix33
  wire Compare_To_Constant_out1;
  wire Logical_Operator5_out1;
  wire Logical_Operator6_out1;
  wire hold_end_2;
  reg  Delay4_out1;
  reg  Delay6_out1;
  reg  Delay_out1;
  wire Constant_out1;
  wire Switch_out1;
  reg  Delay7_out1_start;
  wire start;
  reg  Delay2_out1;
  wire Logical_Operator7_out1;
  wire new_frame_hold;
  reg  Unit_Delay2_out1;
  wire Logical_Operator1_out1;
  reg  Delay3_out1;
  wire hold_end_3;
  wire Logical_Operator3_out1;
  wire Logical_Operator2_out1;
  wire Sample_Control_Bus_Creator_out1_start;
  wire Sample_Control_Bus_Creator_out1_end;
  wire Sample_Control_Bus_Creator_out1_valid;
  reg signed [31:0] Delay8_t_0_0;  // int32
  reg signed [31:0] Delay8_t_1;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_1;  // int32
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_1;  // int32


  assign Data_Type_Conversion_out1 = {4'b0, bits_per_subcarrier};



  always @(posedge clk)
    begin : Delay11_process
      if (reset_x == 1'b1) begin
        Delay11_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Data_Type_Conversion_out1;
        end
      end
    end



  assign Gain_mul_temp = 8'b11000010 * Delay11_out1;
  assign Gain_out1 = Gain_mul_temp[9:0];



  always @(posedge clk)
    begin : Delay8_process
      if (reset_x == 1'b1) begin
        for(Delay8_t_1 = 32'sd0; Delay8_t_1 <= 32'sd1; Delay8_t_1 = Delay8_t_1 + 32'sd1) begin
          Delay8_reg[Delay8_t_1] <= 10'b0000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay8_t_0_0 = 32'sd0; Delay8_t_0_0 <= 32'sd1; Delay8_t_0_0 = Delay8_t_0_0 + 32'sd1) begin
            Delay8_reg[Delay8_t_0_0] <= Delay8_reg_next[Delay8_t_0_0];
          end
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[1];
  assign Delay8_reg_next[0] = Gain_out1;
  assign Delay8_reg_next[1] = Delay8_reg[0];



  always @(posedge clk)
    begin : Delay12_process
      if (reset_x == 1'b1) begin
        Delay12_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= len_in_ofdm_symbols;
        end
      end
    end



  always @(posedge clk)
    begin : Delay9_process
      if (reset_x == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd1; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd1; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
            Delay9_reg[Delay9_t_0_0] <= Delay9_reg_next[Delay9_t_0_0];
          end
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[1];
  assign Delay9_reg_next[0] = Delay12_out1;
  assign Delay9_reg_next[1] = Delay9_reg[0];



  assign Product1_out1 = Delay8_out1 * Delay9_out1;



  always @(posedge clk)
    begin : Delay5_process
      if (reset_x == 1'b1) begin
        for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd1; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_1] <= 26'b00000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd1; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
            Delay5_reg[Delay5_t_0_0] <= Delay5_reg_next[Delay5_t_0_0];
          end
        end
      end
    end

  assign count_hit = Delay5_reg[1];
  assign Delay5_reg_next[0] = Product1_out1;
  assign Delay5_reg_next[1] = Delay5_reg[0];



  assign count_hit_1 = count_hit;

  always @(posedge clk)
    begin : c_process
      if (reset_x == 1'b1) begin
        Delay7_out1_valid <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1_valid <= ctrl_in_valid;
        end
      end
    end



  assign valid = Delay7_out1_valid;

  always @(posedge clk)
    begin : Delay10_process
      if (reset_x == 1'b1) begin
        Delay10_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= valid;
        end
      end
    end



  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  assign count_step = 32'b00000000000000000000000000000001;



  assign count_reset = 32'b00000000000000000000000000000000;



  always @(posedge clk)
    begin : c_1_process
      if (reset_x == 1'b1) begin
        Delay7_out1_end <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1_end <= ctrl_in_end;
        end
      end
    end



  assign end_rsvd = Delay7_out1_end;

  always @(posedge clk)
    begin : Unit_Delay1_process
      if (reset_x == 1'b1) begin
        Unit_Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Unit_Delay1_out1 <= Switch2_out1;
        end
      end
    end



  assign Relational_Operator_1 = {16'b0, Delay8_out1};
  assign Relational_Operator_out1 = Subtract_out1 <= Relational_Operator_1;



  assign Logical_Operator_out1 = end_rsvd & Relational_Operator_out1;



  assign count_1 = count + count_step;



  assign hold_end_1 = hold_end;

  assign enable = Delay10_out1 | hold_end_1;



  assign count_2 = (enable == 1'b0 ? count :
              count_1);



  assign count_3 = (new_frame == 1'b0 ? count_2 :
              count_reset);



  always @(posedge clk)
    begin : HDL_Counter_process
      if (reset_x == 1'b1) begin
        count <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          count <= count_3;
        end
      end
    end



  assign Subtract_1 = {7'b0, count_hit_1};
  assign Subtract_2 = {1'b0, count};
  assign Subtract_sub_temp = Subtract_1 - Subtract_2;
  assign Subtract_out1 = Subtract_sub_temp[25:0];



  tx_125_src_Compare_To_Constant u_Compare_To_Constant (.u(Subtract_out1),  // ufix26
                                                        .y(Compare_To_Constant_out1)
                                                        );

  assign Logical_Operator5_out1 = Compare_To_Constant_out1 & hold_end;



  assign Logical_Operator6_out1 = Logical_Operator5_out1 | Logical_Operator_out1;



  assign Switch2_out1 = (Logical_Operator6_out1 == 1'b0 ? Unit_Delay1_out1 :
              Logical_Operator_out1);



  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        hold_end <= 1'b0;
      end
      else begin
        if (enb) begin
          hold_end <= Switch2_out1;
        end
      end
    end



  assign hold_end_2 = hold_end;

  always @(posedge clk)
    begin : Delay4_process
      if (reset_x == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= hold_end_2;
        end
      end
    end



  always @(posedge clk)
    begin : Delay6_process
      if (reset_x == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= data_in;
        end
      end
    end



  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b1) begin
        Delay_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay_out1 <= Delay6_out1;
        end
      end
    end



  assign Constant_out1 = 1'b0;



  assign Switch_out1 = (Delay4_out1 == 1'b0 ? Delay_out1 :
              Constant_out1);



  assign data_out = Switch_out1;

  always @(posedge clk)
    begin : c_2_process
      if (reset_x == 1'b1) begin
        Delay7_out1_start <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1_start <= ctrl_in_start;
        end
      end
    end



  assign start = Delay7_out1_start;

  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= start;
        end
      end
    end



  assign Logical_Operator7_out1 = Delay2_out1 | new_frame;



  always @(posedge clk)
    begin : Unit_Delay2_process
      if (reset_x == 1'b1) begin
        Unit_Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Unit_Delay2_out1 <= new_frame_hold;
        end
      end
    end



  assign new_frame_hold = (Logical_Operator7_out1 == 1'b0 ? Unit_Delay2_out1 :
              new_frame);



  assign Logical_Operator1_out1 = new_frame_hold & start;



  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b1) begin
        Delay3_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Logical_Operator1_out1;
        end
      end
    end



  assign hold_end_3 = hold_end;

  assign Logical_Operator3_out1 = Compare_To_Constant_out1 & hold_end_3;



  assign Logical_Operator2_out1 = Delay10_out1 | hold_end;



  tx_125_src_Sample_Control_Bus_Creator_block4 u_Sample_Control_Bus_Creator (.In1(Delay3_out1),
                                                                             .In2(Logical_Operator3_out1),
                                                                             .In3(Logical_Operator2_out1),
                                                                             .Out1_start(Sample_Control_Bus_Creator_out1_start),
                                                                             .Out1_end(Sample_Control_Bus_Creator_out1_end),
                                                                             .Out1_valid(Sample_Control_Bus_Creator_out1_valid)
                                                                             );

  assign ctrl_out_start = Sample_Control_Bus_Creator_out1_start;

  assign ctrl_out_end = Sample_Control_Bus_Creator_out1_end;

  assign ctrl_out_valid = Sample_Control_Bus_Creator_out1_valid;

endmodule  // tx_125_src_tone_mapping

