// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_FIR_Interpolator.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_FIR_Interpolator
// Source Path: HDLTx/full_tx/full_ofdm_modulator/interpolator/FIR Interpolator
// Hierarchy Level: 3
// Model version: 4.114
// 
// HDLFIRInterpolation
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_FIR_Interpolator
          (clk,
           reset_x,
           enb,
           dataIn_re,
           dataIn_im,
           validIn,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset_x;
  input   enb;
  input   signed [15:0] dataIn_re;  // sfix16_En14
  input   signed [15:0] dataIn_im;  // sfix16_En14
  input   validIn;
  output  signed [15:0] dataOut_re;  // sfix16_En12
  output  signed [15:0] dataOut_im;  // sfix16_En12
  output  validOut;


  wire syncReset;
  wire signed [15:0] FIROutput2_re;  // sfix16_En12
  wire signed [15:0] FIROutput2_im;  // sfix16_En12
  wire FIRValid2;
  wire outputSharingRSTTerm2;
  wire sharingReset;
  wire counterRST;
  wire validSharing;
  reg  sharingSEL_1;  // ufix1
  wire SharingSEL0;
  wire SharingCount0;
  wire outputSharingRSTTerm1;
  wire outputSharingRSTTerm3;
  reg  outputSharing_1;
  wire counterEnTerm;
  wire counterEn;
  reg [1:0] sharingCounter_1;  // ufix2
  wire validOutTerm;
  reg  validOut_1;
  wire signed [15:0] dataZero_re;  // sfix16_En12
  wire signed [15:0] dataZero_im;  // sfix16_En12
  reg  sharingSELREG;  // ufix1
  wire signed [15:0] FIROutput1_re;  // sfix16_En12
  wire signed [15:0] FIROutput1_im;  // sfix16_En12
  wire FIRValid1;
  reg  [1:0] intdelay_reg;  // ufix1 [2]
  wire ValidPipeline1;
  reg signed [15:0] intdelay_reg_re [0:1];  // sfix16_En12 [2]
  reg signed [15:0] intdelay_reg_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] intdelay_reg_next_re [0:1];  // sfix16_En12 [2]
  wire signed [15:0] intdelay_reg_next_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] FIROutputCastDBP1_re;  // sfix16_En12
  wire signed [15:0] FIROutputCastDBP1_im;  // sfix16_En12
  reg signed [15:0] FIROutputCastDB1_re;  // sfix16_En12
  reg signed [15:0] FIROutputCastDB1_im;  // sfix16_En12
  reg signed [15:0] FIROutputCastDB2_re;  // sfix16_En12
  reg signed [15:0] FIROutputCastDB2_im;  // sfix16_En12
  wire signed [15:0] dataSelect_re;  // sfix16_En12
  wire signed [15:0] dataSelect_im;  // sfix16_En12
  reg signed [31:0] intdelay_t_0_0;  // int32
  reg signed [31:0] intdelay_t_1;  // int32


  assign syncReset = 1'b0;



  tx_125_src_FIRFilter2 u_filterInstantiation (.clk(clk),
                                               .reset_x(reset_x),
                                               .enb(enb),
                                               .dataIn_re(dataIn_re),  // sfix16_En14
                                               .dataIn_im(dataIn_im),  // sfix16_En14
                                               .validIn(validIn),
                                               .dataOut_re(FIROutput2_re),  // sfix16_En12
                                               .dataOut_im(FIROutput2_im),  // sfix16_En12
                                               .validOut(FIRValid2)
                                               );

  assign outputSharingRSTTerm2 =  ~ FIRValid2;



  assign counterRST =  ~ sharingReset;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  always @(posedge clk)
    begin : SharingSEL_process
      if (reset_x == 1'b1) begin
        sharingSEL_1 <= 1'b0;
      end
      else begin
        if (enb && validSharing) begin
          sharingSEL_1 <=  ~ sharingSEL_1;
        end
      end
    end



  assign SharingSEL0 = sharingSEL_1 == 1'b0;



  assign outputSharingRSTTerm1 = SharingCount0 & SharingSEL0;



  assign outputSharingRSTTerm3 = outputSharingRSTTerm1 & outputSharingRSTTerm2;



  assign sharingReset = syncReset | outputSharingRSTTerm3;



  always @(posedge clk)
    begin : OutputSharing_process
      if (reset_x == 1'b1) begin
        outputSharing_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          if (sharingReset == 1'b1) begin
            outputSharing_1 <= 1'b0;
          end
          else begin
            if (FIRValid2) begin
              outputSharing_1 <= FIRValid2;
            end
          end
        end
      end
    end



  assign counterEnTerm = outputSharing_1 | FIRValid2;



  assign counterEn = counterEnTerm & counterRST;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 0
  always @(posedge clk)
    begin : SharingCounter_process
      if (reset_x == 1'b1) begin
        sharingCounter_1 <= 2'b00;
      end
      else begin
        if (enb) begin
          if (counterEn == 1'b1) begin
            sharingCounter_1 <= 2'b00;
          end
        end
      end
    end



  assign SharingCount0 = sharingCounter_1 == 2'b00;



  assign validSharing = SharingCount0 & counterEn;



  assign validOutTerm = validSharing | FIRValid2;



  always @(posedge clk)
    begin : OutputSharing_2_process
      if (reset_x == 1'b1) begin
        validOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            validOut_1 <= 1'b0;
          end
          else begin
            validOut_1 <= validOutTerm;
          end
        end
      end
    end



  assign dataZero_re = 16'sb0000000000000000;
  assign dataZero_im = 16'sb0000000000000000;



  always @(posedge clk)
    begin : OutputSharing_3_process
      if (reset_x == 1'b1) begin
        sharingSELREG <= 1'b0;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            sharingSELREG <= 1'b0;
          end
          else begin
            if (validSharing) begin
              sharingSELREG <= sharingSEL_1;
            end
          end
        end
      end
    end



  tx_125_src_FIRFilter1 u_filterInstantiation_1 (.clk(clk),
                                                 .reset_x(reset_x),
                                                 .enb(enb),
                                                 .dataIn_re(dataIn_re),  // sfix16_En14
                                                 .dataIn_im(dataIn_im),  // sfix16_En14
                                                 .validIn(validIn),
                                                 .dataOut_re(FIROutput1_re),  // sfix16_En12
                                                 .dataOut_im(FIROutput1_im),  // sfix16_En12
                                                 .validOut(FIRValid1)
                                                 );

  always @(posedge clk)
    begin : intdelay_process
      if (reset_x == 1'b1) begin
        intdelay_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            intdelay_reg <= {2{1'b0}};
          end
          else begin
            intdelay_reg[0] <= FIRValid1;
            intdelay_reg[1] <= intdelay_reg[0];
          end
        end
      end
    end

  assign ValidPipeline1 = intdelay_reg[1];



  always @(posedge clk)
    begin : intdelay_1_process
      if (reset_x == 1'b1) begin
        for(intdelay_t_1 = 32'sd0; intdelay_t_1 <= 32'sd1; intdelay_t_1 = intdelay_t_1 + 32'sd1) begin
          intdelay_reg_re[intdelay_t_1] <= 16'sb0000000000000000;
          intdelay_reg_im[intdelay_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            for(intdelay_t_1 = 32'sd0; intdelay_t_1 <= 32'sd1; intdelay_t_1 = intdelay_t_1 + 32'sd1) begin
              intdelay_reg_re[intdelay_t_1] <= 16'sb0000000000000000;
              intdelay_reg_im[intdelay_t_1] <= 16'sb0000000000000000;
            end
          end
          else begin
            for(intdelay_t_0_0 = 32'sd0; intdelay_t_0_0 <= 32'sd1; intdelay_t_0_0 = intdelay_t_0_0 + 32'sd1) begin
              intdelay_reg_re[intdelay_t_0_0] <= intdelay_reg_next_re[intdelay_t_0_0];
              intdelay_reg_im[intdelay_t_0_0] <= intdelay_reg_next_im[intdelay_t_0_0];
            end
          end
        end
      end
    end

  assign FIROutputCastDBP1_re = intdelay_reg_re[1];
  assign FIROutputCastDBP1_im = intdelay_reg_im[1];
  assign intdelay_reg_next_re[0] = FIROutput1_re;
  assign intdelay_reg_next_im[0] = FIROutput1_im;
  assign intdelay_reg_next_re[1] = intdelay_reg_re[0];
  assign intdelay_reg_next_im[1] = intdelay_reg_im[0];



  always @(posedge clk)
    begin : intdelay_2_process
      if (reset_x == 1'b1) begin
        FIROutputCastDB1_re <= 16'sb0000000000000000;
        FIROutputCastDB1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            FIROutputCastDB1_re <= 16'sb0000000000000000;
            FIROutputCastDB1_im <= 16'sb0000000000000000;
          end
          else begin
            if (ValidPipeline1) begin
              FIROutputCastDB1_re <= FIROutputCastDBP1_re;
              FIROutputCastDB1_im <= FIROutputCastDBP1_im;
            end
          end
        end
      end
    end



  always @(posedge clk)
    begin : intdelay_3_process
      if (reset_x == 1'b1) begin
        FIROutputCastDB2_re <= 16'sb0000000000000000;
        FIROutputCastDB2_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            FIROutputCastDB2_re <= 16'sb0000000000000000;
            FIROutputCastDB2_im <= 16'sb0000000000000000;
          end
          else begin
            if (FIRValid2) begin
              FIROutputCastDB2_re <= FIROutput2_re;
              FIROutputCastDB2_im <= FIROutput2_im;
            end
          end
        end
      end
    end



  assign dataSelect_re = (sharingSELREG == 1'b0 ? FIROutputCastDB1_re :
              FIROutputCastDB2_re);
  assign dataSelect_im = (sharingSELREG == 1'b0 ? FIROutputCastDB1_im :
              FIROutputCastDB2_im);



  assign dataOut_re = (validOut_1 == 1'b0 ? dataZero_re :
              dataSelect_re);
  assign dataOut_im = (validOut_1 == 1'b0 ? dataZero_im :
              dataSelect_im);



  assign validOut = validOut_1;

endmodule  // tx_125_src_FIR_Interpolator

