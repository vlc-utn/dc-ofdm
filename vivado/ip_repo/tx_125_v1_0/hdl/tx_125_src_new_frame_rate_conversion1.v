// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_new_frame_rate_conversion1.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_new_frame_rate_conversion1
// Source Path: HDLTx/full_tx/new_frame_rate_conversion1
// Hierarchy Level: 1
// Model version: 4.114
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_new_frame_rate_conversion1
          (clk,
           reset_x,
           enb,
           enb_1_8_1,
           ctrl_in_end,
           new_frame);


  input   clk;
  input   reset_x;
  input   enb;
  input   enb_1_8_1;
  input   ctrl_in_end;
  output  new_frame;


  wire end_rsvd;
  reg  Delay2_out1;
  reg  Delay3_out1;
  reg  Delay4_out1;
  reg  Delay1_out1;
  reg  Delay5_out1;
  reg  Delay6_out1;
  reg  Delay7_out1;
  wire Logical_Operator_out1;
  reg  Rate_Transition2_bypass_reg;  // ufix1
  wire Rate_Transition2_out1;

  // Description:
  // This block "extends" the "end" signal 8 clock cycles, to ensure that the "end" signal can be sampled by the rate 
  // transition block
  // (Otherwise, the "end" signal would be "on" only 1/4th of a cycle, and it can't be ensured that it will be read).


  assign end_rsvd = ctrl_in_end;

  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= end_rsvd;
        end
      end
    end



  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b1) begin
        Delay3_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Delay2_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay4_process
      if (reset_x == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= Delay3_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Delay4_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay5_process
      if (reset_x == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Delay1_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay6_process
      if (reset_x == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Delay5_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay7_process
      if (reset_x == 1'b1) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= Delay6_out1;
        end
      end
    end



  assign Logical_Operator_out1 = Delay4_out1 | (Delay1_out1 | (Delay5_out1 | (Delay6_out1 | (Delay7_out1 | (Delay3_out1 | (end_rsvd | Delay2_out1))))));



  always @(posedge clk)
    begin : Rate_Transition2_bypass_process
      if (reset_x == 1'b1) begin
        Rate_Transition2_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Rate_Transition2_bypass_reg <= Logical_Operator_out1;
        end
      end
    end

  assign Rate_Transition2_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator_out1 :
              Rate_Transition2_bypass_reg);



  assign new_frame = Rate_Transition2_out1;

endmodule  // tx_125_src_new_frame_rate_conversion1

