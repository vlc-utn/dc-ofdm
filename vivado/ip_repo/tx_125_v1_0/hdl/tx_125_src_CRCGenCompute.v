// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_CRCGenCompute.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_CRCGenCompute
// Source Path: HDLTx/full_tx/header_full/h_crc/General CRC Generator HDL Optimized/CRCGenCompute
// Hierarchy Level: 4
// Model version: 4.114
// 
// Compute the CRC CheckSum
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_CRCGenCompute
          (clk,
           reset_x,
           enb,
           datainReg,
           validIn,
           processMsg,
           padZero,
           counter,
           crcChecksum_0,
           crcChecksum_1,
           crcChecksum_2,
           crcChecksum_3,
           crcChecksum_4,
           crcChecksum_5,
           crcChecksum_6,
           crcChecksum_7,
           crcChecksum_8,
           crcChecksum_9,
           crcChecksum_10,
           crcChecksum_11,
           crcChecksum_12,
           crcChecksum_13,
           crcChecksum_14,
           crcChecksum_15);


  input   clk;
  input   reset_x;
  input   enb;
  input   datainReg;  // ufix1
  input   validIn;  // ufix1
  input   processMsg;  // ufix1
  input   padZero;  // ufix1
  input   [3:0] counter;  // ufix4
  output  crcChecksum_0;  // ufix1
  output  crcChecksum_1;  // ufix1
  output  crcChecksum_2;  // ufix1
  output  crcChecksum_3;  // ufix1
  output  crcChecksum_4;  // ufix1
  output  crcChecksum_5;  // ufix1
  output  crcChecksum_6;  // ufix1
  output  crcChecksum_7;  // ufix1
  output  crcChecksum_8;  // ufix1
  output  crcChecksum_9;  // ufix1
  output  crcChecksum_10;  // ufix1
  output  crcChecksum_11;  // ufix1
  output  crcChecksum_12;  // ufix1
  output  crcChecksum_13;  // ufix1
  output  crcChecksum_14;  // ufix1
  output  crcChecksum_15;  // ufix1


  wire xoredSel;  // ufix1
  reg  dvalidin;  // ufix1
  wire tcsSel;  // ufix1
  wire csSel;  // ufix1
  wire rpadZero;  // ufix1
  wire dataSel;  // ufix1
  wire [15:0] padingzeros;  // ufix1 [16]
  wire [14:0] inputzeros;  // ufix1 [15]
  wire [15:0] datamux;  // ufix1 [16]
  wire [15:0] datacpt;  // ufix1 [16]
  wire datacpt_15;  // ufix1
  wire datacpt_14;  // ufix1
  wire datacpt_13;  // ufix1
  wire datacpt_12;  // ufix1
  wire datacpt_11;  // ufix1
  wire datacpt_10;  // ufix1
  wire datacpt_9;  // ufix1
  wire datacpt_8;  // ufix1
  wire datacpt_7;  // ufix1
  wire datacpt_6;  // ufix1
  wire datacpt_5;  // ufix1
  wire datacpt_4;  // ufix1
  wire datacpt_3;  // ufix1
  wire datacpt_2;  // ufix1
  wire datacpt_1;  // ufix1
  wire datacpt_0;  // ufix1
  wire [15:0] finalXorValue;  // ufix1 [16]
  wire finalXorValue_0;  // ufix1
  wire finalXorValue_1;  // ufix1
  wire finalXorValue_2;  // ufix1
  wire finalXorValue_3;  // ufix1
  wire finalXorValue_4;  // ufix1
  wire finalXorValue_5;  // ufix1
  wire finalXorValue_6;  // ufix1
  wire finalXorValue_7;  // ufix1
  wire finalXorValue_8;  // ufix1
  wire finalXorValue_9;  // ufix1
  wire finalXorValue_10;  // ufix1
  wire finalXorValue_11;  // ufix1
  wire finalXorValue_12;  // ufix1
  wire finalXorValue_13;  // ufix1
  wire finalXorValue_14;  // ufix1
  wire finalXorValue_15;  // ufix1
  wire [15:0] newChecksum;  // ufix1 [16]
  wire newChecksum_0;  // ufix1
  wire refelctCheckSum_15;  // ufix1
  wire newChecksum_1;  // ufix1
  wire refelctCheckSum_14;  // ufix1
  wire newChecksum_2;  // ufix1
  wire refelctCheckSum_13;  // ufix1
  wire newChecksum_3;  // ufix1
  wire refelctCheckSum_12;  // ufix1
  wire newChecksum_4;  // ufix1
  wire refelctCheckSum_11;  // ufix1
  wire newChecksum_5;  // ufix1
  wire refelctCheckSum_10;  // ufix1
  wire newChecksum_6;  // ufix1
  wire refelctCheckSum_9;  // ufix1
  wire newChecksum_7;  // ufix1
  wire refelctCheckSum_8;  // ufix1
  wire newChecksum_8;  // ufix1
  wire refelctCheckSum_7;  // ufix1
  wire newChecksum_9;  // ufix1
  wire refelctCheckSum_6;  // ufix1
  wire newChecksum_10;  // ufix1
  wire refelctCheckSum_5;  // ufix1
  wire newChecksum_11;  // ufix1
  wire refelctCheckSum_4;  // ufix1
  wire newChecksum_12;  // ufix1
  wire refelctCheckSum_3;  // ufix1
  wire newChecksum_13;  // ufix1
  wire refelctCheckSum_2;  // ufix1
  wire newChecksum_14;  // ufix1
  wire refelctCheckSum_1;  // ufix1
  wire newChecksum_15;  // ufix1
  wire refelctCheckSum_0;  // ufix1
  wire [15:0] xoredChecksum;  // ufix1 [16]
  reg  [15:0] checksumReg;  // ufix1 [16]
  wire checksumReg_14;  // ufix1
  wire tcs_entry15;  // ufix1
  wire checksumReg_13;  // ufix1
  wire tcs_entry14;  // ufix1
  wire checksumReg_12;  // ufix1
  wire tcs_entry13;  // ufix1
  wire checksumReg_11;  // ufix1
  wire checksumReg_15;  // ufix1
  wire tcs_entry12;  // ufix1
  wire checksumReg_10;  // ufix1
  wire tcs_entry11;  // ufix1
  wire checksumReg_9;  // ufix1
  wire tcs_entry10;  // ufix1
  wire checksumReg_8;  // ufix1
  wire tcs_entry9;  // ufix1
  wire checksumReg_7;  // ufix1
  wire tcs_entry8;  // ufix1
  wire checksumReg_6;  // ufix1
  wire tcs_entry7;  // ufix1
  wire checksumReg_5;  // ufix1
  wire tcs_entry6;  // ufix1
  wire checksumReg_4;  // ufix1
  wire tcs_entry5;  // ufix1
  wire checksumReg_3;  // ufix1
  wire tcs_entry4;  // ufix1
  wire checksumReg_2;  // ufix1
  wire tcs_entry3;  // ufix1
  wire checksumReg_1;  // ufix1
  wire tcs_entry2;  // ufix1
  wire checksumReg_0;  // ufix1
  wire tcs_entry1;  // ufix1
  wire tcs_entry0;  // ufix1
  wire [15:0] tchecksum;  // ufix1 [16]
  wire [15:0] finalChecksum;  // ufix1 [16]
  reg  [15:0] checksum_register_1;  // ufix1 [16]
  reg  [15:0] crcChecksum;  // ufix1 [16]
  reg signed [31:0] checksum_register_t_0_0;  // int32


  assign xoredSel = counter == 4'b1111;



  always @(posedge clk)
    begin : validin_register_process
      if (reset_x == 1'b1) begin
        dvalidin <= 1'b0;
      end
      else begin
        if (enb) begin
          dvalidin <= validIn;
        end
      end
    end



  assign tcsSel = processMsg & dvalidin;



  assign csSel = tcsSel | padZero;



  assign rpadZero =  ~ padZero;



  // Selection signal: Select input data or pad zeros
  assign dataSel = rpadZero & dvalidin;



  // Padding zeros
  assign padingzeros = {16{1'b0}};



  assign inputzeros = {15{1'b0}};



  // Prepare inputs for parallel CRC computation
  assign datamux[0] = inputzeros[0];
  assign datamux[1] = inputzeros[1];
  assign datamux[2] = inputzeros[2];
  assign datamux[3] = inputzeros[3];
  assign datamux[4] = inputzeros[4];
  assign datamux[5] = inputzeros[5];
  assign datamux[6] = inputzeros[6];
  assign datamux[7] = inputzeros[7];
  assign datamux[8] = inputzeros[8];
  assign datamux[9] = inputzeros[9];
  assign datamux[10] = inputzeros[10];
  assign datamux[11] = inputzeros[11];
  assign datamux[12] = inputzeros[12];
  assign datamux[13] = inputzeros[13];
  assign datamux[14] = inputzeros[14];
  assign datamux[15] = datainReg;

  // Switch between input data and padded zeros
  assign datacpt = (dataSel == 1'b0 ? padingzeros :
              datamux);



  assign datacpt_15 = datacpt[15];

  assign datacpt_14 = datacpt[14];

  assign datacpt_13 = datacpt[13];

  assign datacpt_12 = datacpt[12];

  assign datacpt_11 = datacpt[11];

  assign datacpt_10 = datacpt[10];

  assign datacpt_9 = datacpt[9];

  assign datacpt_8 = datacpt[8];

  assign datacpt_7 = datacpt[7];

  assign datacpt_6 = datacpt[6];

  assign datacpt_5 = datacpt[5];

  assign datacpt_4 = datacpt[4];

  assign datacpt_3 = datacpt[3];

  assign datacpt_2 = datacpt[2];

  assign datacpt_1 = datacpt[1];

  assign datacpt_0 = datacpt[0];

  // Compute finalXor
  assign finalXorValue = {16{1'b0}};



  assign finalXorValue_0 = finalXorValue[0];

  assign finalXorValue_1 = finalXorValue[1];

  assign finalXorValue_2 = finalXorValue[2];

  assign finalXorValue_3 = finalXorValue[3];

  assign finalXorValue_4 = finalXorValue[4];

  assign finalXorValue_5 = finalXorValue[5];

  assign finalXorValue_6 = finalXorValue[6];

  assign finalXorValue_7 = finalXorValue[7];

  assign finalXorValue_8 = finalXorValue[8];

  assign finalXorValue_9 = finalXorValue[9];

  assign finalXorValue_10 = finalXorValue[10];

  assign finalXorValue_11 = finalXorValue[11];

  assign finalXorValue_12 = finalXorValue[12];

  assign finalXorValue_13 = finalXorValue[13];

  assign finalXorValue_14 = finalXorValue[14];

  assign finalXorValue_15 = finalXorValue[15];

  assign newChecksum_0 = newChecksum[0];

  assign refelctCheckSum_15 = newChecksum_0 ^ finalXorValue_15;



  assign newChecksum_1 = newChecksum[1];

  assign refelctCheckSum_14 = newChecksum_1 ^ finalXorValue_14;



  assign newChecksum_2 = newChecksum[2];

  assign refelctCheckSum_13 = newChecksum_2 ^ finalXorValue_13;



  assign newChecksum_3 = newChecksum[3];

  assign refelctCheckSum_12 = newChecksum_3 ^ finalXorValue_12;



  assign newChecksum_4 = newChecksum[4];

  assign refelctCheckSum_11 = newChecksum_4 ^ finalXorValue_11;



  assign newChecksum_5 = newChecksum[5];

  assign refelctCheckSum_10 = newChecksum_5 ^ finalXorValue_10;



  assign newChecksum_6 = newChecksum[6];

  assign refelctCheckSum_9 = newChecksum_6 ^ finalXorValue_9;



  assign newChecksum_7 = newChecksum[7];

  assign refelctCheckSum_8 = newChecksum_7 ^ finalXorValue_8;



  assign newChecksum_8 = newChecksum[8];

  assign refelctCheckSum_7 = newChecksum_8 ^ finalXorValue_7;



  assign newChecksum_9 = newChecksum[9];

  assign refelctCheckSum_6 = newChecksum_9 ^ finalXorValue_6;



  assign newChecksum_10 = newChecksum[10];

  assign refelctCheckSum_5 = newChecksum_10 ^ finalXorValue_5;



  assign newChecksum_11 = newChecksum[11];

  assign refelctCheckSum_4 = newChecksum_11 ^ finalXorValue_4;



  assign newChecksum_12 = newChecksum[12];

  assign refelctCheckSum_3 = newChecksum_12 ^ finalXorValue_3;



  assign newChecksum_13 = newChecksum[13];

  assign refelctCheckSum_2 = newChecksum_13 ^ finalXorValue_2;



  assign newChecksum_14 = newChecksum[14];

  assign refelctCheckSum_1 = newChecksum_14 ^ finalXorValue_1;



  // Reflect Checksum and make checksum LSB first
  assign newChecksum_15 = newChecksum[15];

  assign refelctCheckSum_0 = newChecksum_15 ^ finalXorValue_0;



  assign xoredChecksum[0] = refelctCheckSum_0;
  assign xoredChecksum[1] = refelctCheckSum_1;
  assign xoredChecksum[2] = refelctCheckSum_2;
  assign xoredChecksum[3] = refelctCheckSum_3;
  assign xoredChecksum[4] = refelctCheckSum_4;
  assign xoredChecksum[5] = refelctCheckSum_5;
  assign xoredChecksum[6] = refelctCheckSum_6;
  assign xoredChecksum[7] = refelctCheckSum_7;
  assign xoredChecksum[8] = refelctCheckSum_8;
  assign xoredChecksum[9] = refelctCheckSum_9;
  assign xoredChecksum[10] = refelctCheckSum_10;
  assign xoredChecksum[11] = refelctCheckSum_11;
  assign xoredChecksum[12] = refelctCheckSum_12;
  assign xoredChecksum[13] = refelctCheckSum_13;
  assign xoredChecksum[14] = refelctCheckSum_14;
  assign xoredChecksum[15] = refelctCheckSum_15;

  assign checksumReg_14 = checksumReg[14];

  // Compute checksum element16
  assign tcs_entry15 = checksumReg_14 ^ datacpt_0;



  assign checksumReg_13 = checksumReg[13];

  // Compute checksum element15
  assign tcs_entry14 = checksumReg_13 ^ datacpt_1;



  assign checksumReg_12 = checksumReg[12];

  // Compute checksum element14
  assign tcs_entry13 = checksumReg_12 ^ datacpt_2;



  assign checksumReg_11 = checksumReg[11];

  // Compute checksum element13
  assign tcs_entry12 = datacpt_3 ^ (checksumReg_15 ^ checksumReg_11);



  assign checksumReg_10 = checksumReg[10];

  // Compute checksum element12
  assign tcs_entry11 = checksumReg_10 ^ datacpt_4;



  assign checksumReg_9 = checksumReg[9];

  // Compute checksum element11
  assign tcs_entry10 = checksumReg_9 ^ datacpt_5;



  assign checksumReg_8 = checksumReg[8];

  // Compute checksum element10
  assign tcs_entry9 = checksumReg_8 ^ datacpt_6;



  assign checksumReg_7 = checksumReg[7];

  // Compute checksum element9
  assign tcs_entry8 = checksumReg_7 ^ datacpt_7;



  assign checksumReg_6 = checksumReg[6];

  // Compute checksum element8
  assign tcs_entry7 = checksumReg_6 ^ datacpt_8;



  assign checksumReg_5 = checksumReg[5];

  // Compute checksum element7
  assign tcs_entry6 = checksumReg_5 ^ datacpt_9;



  assign checksumReg_4 = checksumReg[4];

  // Compute checksum element6
  assign tcs_entry5 = datacpt_10 ^ (checksumReg_15 ^ checksumReg_4);



  assign checksumReg_3 = checksumReg[3];

  // Compute checksum element5
  assign tcs_entry4 = checksumReg_3 ^ datacpt_11;



  assign checksumReg_2 = checksumReg[2];

  // Compute checksum element4
  assign tcs_entry3 = checksumReg_2 ^ datacpt_12;



  assign checksumReg_1 = checksumReg[1];

  // Compute checksum element3
  assign tcs_entry2 = checksumReg_1 ^ datacpt_13;



  assign checksumReg_0 = checksumReg[0];

  // Compute checksum element2
  assign tcs_entry1 = checksumReg_0 ^ datacpt_14;



  assign checksumReg_15 = checksumReg[15];

  // Compute checksum element1
  // Checksum selection signal
  assign tcs_entry0 = checksumReg_15 ^ datacpt_15;



  assign tchecksum[0] = tcs_entry0;
  assign tchecksum[1] = tcs_entry1;
  assign tchecksum[2] = tcs_entry2;
  assign tchecksum[3] = tcs_entry3;
  assign tchecksum[4] = tcs_entry4;
  assign tchecksum[5] = tcs_entry5;
  assign tchecksum[6] = tcs_entry6;
  assign tchecksum[7] = tcs_entry7;
  assign tchecksum[8] = tcs_entry8;
  assign tchecksum[9] = tcs_entry9;
  assign tchecksum[10] = tcs_entry10;
  assign tchecksum[11] = tcs_entry11;
  assign tchecksum[12] = tcs_entry12;
  assign tchecksum[13] = tcs_entry13;
  assign tchecksum[14] = tcs_entry14;
  assign tchecksum[15] = tcs_entry15;

  always @(posedge clk)
    begin : checksum_register_process
      if (reset_x == 1'b1) begin
        checksum_register_1[0] <= 1'b1;
        checksum_register_1[1] <= 1'b1;
        checksum_register_1[2] <= 1'b1;
        checksum_register_1[3] <= 1'b1;
        checksum_register_1[4] <= 1'b0;
        checksum_register_1[5] <= 1'b0;
        checksum_register_1[6] <= 1'b1;
        checksum_register_1[7] <= 1'b1;
        checksum_register_1[8] <= 1'b0;
        checksum_register_1[9] <= 1'b0;
        checksum_register_1[10] <= 1'b1;
        checksum_register_1[11] <= 1'b0;
        checksum_register_1[12] <= 1'b0;
        checksum_register_1[13] <= 1'b0;
        checksum_register_1[14] <= 1'b0;
        checksum_register_1[15] <= 1'b1;

        for(checksum_register_t_0_0 = 32'sd0; checksum_register_t_0_0 <= 32'sd15; checksum_register_t_0_0 = checksum_register_t_0_0 + 32'sd1) begin
          checksumReg[checksum_register_t_0_0] <= checksum_register_1[checksum_register_t_0_0];
        end

      end
      else begin
        if (enb) begin
          if (xoredSel == 1'b1) begin
            checksum_register_1[0] <= 1'b1;
            checksum_register_1[1] <= 1'b1;
            checksum_register_1[2] <= 1'b1;
            checksum_register_1[3] <= 1'b1;
            checksum_register_1[4] <= 1'b0;
            checksum_register_1[5] <= 1'b0;
            checksum_register_1[6] <= 1'b1;
            checksum_register_1[7] <= 1'b1;
            checksum_register_1[8] <= 1'b0;
            checksum_register_1[9] <= 1'b0;
            checksum_register_1[10] <= 1'b1;
            checksum_register_1[11] <= 1'b0;
            checksum_register_1[12] <= 1'b0;
            checksum_register_1[13] <= 1'b0;
            checksum_register_1[14] <= 1'b0;
            checksum_register_1[15] <= 1'b1;

            for(checksum_register_t_0_0 = 32'sd0; checksum_register_t_0_0 <= 32'sd15; checksum_register_t_0_0 = checksum_register_t_0_0 + 32'sd1) begin
              checksumReg[checksum_register_t_0_0] <= checksum_register_1[checksum_register_t_0_0];
            end

          end
          else begin
            checksumReg <= finalChecksum;
          end
        end
      end
    end



  // Update checksum register for valid inputs
  assign newChecksum = (csSel == 1'b0 ? checksumReg :
              tchecksum);



  // Xor after computing the checksum
  assign finalChecksum = (xoredSel == 1'b0 ? newChecksum :
              xoredChecksum);



  // 1
  always @(posedge clk)
    begin : outputchecksum_register_process
      if (reset_x == 1'b1) begin
        crcChecksum <= {16{1'b0}};
      end
      else begin
        if (enb && xoredSel) begin
          crcChecksum <= finalChecksum;
        end
      end
    end



  assign crcChecksum_0 = crcChecksum[0];

  assign crcChecksum_1 = crcChecksum[1];

  assign crcChecksum_2 = crcChecksum[2];

  assign crcChecksum_3 = crcChecksum[3];

  assign crcChecksum_4 = crcChecksum[4];

  assign crcChecksum_5 = crcChecksum[5];

  assign crcChecksum_6 = crcChecksum[6];

  assign crcChecksum_7 = crcChecksum[7];

  assign crcChecksum_8 = crcChecksum[8];

  assign crcChecksum_9 = crcChecksum[9];

  assign crcChecksum_10 = crcChecksum[10];

  assign crcChecksum_11 = crcChecksum[11];

  assign crcChecksum_12 = crcChecksum[12];

  assign crcChecksum_13 = crcChecksum[13];

  assign crcChecksum_14 = crcChecksum[14];

  assign crcChecksum_15 = crcChecksum[15];

endmodule  // tx_125_src_CRCGenCompute

