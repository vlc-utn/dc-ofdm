// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_frequency_upshift.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_frequency_upshift
// Source Path: HDLTx/full_tx/full_ofdm_modulator/frequency_upshift
// Hierarchy Level: 2
// Model version: 4.114
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_frequency_upshift
          (clk,
           reset_x,
           enb,
           data_in_re,
           data_in_im,
           valid_in,
           reset,
           data_out,
           valid_out);


  input   clk;
  input   reset_x;
  input   enb;
  input   signed [15:0] data_in_re;  // sfix16_En12
  input   signed [15:0] data_in_im;  // sfix16_En12
  input   valid_in;
  input   reset;
  output  signed [15:0] data_out;  // sfix16_En12
  output  valid_out;


  wire stateControl;
  reg  [1:0] delayMatch3_reg;  // ufix1 [2]
  wire stateControl_1;
  wire enb_gated;
  reg signed [15:0] Delay3_out1_re;  // sfix16_En12
  reg signed [15:0] Delay3_out1_im;  // sfix16_En12
  wire stateControl_3;
  reg  [1:0] delayMatch_reg;  // ufix1 [2]
  wire stateControl_4;
  wire enb_gated_1;
  reg signed [15:0] Delay_reg_re [0:5];  // sfix16_En12 [6]
  reg signed [15:0] Delay_reg_im [0:5];  // sfix16_En12 [6]
  reg signed [15:0] Delay_reg_next_re [0:5];  // sfix16_En12 [6]
  reg signed [15:0] Delay_reg_next_im [0:5];  // sfix16_En12 [6]
  reg signed [15:0] Delay_out1_re;  // sfix16_En12
  reg signed [15:0] Delay_out1_im;  // sfix16_En12
  wire stateControl_5;
  reg  [1:0] delayMatch2_reg;  // ufix1 [2]
  wire stateControl_6;
  wire enb_gated_2;
  reg  Delay2_out1;
  wire signed [15:0] NCO_out1_re;  // sfix16_En14
  wire signed [15:0] NCO_out1_im;  // sfix16_En14
  wire NCO_out2;
  wire signed [15:0] Mixer_out1;  // sfix16_En12
  wire stateControl_7;
  reg  [1:0] delayMatch1_reg;  // ufix1 [2]
  wire stateControl_8;
  wire enb_gated_3;
  reg  [8:0] Delay1_reg;  // ufix1 [9]
  wire Delay1_out1;
  reg signed [31:0] Delay_t_0_0;  // int32
  reg signed [31:0] Delay_t_0_1;  // int32
  reg signed [31:0] Delay_t_1;  // int32


  assign stateControl = 1'b1;



  always @(posedge clk)
    begin : delayMatch3_process
      if (reset_x == 1'b1) begin
        delayMatch3_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch3_reg[0] <= stateControl;
          delayMatch3_reg[1] <= delayMatch3_reg[0];
        end
      end
    end

  assign stateControl_1 = delayMatch3_reg[1];



  assign enb_gated = stateControl_1 && enb;

  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b1) begin
        Delay3_out1_re <= 16'sb0000000000000000;
        Delay3_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated) begin
          Delay3_out1_re <= data_in_re;
          Delay3_out1_im <= data_in_im;
        end
      end
    end



  assign stateControl_3 = 1'b1;



  always @(posedge clk)
    begin : delayMatch_process
      if (reset_x == 1'b1) begin
        delayMatch_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= stateControl_3;
          delayMatch_reg[1] <= delayMatch_reg[0];
        end
      end
    end

  assign stateControl_4 = delayMatch_reg[1];



  assign enb_gated_1 = stateControl_4 && enb;

  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b1) begin
        for(Delay_t_1 = 32'sd0; Delay_t_1 <= 32'sd5; Delay_t_1 = Delay_t_1 + 32'sd1) begin
          Delay_reg_re[Delay_t_1] <= 16'sb0000000000000000;
          Delay_reg_im[Delay_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_gated_1) begin
          for(Delay_t_0_1 = 32'sd0; Delay_t_0_1 <= 32'sd5; Delay_t_0_1 = Delay_t_0_1 + 32'sd1) begin
            Delay_reg_re[Delay_t_0_1] <= Delay_reg_next_re[Delay_t_0_1];
            Delay_reg_im[Delay_t_0_1] <= Delay_reg_next_im[Delay_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay_out1_re = Delay_reg_re[5];
    Delay_out1_im = Delay_reg_im[5];
    Delay_reg_next_re[0] = Delay3_out1_re;
    Delay_reg_next_im[0] = Delay3_out1_im;

    for(Delay_t_0_0 = 32'sd0; Delay_t_0_0 <= 32'sd4; Delay_t_0_0 = Delay_t_0_0 + 32'sd1) begin
      Delay_reg_next_re[Delay_t_0_0 + 32'sd1] = Delay_reg_re[Delay_t_0_0];
      Delay_reg_next_im[Delay_t_0_0 + 32'sd1] = Delay_reg_im[Delay_t_0_0];
    end

  end



  assign stateControl_5 = 1'b1;



  always @(posedge clk)
    begin : delayMatch2_process
      if (reset_x == 1'b1) begin
        delayMatch2_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= stateControl_5;
          delayMatch2_reg[1] <= delayMatch2_reg[0];
        end
      end
    end

  assign stateControl_6 = delayMatch2_reg[1];



  assign enb_gated_2 = stateControl_6 && enb;

  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_2) begin
          Delay2_out1 <= valid_in;
        end
      end
    end



  tx_125_src_NCO u_NCO (.clk(clk),
                        .reset_x(reset_x),
                        .enb(enb),
                        .resetPhase(reset),
                        .validIn(Delay2_out1),
                        .complexexp_re(NCO_out1_re),  // sfix16_En14
                        .complexexp_im(NCO_out1_im),  // sfix16_En14
                        .validOut(NCO_out2)
                        );

  tx_125_src_Mixer u_Mixer (.clk(clk),
                            .reset_x(reset_x),
                            .enb(enb),
                            .dataIn_re(Delay_out1_re),  // sfix16_En12
                            .dataIn_im(Delay_out1_im),  // sfix16_En12
                            .ncoIn_re(NCO_out1_re),  // sfix16_En14
                            .ncoIn_im(NCO_out1_im),  // sfix16_En14
                            .mixedOut(Mixer_out1)  // sfix16_En12
                            );

  assign data_out = Mixer_out1;

  assign stateControl_7 = 1'b1;



  always @(posedge clk)
    begin : delayMatch1_process
      if (reset_x == 1'b1) begin
        delayMatch1_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= stateControl_7;
          delayMatch1_reg[1] <= delayMatch1_reg[0];
        end
      end
    end

  assign stateControl_8 = delayMatch1_reg[1];



  assign enb_gated_3 = stateControl_8 && enb;

  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_reg <= {9{1'b0}};
      end
      else begin
        if (enb_gated_3) begin
          Delay1_reg[0] <= NCO_out2;
          Delay1_reg[32'sd8:32'sd1] <= Delay1_reg[32'sd7:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[8];



  assign valid_out = Delay1_out1;

endmodule  // tx_125_src_frequency_upshift

