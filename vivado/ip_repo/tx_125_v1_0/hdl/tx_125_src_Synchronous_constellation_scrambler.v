// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_Synchronous_constellation_scrambler.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_Synchronous_constellation_scrambler
// Source Path: HDLTx/full_tx/full_ofdm_modulator/enabled_qam_and_scrambler/sync_constellation_scrambler/Synchronous 
// constellation scramble
// Hierarchy Level: 4
// Model version: 4.114
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_Synchronous_constellation_scrambler
          (clk,
           reset_x,
           enb_1_2_0,
           valid_in,
           init_0,
           init_1,
           init_2,
           init_3,
           init_4,
           init_5,
           init_6,
           init_7,
           init_8,
           init_9,
           init_10,
           init_11,
           init_12,
           new_ofdm_symbol,
           ready_out,
           s1_out,
           s2_out);


  input   clk;
  input   reset_x;
  input   enb_1_2_0;
  input   valid_in;
  input   init_0;  // boolean
  input   init_1;  // boolean
  input   init_2;  // boolean
  input   init_3;  // boolean
  input   init_4;  // boolean
  input   init_5;  // boolean
  input   init_6;  // boolean
  input   init_7;  // boolean
  input   init_8;  // boolean
  input   init_9;  // boolean
  input   init_10;  // boolean
  input   init_11;  // boolean
  input   init_12;  // boolean
  input   new_ofdm_symbol;
  input   ready_out;
  output  s1_out;
  output  s2_out;


  wire enb_1_2_0_gated;
  wire enb_1_2_0_gated_1;
  wire enb_1_2_0_gated_2;
  wire enb_1_2_0_gated_3;
  wire enb_1_2_0_gated_4;
  wire enb_1_2_0_gated_5;
  wire enb_1_2_0_gated_6;
  wire enb_1_2_0_gated_7;
  wire enb_1_2_0_gated_8;
  wire enb_1_2_0_gated_9;
  wire enb_1_2_0_gated_10;
  wire enb_1_2_0_gated_11;
  wire enb_1_2_0_gated_12;
  wire s1;
  wire s1_1;
  wire Switch2_out1;
  reg  Delay2_bypass_delay;  // ufix1
  reg  Delay2_reg;  // ufix1
  wire Delay2_out1;
  wire Switch4_out1;
  reg  Delay4_bypass_delay;  // ufix1
  reg  Delay4_reg;  // ufix1
  wire Delay4_out1;
  wire Switch6_out1;
  reg  Delay6_bypass_delay;  // ufix1
  reg  Delay6_reg;  // ufix1
  wire Delay6_out1;
  wire Switch8_out1;
  reg  Delay8_bypass_delay;  // ufix1
  reg  Delay8_reg;  // ufix1
  wire Delay8_out1;
  wire Switch10_out1;
  reg  Delay10_bypass_delay;  // ufix1
  reg  Delay10_reg;  // ufix1
  wire Delay10_out1;
  wire Switch12_out1;
  reg  Delay12_bypass_delay;  // ufix1
  reg  Delay12_reg;  // ufix1
  wire Delay12_out1;
  wire Delay11_out1;
  wire XOR3_out1;
  wire XOR4_out1;
  wire Delay7_out1;
  wire XOR5_out1;
  wire Switch1_out1;
  reg  Delay1_bypass_delay;  // ufix1
  reg  Delay1_reg;  // ufix1
  wire s2;
  wire s2_1;
  wire Switch3_out1;
  reg  Delay3_bypass_delay;  // ufix1
  reg  Delay3_reg;  // ufix1
  wire Delay3_out1;
  wire Switch5_out1;
  reg  Delay5_bypass_delay;  // ufix1
  reg  Delay5_reg;  // ufix1
  wire Delay5_out1;
  wire Switch7_out1;
  reg  Delay7_bypass_delay;  // ufix1
  reg  Delay7_reg;  // ufix1
  wire Switch9_out1;
  reg  Delay9_bypass_delay;  // ufix1
  reg  Delay9_reg;  // ufix1
  wire Delay9_out1;
  wire Switch11_out1;
  reg  Delay11_bypass_delay;  // ufix1
  reg  Delay11_reg;  // ufix1
  wire XOR_out1;
  wire XOR1_out1;
  wire XOR2_out1;
  wire Switch_out1;
  reg  Delay_bypass_delay;  // ufix1
  reg  Delay_reg;  // ufix1
  wire s1_2;
  wire s2_2;


  assign enb_1_2_0_gated = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_1 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_2 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_3 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_4 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_5 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_6 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_7 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_8 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_9 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_10 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_11 = ready_out && enb_1_2_0;

  assign enb_1_2_0_gated_12 = ready_out && enb_1_2_0;

  assign s1_1 = s1;

  assign Switch2_out1 = (new_ofdm_symbol == 1'b0 ? s1_1 :
              init_2);



  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b1) begin
        Delay2_bypass_delay <= 1'b0;
        Delay2_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated && valid_in) begin
          Delay2_bypass_delay <= Delay2_reg;
          Delay2_reg <= Switch2_out1;
        end
      end
    end

  assign Delay2_out1 = (valid_in == 1'b1 ? Delay2_reg :
              Delay2_bypass_delay);



  assign Switch4_out1 = (new_ofdm_symbol == 1'b0 ? Delay2_out1 :
              init_4);



  always @(posedge clk)
    begin : Delay4_process
      if (reset_x == 1'b1) begin
        Delay4_bypass_delay <= 1'b0;
        Delay4_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_1 && valid_in) begin
          Delay4_bypass_delay <= Delay4_reg;
          Delay4_reg <= Switch4_out1;
        end
      end
    end

  assign Delay4_out1 = (valid_in == 1'b1 ? Delay4_reg :
              Delay4_bypass_delay);



  assign Switch6_out1 = (new_ofdm_symbol == 1'b0 ? Delay4_out1 :
              init_6);



  always @(posedge clk)
    begin : Delay6_process
      if (reset_x == 1'b1) begin
        Delay6_bypass_delay <= 1'b0;
        Delay6_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_2 && valid_in) begin
          Delay6_bypass_delay <= Delay6_reg;
          Delay6_reg <= Switch6_out1;
        end
      end
    end

  assign Delay6_out1 = (valid_in == 1'b1 ? Delay6_reg :
              Delay6_bypass_delay);



  assign Switch8_out1 = (new_ofdm_symbol == 1'b0 ? Delay6_out1 :
              init_8);



  always @(posedge clk)
    begin : Delay8_process
      if (reset_x == 1'b1) begin
        Delay8_bypass_delay <= 1'b0;
        Delay8_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_3 && valid_in) begin
          Delay8_bypass_delay <= Delay8_reg;
          Delay8_reg <= Switch8_out1;
        end
      end
    end

  assign Delay8_out1 = (valid_in == 1'b1 ? Delay8_reg :
              Delay8_bypass_delay);



  assign Switch10_out1 = (new_ofdm_symbol == 1'b0 ? Delay8_out1 :
              init_10);



  always @(posedge clk)
    begin : Delay10_process
      if (reset_x == 1'b1) begin
        Delay10_bypass_delay <= 1'b0;
        Delay10_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_4 && valid_in) begin
          Delay10_bypass_delay <= Delay10_reg;
          Delay10_reg <= Switch10_out1;
        end
      end
    end

  assign Delay10_out1 = (valid_in == 1'b1 ? Delay10_reg :
              Delay10_bypass_delay);



  assign Switch12_out1 = (new_ofdm_symbol == 1'b0 ? Delay10_out1 :
              init_12);



  always @(posedge clk)
    begin : Delay12_process
      if (reset_x == 1'b1) begin
        Delay12_bypass_delay <= 1'b0;
        Delay12_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_5 && valid_in) begin
          Delay12_bypass_delay <= Delay12_reg;
          Delay12_reg <= Switch12_out1;
        end
      end
    end

  assign Delay12_out1 = (valid_in == 1'b1 ? Delay12_reg :
              Delay12_bypass_delay);



  assign XOR3_out1 = Delay12_out1 ^ Delay11_out1;



  assign XOR4_out1 = XOR3_out1 ^ Delay10_out1;



  assign XOR5_out1 = XOR4_out1 ^ Delay7_out1;



  assign Switch1_out1 = (new_ofdm_symbol == 1'b0 ? XOR5_out1 :
              init_1);



  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_bypass_delay <= 1'b0;
        Delay1_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_6 && valid_in) begin
          Delay1_bypass_delay <= Delay1_reg;
          Delay1_reg <= Switch1_out1;
        end
      end
    end

  assign s2 = (valid_in == 1'b1 ? Delay1_reg :
              Delay1_bypass_delay);



  assign s2_1 = s2;

  assign Switch3_out1 = (new_ofdm_symbol == 1'b0 ? s2_1 :
              init_3);



  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b1) begin
        Delay3_bypass_delay <= 1'b0;
        Delay3_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_7 && valid_in) begin
          Delay3_bypass_delay <= Delay3_reg;
          Delay3_reg <= Switch3_out1;
        end
      end
    end

  assign Delay3_out1 = (valid_in == 1'b1 ? Delay3_reg :
              Delay3_bypass_delay);



  assign Switch5_out1 = (new_ofdm_symbol == 1'b0 ? Delay3_out1 :
              init_5);



  always @(posedge clk)
    begin : Delay5_process
      if (reset_x == 1'b1) begin
        Delay5_bypass_delay <= 1'b0;
        Delay5_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_8 && valid_in) begin
          Delay5_bypass_delay <= Delay5_reg;
          Delay5_reg <= Switch5_out1;
        end
      end
    end

  assign Delay5_out1 = (valid_in == 1'b1 ? Delay5_reg :
              Delay5_bypass_delay);



  assign Switch7_out1 = (new_ofdm_symbol == 1'b0 ? Delay5_out1 :
              init_7);



  always @(posedge clk)
    begin : Delay7_process
      if (reset_x == 1'b1) begin
        Delay7_bypass_delay <= 1'b0;
        Delay7_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_9 && valid_in) begin
          Delay7_bypass_delay <= Delay7_reg;
          Delay7_reg <= Switch7_out1;
        end
      end
    end

  assign Delay7_out1 = (valid_in == 1'b1 ? Delay7_reg :
              Delay7_bypass_delay);



  assign Switch9_out1 = (new_ofdm_symbol == 1'b0 ? Delay7_out1 :
              init_9);



  always @(posedge clk)
    begin : Delay9_process
      if (reset_x == 1'b1) begin
        Delay9_bypass_delay <= 1'b0;
        Delay9_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_10 && valid_in) begin
          Delay9_bypass_delay <= Delay9_reg;
          Delay9_reg <= Switch9_out1;
        end
      end
    end

  assign Delay9_out1 = (valid_in == 1'b1 ? Delay9_reg :
              Delay9_bypass_delay);



  assign Switch11_out1 = (new_ofdm_symbol == 1'b0 ? Delay9_out1 :
              init_11);



  always @(posedge clk)
    begin : Delay11_process
      if (reset_x == 1'b1) begin
        Delay11_bypass_delay <= 1'b0;
        Delay11_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_11 && valid_in) begin
          Delay11_bypass_delay <= Delay11_reg;
          Delay11_reg <= Switch11_out1;
        end
      end
    end

  assign Delay11_out1 = (valid_in == 1'b1 ? Delay11_reg :
              Delay11_bypass_delay);



  assign XOR_out1 = Delay11_out1 ^ Delay10_out1;



  assign XOR1_out1 = XOR_out1 ^ Delay9_out1;



  assign XOR2_out1 = XOR1_out1 ^ Delay6_out1;



  assign Switch_out1 = (new_ofdm_symbol == 1'b0 ? XOR2_out1 :
              init_0);



  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b1) begin
        Delay_bypass_delay <= 1'b0;
        Delay_reg <= 1'b0;
      end
      else begin
        if (enb_1_2_0_gated_12 && valid_in) begin
          Delay_bypass_delay <= Delay_reg;
          Delay_reg <= Switch_out1;
        end
      end
    end

  assign s1 = (valid_in == 1'b1 ? Delay_reg :
              Delay_bypass_delay);



  assign s1_2 = s1;

  assign s1_out = s1_2;

  assign s2_2 = s2;

  assign s2_out = s2_2;

endmodule  // tx_125_src_Synchronous_constellation_scrambler

