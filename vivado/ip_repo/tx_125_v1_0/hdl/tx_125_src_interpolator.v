// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/HDLTx/tx_125_src_interpolator.v
// Created: 2024-09-14 22:22:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: tx_125_src_interpolator
// Source Path: HDLTx/full_tx/full_ofdm_modulator/interpolator
// Hierarchy Level: 2
// Model version: 4.114
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module tx_125_src_interpolator
          (clk,
           reset_x,
           enb_1_2_0,
           enb,
           data_in_re,
           data_in_im,
           valid_in,
           data_out_re,
           data_out_im,
           valid_out);


  input   clk;
  input   reset_x;
  input   enb_1_2_0;
  input   enb;
  input   signed [15:0] data_in_re;  // sfix16_En14
  input   signed [15:0] data_in_im;  // sfix16_En14
  input   valid_in;
  output  signed [15:0] data_out_re;  // sfix16_En12
  output  signed [15:0] data_out_im;  // sfix16_En12
  output  valid_out;


  reg  Upsample_muxsel;  // ufix1
  wire stateControl;
  reg  stateControl_1;
  wire enb_1_2_0_gated;
  reg signed [15:0] Delay5_reg_re [0:1];  // sfix16_En14 [2]
  reg signed [15:0] Delay5_reg_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay5_reg_next_re [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay5_reg_next_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay5_out1_re;  // sfix16_En14
  wire signed [15:0] Delay5_out1_im;  // sfix16_En14
  wire signed [15:0] Upsample_zero_re;  // sfix16_En14
  wire signed [15:0] Upsample_zero_im;  // sfix16_En14
  wire signed [15:0] Upsample_out1_re;  // sfix16_En14
  wire signed [15:0] Upsample_out1_im;  // sfix16_En14
  reg  Upsample1_muxsel;  // ufix1
  wire stateControl_2;
  reg  stateControl_3;
  wire enb_1_2_0_gated_1;
  reg  [13:0] Delay3_reg;  // ufix1 [14]
  wire Delay3_out1;
  wire Logical_Operator_out1;
  wire stateControl_4;
  reg  stateControl_5;
  wire enb_1_2_0_gated_2;
  reg  [1:0] Delay2_reg;  // ufix1 [2]
  wire Delay2_out1;
  wire Upsample1_zero;
  wire Upsample1_out1;
  wire signed [15:0] FIR_Interpolator_out1_re;  // sfix16_En12
  wire signed [15:0] FIR_Interpolator_out1_im;  // sfix16_En12
  wire FIR_Interpolator_out2;
  wire stateControl_6;
  reg  [1:0] delayMatch16_reg;  // ufix1 [2]
  wire stateControl_7;
  wire enb_gated;
  reg signed [15:0] Delay9_out1_re;  // sfix16_En12
  reg signed [15:0] Delay9_out1_im;  // sfix16_En12
  wire stateControl_8;
  reg  [1:0] delayMatch13_reg;  // ufix1 [2]
  wire stateControl_9;
  wire enb_gated_1;
  reg signed [15:0] Delay6_out1_re;  // sfix16_En12
  reg signed [15:0] Delay6_out1_im;  // sfix16_En12
  wire stateControl_10;
  reg  [1:0] delayMatch3_reg;  // ufix1 [2]
  wire stateControl_11;
  wire enb_gated_2;
  reg signed [15:0] Delay11_out1_re;  // sfix16_En12
  reg signed [15:0] Delay11_out1_im;  // sfix16_En12
  wire stateControl_12;
  reg  [1:0] delayMatch7_reg;  // ufix1 [2]
  wire stateControl_13;
  wire enb_gated_3;
  reg signed [15:0] Delay17_reg_re [0:13];  // sfix16_En12 [14]
  reg signed [15:0] Delay17_reg_im [0:13];  // sfix16_En12 [14]
  reg signed [15:0] Delay17_reg_next_re [0:13];  // sfix16_En12 [14]
  reg signed [15:0] Delay17_reg_next_im [0:13];  // sfix16_En12 [14]
  reg signed [15:0] Delay17_out1_re;  // sfix16_En12
  reg signed [15:0] Delay17_out1_im;  // sfix16_En12
  wire stateControl_14;
  reg  [1:0] delayMatch11_reg;  // ufix1 [2]
  wire stateControl_15;
  wire enb_gated_4;
  reg signed [15:0] Delay4_out1_re;  // sfix16_En12
  reg signed [15:0] Delay4_out1_im;  // sfix16_En12
  wire stateControl_16;
  reg  [1:0] delayMatch1_reg;  // ufix1 [2]
  wire stateControl_17;
  wire enb_gated_5;
  reg  [13:0] Delay1_reg;  // ufix1 [14]
  wire Delay1_out1;
  wire Logical_Operator1_out1;
  wire stateControl_18;
  reg  [1:0] delayMatch15_reg;  // ufix1 [2]
  wire stateControl_19;
  wire enb_gated_6;
  reg  Delay8_out1;
  wire stateControl_20;
  reg  [1:0] delayMatch4_reg;  // ufix1 [2]
  wire stateControl_21;
  wire enb_gated_7;
  reg  Delay14_out1;
  wire stateControl_22;
  reg  [1:0] delayMatch5_reg;  // ufix1 [2]
  wire stateControl_23;
  wire enb_gated_8;
  reg  Delay15_out1;
  wire stateControl_24;
  reg  [1:0] delayMatch6_reg;  // ufix1 [2]
  wire stateControl_25;
  wire enb_gated_9;
  wire b;
  wire stateControl_26;
  reg  [1:0] delayMatch2_reg;  // ufix1 [2]
  wire stateControl_27;
  wire enb_gated_10;
  reg  Delay10_out1;
  wire [7:0] count_step;  // uint8
  wire [7:0] count_from;  // uint8
  wire [7:0] count_reset;  // uint8
  wire zero_1;
  wire stateControl_28;
  reg  [1:0] delayMatch14_reg;  // ufix1 [2]
  wire stateControl_29;
  wire enb_gated_11;
  wire stateControl_30;
  reg  [1:0] delayMatch17_reg;  // ufix1 [2]
  wire stateControl_31;
  wire enb_gated_12;
  wire count_enable;
  reg  Unit_Delay_out1;
  reg [7:0] count;  // uint8
  wire range_hit;
  wire [7:0] count_1;  // uint8
  wire need_to_wrap;
  wire [7:0] count_value;  // uint8
  wire [7:0] count_2;  // uint8
  wire [7:0] count_3;  // uint8
  wire count_hit;
  wire HDL_Counter_out2;
  reg  Delay7_out1;
  wire Logical_Operator4_out1;
  wire stateControl_32;
  reg  [1:0] delayMatch8_reg;  // ufix1 [2]
  wire stateControl_33;
  wire enb_gated_13;
  reg  [13:0] Delay16_reg;  // ufix1 [14]
  wire Delay16_out1;
  reg  Delay18_out1;
  wire Logical_Operator3_out1;
  wire Logical_Operator2_out1;
  wire stateControl_35;
  reg  [1:0] delayMatch_reg;  // ufix1 [2]
  wire stateControl_36;
  wire enb_gated_14;
  reg  Delay_out1;
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay17_t_0_0;  // int32
  reg signed [31:0] Delay17_t_0_1;  // int32
  reg signed [31:0] Delay17_t_1;  // int32


  // Free running, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  always @(posedge clk)
    begin : Upsample_cnt_process
      if (reset_x == 1'b1) begin
        Upsample_muxsel <= 1'b1;
      end
      else begin
        if (enb) begin
          Upsample_muxsel <=  ~ Upsample_muxsel;
        end
      end
    end



  assign stateControl = 1'b1;



  always @(posedge clk)
    begin : delayMatch12_process
      if (reset_x == 1'b1) begin
        stateControl_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          stateControl_1 <= stateControl;
        end
      end
    end



  assign enb_1_2_0_gated = stateControl_1 && enb_1_2_0;

  always @(posedge clk)
    begin : Delay5_process
      if (reset_x == 1'b1) begin
        for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd1; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
          Delay5_reg_re[Delay5_t_1] <= 16'sb0000000000000000;
          Delay5_reg_im[Delay5_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_2_0_gated) begin
          for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd1; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
            Delay5_reg_re[Delay5_t_0_0] <= Delay5_reg_next_re[Delay5_t_0_0];
            Delay5_reg_im[Delay5_t_0_0] <= Delay5_reg_next_im[Delay5_t_0_0];
          end
        end
      end
    end

  assign Delay5_out1_re = Delay5_reg_re[1];
  assign Delay5_out1_im = Delay5_reg_im[1];
  assign Delay5_reg_next_re[0] = data_in_re;
  assign Delay5_reg_next_im[0] = data_in_im;
  assign Delay5_reg_next_re[1] = Delay5_reg_re[0];
  assign Delay5_reg_next_im[1] = Delay5_reg_im[0];



  assign Upsample_zero_re = 16'sb0000000000000000;
  assign Upsample_zero_im = 16'sb0000000000000000;



  // Upsample: Upsample by 2, Sample offset 0 
  assign Upsample_out1_re = (Upsample_muxsel == 1'b1 ? Delay5_out1_re :
              Upsample_zero_re);
  assign Upsample_out1_im = (Upsample_muxsel == 1'b1 ? Delay5_out1_im :
              Upsample_zero_im);



  // Free running, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  always @(posedge clk)
    begin : Upsample1_cnt_process
      if (reset_x == 1'b1) begin
        Upsample1_muxsel <= 1'b1;
      end
      else begin
        if (enb) begin
          Upsample1_muxsel <=  ~ Upsample1_muxsel;
        end
      end
    end



  assign stateControl_2 = 1'b1;



  always @(posedge clk)
    begin : delayMatch10_process
      if (reset_x == 1'b1) begin
        stateControl_3 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          stateControl_3 <= stateControl_2;
        end
      end
    end



  assign enb_1_2_0_gated_1 = stateControl_3 && enb_1_2_0;

  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b1) begin
        Delay3_reg <= {14{1'b0}};
      end
      else begin
        if (enb_1_2_0_gated_1) begin
          Delay3_reg[0] <= valid_in;
          Delay3_reg[32'sd13:32'sd1] <= Delay3_reg[32'sd12:32'sd0];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[13];



  assign Logical_Operator_out1 = valid_in | Delay3_out1;



  assign stateControl_4 = 1'b1;



  always @(posedge clk)
    begin : delayMatch9_process
      if (reset_x == 1'b1) begin
        stateControl_5 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          stateControl_5 <= stateControl_4;
        end
      end
    end



  assign enb_1_2_0_gated_2 = stateControl_5 && enb_1_2_0;

  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b1) begin
        Delay2_reg <= {2{1'b0}};
      end
      else begin
        if (enb_1_2_0_gated_2) begin
          Delay2_reg[0] <= Logical_Operator_out1;
          Delay2_reg[1] <= Delay2_reg[0];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[1];



  assign Upsample1_zero = 1'b0;



  // Upsample1: Upsample by 2, Sample offset 0 
  assign Upsample1_out1 = (Upsample1_muxsel == 1'b1 ? Delay2_out1 :
              Upsample1_zero);



  tx_125_src_FIR_Interpolator u_FIR_Interpolator (.clk(clk),
                                                  .reset_x(reset_x),
                                                  .enb(enb),
                                                  .dataIn_re(Upsample_out1_re),  // sfix16_En14
                                                  .dataIn_im(Upsample_out1_im),  // sfix16_En14
                                                  .validIn(Upsample1_out1),
                                                  .dataOut_re(FIR_Interpolator_out1_re),  // sfix16_En12
                                                  .dataOut_im(FIR_Interpolator_out1_im),  // sfix16_En12
                                                  .validOut(FIR_Interpolator_out2)
                                                  );

  assign stateControl_6 = 1'b1;



  always @(posedge clk)
    begin : delayMatch16_process
      if (reset_x == 1'b1) begin
        delayMatch16_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch16_reg[0] <= stateControl_6;
          delayMatch16_reg[1] <= delayMatch16_reg[0];
        end
      end
    end

  assign stateControl_7 = delayMatch16_reg[1];



  assign enb_gated = stateControl_7 && enb;

  always @(posedge clk)
    begin : Delay9_process
      if (reset_x == 1'b1) begin
        Delay9_out1_re <= 16'sb0000000000000000;
        Delay9_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated) begin
          Delay9_out1_re <= FIR_Interpolator_out1_re;
          Delay9_out1_im <= FIR_Interpolator_out1_im;
        end
      end
    end



  assign stateControl_8 = 1'b1;



  always @(posedge clk)
    begin : delayMatch13_process
      if (reset_x == 1'b1) begin
        delayMatch13_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch13_reg[0] <= stateControl_8;
          delayMatch13_reg[1] <= delayMatch13_reg[0];
        end
      end
    end

  assign stateControl_9 = delayMatch13_reg[1];



  assign enb_gated_1 = stateControl_9 && enb;

  always @(posedge clk)
    begin : Delay6_process
      if (reset_x == 1'b1) begin
        Delay6_out1_re <= 16'sb0000000000000000;
        Delay6_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated_1) begin
          Delay6_out1_re <= Delay9_out1_re;
          Delay6_out1_im <= Delay9_out1_im;
        end
      end
    end



  assign stateControl_10 = 1'b1;



  always @(posedge clk)
    begin : delayMatch3_process
      if (reset_x == 1'b1) begin
        delayMatch3_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch3_reg[0] <= stateControl_10;
          delayMatch3_reg[1] <= delayMatch3_reg[0];
        end
      end
    end

  assign stateControl_11 = delayMatch3_reg[1];



  assign enb_gated_2 = stateControl_11 && enb;

  always @(posedge clk)
    begin : Delay11_process
      if (reset_x == 1'b1) begin
        Delay11_out1_re <= 16'sb0000000000000000;
        Delay11_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated_2) begin
          Delay11_out1_re <= Delay6_out1_re;
          Delay11_out1_im <= Delay6_out1_im;
        end
      end
    end



  assign stateControl_12 = 1'b1;



  always @(posedge clk)
    begin : delayMatch7_process
      if (reset_x == 1'b1) begin
        delayMatch7_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch7_reg[0] <= stateControl_12;
          delayMatch7_reg[1] <= delayMatch7_reg[0];
        end
      end
    end

  assign stateControl_13 = delayMatch7_reg[1];



  assign enb_gated_3 = stateControl_13 && enb;

  always @(posedge clk)
    begin : Delay17_process
      if (reset_x == 1'b1) begin
        for(Delay17_t_1 = 32'sd0; Delay17_t_1 <= 32'sd13; Delay17_t_1 = Delay17_t_1 + 32'sd1) begin
          Delay17_reg_re[Delay17_t_1] <= 16'sb0000000000000000;
          Delay17_reg_im[Delay17_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_gated_3) begin
          for(Delay17_t_0_1 = 32'sd0; Delay17_t_0_1 <= 32'sd13; Delay17_t_0_1 = Delay17_t_0_1 + 32'sd1) begin
            Delay17_reg_re[Delay17_t_0_1] <= Delay17_reg_next_re[Delay17_t_0_1];
            Delay17_reg_im[Delay17_t_0_1] <= Delay17_reg_next_im[Delay17_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay17_out1_re = Delay17_reg_re[13];
    Delay17_out1_im = Delay17_reg_im[13];
    Delay17_reg_next_re[0] = Delay11_out1_re;
    Delay17_reg_next_im[0] = Delay11_out1_im;

    for(Delay17_t_0_0 = 32'sd0; Delay17_t_0_0 <= 32'sd12; Delay17_t_0_0 = Delay17_t_0_0 + 32'sd1) begin
      Delay17_reg_next_re[Delay17_t_0_0 + 32'sd1] = Delay17_reg_re[Delay17_t_0_0];
      Delay17_reg_next_im[Delay17_t_0_0 + 32'sd1] = Delay17_reg_im[Delay17_t_0_0];
    end

  end



  assign stateControl_14 = 1'b1;



  always @(posedge clk)
    begin : delayMatch11_process
      if (reset_x == 1'b1) begin
        delayMatch11_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch11_reg[0] <= stateControl_14;
          delayMatch11_reg[1] <= delayMatch11_reg[0];
        end
      end
    end

  assign stateControl_15 = delayMatch11_reg[1];



  assign enb_gated_4 = stateControl_15 && enb;

  always @(posedge clk)
    begin : Delay4_process
      if (reset_x == 1'b1) begin
        Delay4_out1_re <= 16'sb0000000000000000;
        Delay4_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated_4) begin
          Delay4_out1_re <= Delay17_out1_re;
          Delay4_out1_im <= Delay17_out1_im;
        end
      end
    end



  assign data_out_re = Delay4_out1_re;

  assign data_out_im = Delay4_out1_im;

  assign stateControl_16 = 1'b1;



  always @(posedge clk)
    begin : delayMatch1_process
      if (reset_x == 1'b1) begin
        delayMatch1_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= stateControl_16;
          delayMatch1_reg[1] <= delayMatch1_reg[0];
        end
      end
    end

  assign stateControl_17 = delayMatch1_reg[1];



  assign enb_gated_5 = stateControl_17 && enb;

  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_reg <= {14{1'b0}};
      end
      else begin
        if (enb_gated_5) begin
          Delay1_reg[0] <= FIR_Interpolator_out2;
          Delay1_reg[32'sd13:32'sd1] <= Delay1_reg[32'sd12:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[13];



  assign Logical_Operator1_out1 = FIR_Interpolator_out2 & Delay1_out1;



  assign stateControl_18 = 1'b1;



  always @(posedge clk)
    begin : delayMatch15_process
      if (reset_x == 1'b1) begin
        delayMatch15_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch15_reg[0] <= stateControl_18;
          delayMatch15_reg[1] <= delayMatch15_reg[0];
        end
      end
    end

  assign stateControl_19 = delayMatch15_reg[1];



  assign enb_gated_6 = stateControl_19 && enb;

  always @(posedge clk)
    begin : Delay8_process
      if (reset_x == 1'b1) begin
        Delay8_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_6) begin
          Delay8_out1 <= Logical_Operator1_out1;
        end
      end
    end



  assign stateControl_20 = 1'b1;



  always @(posedge clk)
    begin : delayMatch4_process
      if (reset_x == 1'b1) begin
        delayMatch4_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch4_reg[0] <= stateControl_20;
          delayMatch4_reg[1] <= delayMatch4_reg[0];
        end
      end
    end

  assign stateControl_21 = delayMatch4_reg[1];



  assign enb_gated_7 = stateControl_21 && enb;

  always @(posedge clk)
    begin : Delay14_process
      if (reset_x == 1'b1) begin
        Delay14_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_7) begin
          Delay14_out1 <= Delay8_out1;
        end
      end
    end



  assign stateControl_22 = 1'b1;



  always @(posedge clk)
    begin : delayMatch5_process
      if (reset_x == 1'b1) begin
        delayMatch5_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch5_reg[0] <= stateControl_22;
          delayMatch5_reg[1] <= delayMatch5_reg[0];
        end
      end
    end

  assign stateControl_23 = delayMatch5_reg[1];



  assign enb_gated_8 = stateControl_23 && enb;

  always @(posedge clk)
    begin : Delay15_process
      if (reset_x == 1'b1) begin
        Delay15_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_8) begin
          Delay15_out1 <= Delay14_out1;
        end
      end
    end



  assign stateControl_24 = 1'b1;



  always @(posedge clk)
    begin : delayMatch6_process
      if (reset_x == 1'b1) begin
        delayMatch6_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch6_reg[0] <= stateControl_24;
          delayMatch6_reg[1] <= delayMatch6_reg[0];
        end
      end
    end

  assign stateControl_25 = delayMatch6_reg[1];



  assign enb_gated_9 = stateControl_25 && enb;

  tx_125_src_falling_edge_detector u_falling_edge_detector (.clk(clk),
                                                            .reset_x(reset_x),
                                                            .enb(enb),
                                                            .in(Delay8_out1),
                                                            .out(b)
                                                            );

  assign stateControl_26 = 1'b1;



  always @(posedge clk)
    begin : delayMatch2_process
      if (reset_x == 1'b1) begin
        delayMatch2_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= stateControl_26;
          delayMatch2_reg[1] <= delayMatch2_reg[0];
        end
      end
    end

  assign stateControl_27 = delayMatch2_reg[1];



  assign enb_gated_10 = stateControl_27 && enb;

  always @(posedge clk)
    begin : Delay10_process
      if (reset_x == 1'b1) begin
        Delay10_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_10) begin
          Delay10_out1 <= b;
        end
      end
    end



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 13
  assign count_step = 8'b00000001;



  assign count_from = 8'b00000000;



  assign count_reset = 8'b00000000;



  assign zero_1 = 1'b0;



  assign stateControl_28 = 1'b1;



  always @(posedge clk)
    begin : delayMatch14_process
      if (reset_x == 1'b1) begin
        delayMatch14_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch14_reg[0] <= stateControl_28;
          delayMatch14_reg[1] <= delayMatch14_reg[0];
        end
      end
    end

  assign stateControl_29 = delayMatch14_reg[1];



  assign enb_gated_11 = stateControl_29 && enb;

  assign stateControl_30 = 1'b1;



  always @(posedge clk)
    begin : delayMatch17_process
      if (reset_x == 1'b1) begin
        delayMatch17_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch17_reg[0] <= stateControl_30;
          delayMatch17_reg[1] <= delayMatch17_reg[0];
        end
      end
    end

  assign stateControl_31 = delayMatch17_reg[1];



  assign enb_gated_12 = stateControl_31 && enb;

  always @(posedge clk)
    begin : Unit_Delay_process
      if (reset_x == 1'b1) begin
        Unit_Delay_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_12) begin
          Unit_Delay_out1 <= count_enable;
        end
      end
    end



  assign range_hit = count > 8'b11111110;



  assign count_1 = count + count_step;



  assign count_value = (need_to_wrap == 1'b0 ? count_1 :
              count_from);



  assign count_2 = (count_enable == 1'b0 ? count :
              count_value);



  assign count_3 = (Delay10_out1 == 1'b0 ? count_2 :
              count_reset);



  always @(posedge clk)
    begin : HDL_Counter_process
      if (reset_x == 1'b1) begin
        count <= 8'b00000000;
      end
      else begin
        if (enb) begin
          count <= count_3;
        end
      end
    end



  assign need_to_wrap = count == 8'b00001101;



  assign count_hit = need_to_wrap | range_hit;



  assign HDL_Counter_out2 = (Delay10_out1 == 1'b0 ? count_hit :
              zero_1);



  always @(posedge clk)
    begin : Delay7_process
      if (reset_x == 1'b1) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_11) begin
          Delay7_out1 <= HDL_Counter_out2;
        end
      end
    end



  assign Logical_Operator4_out1 = Delay10_out1 | Delay7_out1;



  assign count_enable = (Logical_Operator4_out1 == 1'b0 ? Unit_Delay_out1 :
              Delay10_out1);



  assign stateControl_32 = 1'b1;



  always @(posedge clk)
    begin : delayMatch8_process
      if (reset_x == 1'b1) begin
        delayMatch8_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch8_reg[0] <= stateControl_32;
          delayMatch8_reg[1] <= delayMatch8_reg[0];
        end
      end
    end

  assign stateControl_33 = delayMatch8_reg[1];



  assign enb_gated_13 = stateControl_33 && enb;

  always @(posedge clk)
    begin : Delay16_process
      if (reset_x == 1'b1) begin
        Delay16_reg <= {14{1'b0}};
      end
      else begin
        if (enb_gated_9) begin
          Delay16_reg[0] <= Delay15_out1;
          Delay16_reg[32'sd13:32'sd1] <= Delay16_reg[32'sd12:32'sd0];
        end
      end
    end

  assign Delay16_out1 = Delay16_reg[13];



  always @(posedge clk)
    begin : Delay18_process
      if (reset_x == 1'b1) begin
        Delay18_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_13) begin
          Delay18_out1 <= count_enable;
        end
      end
    end



  assign Logical_Operator3_out1 =  ~ Delay18_out1;



  assign Logical_Operator2_out1 = Delay16_out1 & Logical_Operator3_out1;



  assign stateControl_35 = 1'b1;



  always @(posedge clk)
    begin : delayMatch_process
      if (reset_x == 1'b1) begin
        delayMatch_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= stateControl_35;
          delayMatch_reg[1] <= delayMatch_reg[0];
        end
      end
    end

  assign stateControl_36 = delayMatch_reg[1];



  assign enb_gated_14 = stateControl_36 && enb;

  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b1) begin
        Delay_out1 <= 1'b0;
      end
      else begin
        if (enb_gated_14) begin
          Delay_out1 <= Logical_Operator2_out1;
        end
      end
    end



  assign valid_out = Delay_out1;

endmodule  // tx_125_src_interpolator

