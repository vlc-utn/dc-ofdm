-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/full_tx_ip_fir_reduced_src_Final_Output.vhd
-- Created: 2024-08-10 09:35:20
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_tx_ip_fir_reduced_src_Final_Output
-- Source Path: HDLTx/full_tx/header_full/header_fec/Hc_12H_B14/Final Output
-- Hierarchy Level: 4
-- Model version: 4.90
-- 
-- Final output
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_tx_ip_fir_reduced_src_full_tx_pac.ALL;

ENTITY full_tx_ip_fir_reduced_src_Final_Output IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        reset                             :   IN    std_logic;  -- ufix1
        inputData                         :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        inputValid                        :   IN    std_logic;  -- ufix1
        parity                            :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        parityAddr                        :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
        parityValid                       :   IN    std_logic;  -- ufix1
        dataOut                           :   OUT   std_logic;  -- ufix1
        startOut                          :   OUT   std_logic;  -- ufix1
        endOut                            :   OUT   std_logic;  -- ufix1
        validOut                          :   OUT   std_logic  -- ufix1
        );
END full_tx_ip_fir_reduced_src_Final_Output;


ARCHITECTURE rtl OF full_tx_ip_fir_reduced_src_Final_Output IS

  -- Component Declarations
  COMPONENT full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic;  -- ufix1
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    USE ENTITY work.full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL valid_reg                        : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL validReg                         : std_logic;  -- ufix1
  SIGNAL const0                           : std_logic;  -- ufix1
  SIGNAL validTmp                         : std_logic;  -- ufix1
  SIGNAL inValidNeg                       : std_logic;  -- ufix1
  SIGNAL parityStart                      : std_logic;  -- ufix1
  SIGNAL idxOut                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL index_reg                        : vector_of_unsigned4(0 TO 2);  -- ufix4 [3]
  SIGNAL parityIdx                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL rdAddr                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL pAddr                            : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL parityRAM                        : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL readParity_rdValid               : std_logic;
  SIGNAL readParity_rdAddr                : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_idxCount              : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_jdxCount              : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_rdCount               : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_pRead                 : std_logic;
  SIGNAL readParity_rdValid_next          : std_logic;
  SIGNAL readParity_rdAddr_next           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_idxCount_next         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_jdxCount_next         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_rdCount_next          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL readParity_pRead_next            : std_logic;
  SIGNAL inputData_1                      : std_logic;  -- ufix1
  SIGNAL parityData                       : std_logic;  -- ufix1
  SIGNAL pValid                           : std_logic;  -- ufix1
  SIGNAL data_reg                         : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL dataReg                          : std_logic;  -- ufix1
  SIGNAL dataTmp                          : std_logic;  -- ufix1
  SIGNAL index_reg_1                      : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL pValidReg                        : std_logic;  -- ufix1
  SIGNAL pValidNeg                        : std_logic;  -- ufix1
  SIGNAL validReg1                        : std_logic;  -- ufix1
  SIGNAL validRegNeg                      : std_logic;  -- ufix1
  SIGNAL outputController_validReg        : std_logic;
  SIGNAL outputController_endO            : std_logic;
  SIGNAL startO                           : std_logic;  -- ufix1
  SIGNAL endO                             : std_logic;  -- ufix1
  SIGNAL validO                           : std_logic;  -- ufix1
  SIGNAL dataO                            : std_logic;  -- ufix1

BEGIN
  u_Parity_RAM_singlebit_bank13 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(13),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(13)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank12 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(12),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(12)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank11 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(11),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(11)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank10 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(10),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(10)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank9 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(9),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(9)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank8 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(8),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(8)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank7 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(7),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(7)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank6 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(6),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(6)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank5 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(5),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(5)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank4 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(4),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(4)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank3 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(3),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(3)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank2 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(2),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(2)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank1 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(1),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(1)  -- ufix1
              );

  u_Parity_RAM_singlebit_bank0 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => parity(0),  -- ufix1
              wr_addr => parityAddr,
              wr_en => parityValid,  -- ufix1
              rd_addr => std_logic_vector(rdAddr),
              dout => parityRAM(0)  -- ufix1
              );

  valid_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        valid_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        valid_reg(0) <= inputValid;
        valid_reg(2 DOWNTO 1) <= valid_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS valid_process;

  validReg <= valid_reg(2);

  const0 <= '0';

  valid_in_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validTmp <= '0';
      ELSIF enb = '1' THEN
        validTmp <= inputValid;
      END IF;
    END IF;
  END PROCESS valid_in_process;


  inValidNeg <=  NOT inputValid;

  parityStart <= validTmp AND inValidNeg;

  index_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        index_reg <= (OTHERS => to_unsigned(16#1#, 4));
      ELSIF enb = '1' THEN
        index_reg(0) <= idxOut;
        index_reg(1 TO 2) <= index_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS index_process;

  parityIdx <= index_reg(2);

  rdaddr_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdAddr <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        rdAddr <= pAddr;
      END IF;
    END IF;
  END PROCESS rdaddr_1_process;



  readParity_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        readParity_rdValid <= '0';
        readParity_rdCount <= to_unsigned(16#1#, 4);
        readParity_rdAddr <= to_unsigned(16#1#, 4);
        readParity_idxCount <= to_unsigned(16#0#, 4);
        readParity_jdxCount <= to_unsigned(16#0#, 4);
        readParity_pRead <= '0';
      ELSIF enb = '1' THEN
        readParity_rdValid <= readParity_rdValid_next;
        readParity_rdAddr <= readParity_rdAddr_next;
        readParity_idxCount <= readParity_idxCount_next;
        readParity_jdxCount <= readParity_jdxCount_next;
        readParity_rdCount <= readParity_rdCount_next;
        readParity_pRead <= readParity_pRead_next;
      END IF;
    END IF;
  END PROCESS readParity_process;

  readParity_output : PROCESS (inputData, inputValid, parityIdx, parityRAM, parityStart, readParity_idxCount,
       readParity_jdxCount, readParity_pRead, readParity_rdAddr,
       readParity_rdCount, readParity_rdValid, reset)
    VARIABLE pRead_temp : std_logic;
    VARIABLE add_temp : unsigned(4 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(4 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
  BEGIN
    pRead_temp := readParity_pRead;
    readParity_rdValid_next <= readParity_rdValid;
    readParity_rdAddr_next <= readParity_rdAddr;
    readParity_idxCount_next <= readParity_idxCount;
    readParity_jdxCount_next <= readParity_jdxCount;
    readParity_rdCount_next <= readParity_rdCount;
    add_temp := resize(readParity_idxCount, 5) + to_unsigned(16#01#, 5);
    sub_cast := signed(resize(add_temp, 32));
    inputData_1 <= inputData(to_integer(sub_cast - 1));
    add_temp_0 := resize(parityIdx, 5) + to_unsigned(16#01#, 5);
    sub_cast_0 := signed(resize(add_temp_0, 32));
    parityData <= parityRAM(to_integer(sub_cast_0 - 1));
    IF reset /= '0' THEN 
      pRead_temp := '0';
    ELSIF parityStart /= '0' THEN 
      pRead_temp := '1';
    END IF;
    IF reset /= '0' THEN 
      readParity_idxCount_next <= to_unsigned(16#0#, 4);
    ELSIF inputValid /= '0' THEN 
      IF readParity_idxCount = to_unsigned(16#D#, 4) THEN 
        readParity_idxCount_next <= to_unsigned(16#0#, 4);
      ELSE 
        readParity_idxCount_next <= readParity_idxCount + to_unsigned(16#1#, 4);
      END IF;
    END IF;
    IF reset /= '0' THEN 
      readParity_rdValid_next <= '0';
      readParity_rdAddr_next <= to_unsigned(16#1#, 4);
      readParity_rdCount_next <= to_unsigned(16#1#, 4);
      readParity_jdxCount_next <= to_unsigned(16#0#, 4);
    ELSIF pRead_temp = '1' THEN 
      IF readParity_rdCount = to_unsigned(16#D#, 4) THEN 
        readParity_rdAddr_next <= readParity_rdCount;
        readParity_rdValid_next <= '0';
        pRead_temp := '0';
      ELSE 
        readParity_rdValid_next <= '1';
        readParity_rdAddr_next <= readParity_rdCount;
      END IF;
      IF readParity_jdxCount = to_unsigned(16#D#, 4) THEN 
        readParity_jdxCount_next <= to_unsigned(16#0#, 4);
        readParity_rdCount_next <= readParity_rdCount + to_unsigned(16#1#, 4);
      ELSE 
        readParity_jdxCount_next <= readParity_jdxCount + to_unsigned(16#1#, 4);
      END IF;
    END IF;
    pValid <= readParity_rdValid;
    pAddr <= readParity_rdAddr;
    idxOut <= readParity_jdxCount;
    readParity_pRead_next <= pRead_temp;
  END PROCESS readParity_output;


  data_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        data_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        data_reg(0) <= inputData_1;
        data_reg(2 DOWNTO 1) <= data_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS data_process;

  dataReg <= data_reg(2);

  
  dataTmp <= const0 WHEN validReg = '0' ELSE
      dataReg;

  index_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        index_reg_1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        index_reg_1(0) <= pValid;
        index_reg_1(1) <= index_reg_1(0);
      END IF;
    END IF;
  END PROCESS index_1_process;

  pValidReg <= index_reg_1(1);

  pValidNeg <=  NOT pValidReg;

  valid_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validReg1 <= '0';
      ELSIF enb = '1' THEN
        validReg1 <= validReg;
      END IF;
    END IF;
  END PROCESS valid_1_process;


  validRegNeg <=  NOT validReg1;

  outputController_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        startO <= '0';
        validO <= '0';
        dataO <= '0';
        outputController_validReg <= '0';
      ELSIF enb = '1' THEN
        outputController_validReg <= pValidReg;
        validO <= hdlcoder_to_stdlogic((validReg /= '0') OR (pValidReg /= '0'));
        startO <= hdlcoder_to_stdlogic((validReg /= '0') AND (validRegNeg /= '0'));
        IF reset /= '0' THEN 
          dataO <= '0';
        ELSIF validReg /= '0' THEN 
          dataO <= dataTmp;
        ELSIF pValidReg /= '0' THEN 
          dataO <= parityData;
        ELSE 
          dataO <= '0';
        END IF;
      END IF;
    END IF;
  END PROCESS outputController_process;

  outputController_endO <= pValidNeg AND outputController_validReg;
  endO <= outputController_endO;

  dataOut_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dataOut <= '0';
      ELSIF enb = '1' THEN
        dataOut <= dataO;
      END IF;
    END IF;
  END PROCESS dataOut_1_process;


  startOut_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        startOut <= '0';
      ELSIF enb = '1' THEN
        startOut <= startO;
      END IF;
    END IF;
  END PROCESS startOut_1_process;


  endOut_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        endOut <= '0';
      ELSIF enb = '1' THEN
        endOut <= endO;
      END IF;
    END IF;
  END PROCESS endOut_1_process;


  validOut_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validOut <= '0';
      ELSIF enb = '1' THEN
        validOut <= validO;
      END IF;
    END IF;
  END PROCESS validOut_1_process;


END rtl;

