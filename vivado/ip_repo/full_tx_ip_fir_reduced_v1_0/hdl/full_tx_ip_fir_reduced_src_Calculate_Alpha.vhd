-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/full_tx_ip_fir_reduced_src_Calculate_Alpha.vhd
-- Created: 2024-08-10 09:35:20
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_tx_ip_fir_reduced_src_Calculate_Alpha
-- Source Path: HDLTx/full_tx/header_full/header_fec/Hc_12H_B14/Calculate Alpha
-- Hierarchy Level: 4
-- Model version: 4.90
-- 
-- Calculate Alpha
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_tx_ip_fir_reduced_src_full_tx_pac.ALL;

ENTITY full_tx_ip_fir_reduced_src_Calculate_Alpha IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        data                              :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        reset                             :   IN    std_logic;  -- ufix1
        encEnable                         :   IN    std_logic;  -- ufix1
        alpha                             :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
        alphaValid                        :   OUT   std_logic;  -- ufix1
        alphaAddr                         :   OUT   std_logic_vector(3 DOWNTO 0);  -- ufix4
        columnVal                         :   OUT   std_logic_vector(4 DOWNTO 0);  -- ufix5
        parity1                           :   OUT   std_logic_vector(13 DOWNTO 0)  -- ufix1 [14]
        );
END full_tx_ip_fir_reduced_src_Calculate_Alpha;


ARCHITECTURE rtl OF full_tx_ip_fir_reduced_src_Calculate_Alpha IS

  -- Component Declarations
  COMPONENT full_tx_ip_fir_reduced_src_BarrelRotator
    PORT( data                            :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
          shift                           :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          shiftData                       :   OUT   std_logic_vector(13 DOWNTO 0)  -- ufix1 [14]
          );
  END COMPONENT;

  COMPONENT full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic;  -- ufix1
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_tx_ip_fir_reduced_src_BarrelRotator
    USE ENTITY work.full_tx_ip_fir_reduced_src_BarrelRotator(rtl);

  FOR ALL : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    USE ENTITY work.full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block(rtl);

  -- Constants
  CONSTANT alphaController_data           : vector_of_signed8(0 TO 11) := 
    (to_signed(16#06#, 8), to_signed(16#07#, 8), to_signed(16#07#, 8), to_signed(16#06#, 8), to_signed(16#06#, 8),
     to_signed(16#06#, 8), to_signed(16#06#, 8), to_signed(16#06#, 8), to_signed(16#07#, 8), to_signed(16#06#, 8),
     to_signed(16#07#, 8), to_signed(16#06#, 8));  -- int8 [12]
  CONSTANT alphacontroller_data_0         : vector_of_signed8(0 TO 12) := 
    (to_signed(16#01#, 8), to_signed(16#02#, 8), to_signed(16#03#, 8), to_signed(16#04#, 8), to_signed(16#05#, 8),
     to_signed(16#06#, 8), to_signed(16#07#, 8), to_signed(16#08#, 8), to_signed(16#09#, 8), to_signed(16#0A#, 8),
     to_signed(16#0B#, 8), to_signed(16#0C#, 8), to_signed(16#01#, 8));  -- int8 [13]
  CONSTANT Shift_LUT_data                 : vector_of_unsigned4(0 TO 83) := 
    (to_unsigned(16#6#, 4), to_unsigned(16#0#, 4), to_unsigned(16#9#, 4), to_unsigned(16#1#, 4),
     to_unsigned(16#4#, 4), to_unsigned(16#3#, 4), to_unsigned(16#0#, 4), to_unsigned(16#9#, 4),
     to_unsigned(16#9#, 4), to_unsigned(16#5#, 4), to_unsigned(16#8#, 4), to_unsigned(16#A#, 4),
     to_unsigned(16#9#, 4), to_unsigned(16#3#, 4), to_unsigned(16#B#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#8#, 4), to_unsigned(16#0#, 4), to_unsigned(16#6#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#1#, 4), to_unsigned(16#8#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#6#, 4), to_unsigned(16#C#, 4), to_unsigned(16#D#, 4), to_unsigned(16#7#, 4),
     to_unsigned(16#2#, 4), to_unsigned(16#8#, 4), to_unsigned(16#5#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#D#, 4), to_unsigned(16#4#, 4), to_unsigned(16#9#, 4), to_unsigned(16#3#, 4),
     to_unsigned(16#2#, 4), to_unsigned(16#1#, 4), to_unsigned(16#2#, 4), to_unsigned(16#B#, 4),
     to_unsigned(16#5#, 4), to_unsigned(16#1#, 4), to_unsigned(16#D#, 4), to_unsigned(16#1#, 4),
     to_unsigned(16#C#, 4), to_unsigned(16#5#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#4#, 4), to_unsigned(16#3#, 4), to_unsigned(16#C#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#8#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#4#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4),
     to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4), to_unsigned(16#0#, 4));  -- ufix4 [84]
  CONSTANT Column_LUT_data                : vector_of_unsigned5(0 TO 83) := 
    (to_unsigned(16#04#, 5), to_unsigned(16#02#, 5), to_unsigned(16#02#, 5), to_unsigned(16#01#, 5),
     to_unsigned(16#04#, 5), to_unsigned(16#02#, 5), to_unsigned(16#04#, 5), to_unsigned(16#04#, 5),
     to_unsigned(16#01#, 5), to_unsigned(16#02#, 5), to_unsigned(16#04#, 5), to_unsigned(16#01#, 5),
     to_unsigned(16#07#, 5), to_unsigned(16#06#, 5), to_unsigned(16#03#, 5), to_unsigned(16#04#, 5),
     to_unsigned(16#05#, 5), to_unsigned(16#03#, 5), to_unsigned(16#05#, 5), to_unsigned(16#08#, 5),
     to_unsigned(16#02#, 5), to_unsigned(16#05#, 5), to_unsigned(16#07#, 5), to_unsigned(16#02#, 5),
     to_unsigned(16#08#, 5), to_unsigned(16#08#, 5), to_unsigned(16#06#, 5), to_unsigned(16#07#, 5),
     to_unsigned(16#0B#, 5), to_unsigned(16#06#, 5), to_unsigned(16#0A#, 5), to_unsigned(16#0B#, 5),
     to_unsigned(16#03#, 5), to_unsigned(16#06#, 5), to_unsigned(16#0A#, 5), to_unsigned(16#06#, 5),
     to_unsigned(16#0B#, 5), to_unsigned(16#09#, 5), to_unsigned(16#09#, 5), to_unsigned(16#0B#, 5),
     to_unsigned(16#0C#, 5), to_unsigned(16#09#, 5), to_unsigned(16#0B#, 5), to_unsigned(16#0C#, 5),
     to_unsigned(16#06#, 5), to_unsigned(16#09#, 5), to_unsigned(16#0B#, 5), to_unsigned(16#09#, 5),
     to_unsigned(16#0D#, 5), to_unsigned(16#0C#, 5), to_unsigned(16#0A#, 5), to_unsigned(16#10#, 5),
     to_unsigned(16#11#, 5), to_unsigned(16#12#, 5), to_unsigned(16#13#, 5), to_unsigned(16#14#, 5),
     to_unsigned(16#09#, 5), to_unsigned(16#16#, 5), to_unsigned(16#0D#, 5), to_unsigned(16#0D#, 5),
     to_unsigned(16#0E#, 5), to_unsigned(16#0E#, 5), to_unsigned(16#0F#, 5), to_unsigned(16#11#, 5),
     to_unsigned(16#12#, 5), to_unsigned(16#13#, 5), to_unsigned(16#14#, 5), to_unsigned(16#15#, 5),
     to_unsigned(16#15#, 5), to_unsigned(16#17#, 5), to_unsigned(16#17#, 5), to_unsigned(16#18#, 5),
     to_unsigned(16#00#, 5), to_unsigned(16#0F#, 5), to_unsigned(16#10#, 5), to_unsigned(16#00#, 5),
     to_unsigned(16#00#, 5), to_unsigned(16#00#, 5), to_unsigned(16#00#, 5), to_unsigned(16#00#, 5),
     to_unsigned(16#16#, 5), to_unsigned(16#00#, 5), to_unsigned(16#18#, 5), to_unsigned(16#00#, 5));  -- ufix5 [84]

  -- Signals
  SIGNAL alphaController_countLayer       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaController_layerDone        : std_logic;
  SIGNAL alphaController_idxCount         : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL alphaController_xIdx             : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaController_yIdx             : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL alphaController_encEnb           : std_logic;
  SIGNAL alphaController_alphaEnb         : std_logic;
  SIGNAL alphaController_alphaDone        : std_logic;
  SIGNAL alphaController_rdCount          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaController_countLayer_next  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaController_layerDone_next   : std_logic;
  SIGNAL alphaController_idxCount_next    : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL alphaController_xIdx_next        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaController_yIdx_next        : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL alphaController_encEnb_next      : std_logic;
  SIGNAL alphaController_alphaEnb_next    : std_logic;
  SIGNAL alphaController_alphaDone_next   : std_logic;
  SIGNAL alphaController_rdCount_next     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL countLayer                       : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL xIndex                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL yIndex                           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL layerDone                        : std_logic;  -- ufix1
  SIGNAL rdValid                          : std_logic;  -- ufix1
  SIGNAL rdAddr                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL aValid                           : std_logic;  -- ufix1
  SIGNAL rdvalid_register_reg             : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL rdValidReg                       : std_logic;  -- ufix1
  SIGNAL rdValidReg1                      : std_logic;  -- ufix1
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL zeroData                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL const1                           : std_logic;  -- ufix1
  SIGNAL alpha_sub_cast                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL xIdx                             : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alpha_sub_cast_1                 : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL yIdx                             : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Shift_LUT_add_cast               : signed(31 DOWNTO 0);  -- int32
  SIGNAL Shift_LUT_cast                   : signed(5 DOWNTO 0);  -- sfix6
  SIGNAL Shift_LUT_mul_temp               : signed(37 DOWNTO 0);  -- sfix38
  SIGNAL sVal                             : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL rdData                           : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL shift_register_reg               : vector_of_unsigned4(0 TO 2);  -- ufix4 [3]
  SIGNAL shiftVal                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL sData                            : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL sDataReg                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL sDataTmp                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL shiftData                        : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL shiftData_0                      : std_logic;  -- ufix1
  SIGNAL layerdone_register_reg           : std_logic_vector(3 DOWNTO 0);  -- ufix1 [4]
  SIGNAL layerDoneReg                     : std_logic;  -- ufix1
  SIGNAL encEnb_neg                       : std_logic;  -- ufix1
  SIGNAL encEnbNegReg                     : std_logic;  -- ufix1
  SIGNAL encEnbTmp                        : std_logic;  -- ufix1
  SIGNAL encenb_tmp_register_reg          : std_logic_vector(4 DOWNTO 0);  -- ufix1 [5]
  SIGNAL encEnbTmp1                       : std_logic;  -- ufix1
  SIGNAL wrEnb                            : std_logic;  -- ufix1
  SIGNAL wrEnbReg                         : std_logic;  -- ufix1
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL const1Reg                        : std_logic;  -- ufix1
  SIGNAL shiftData_1                      : std_logic;  -- ufix1
  SIGNAL shiftData_2                      : std_logic;  -- ufix1
  SIGNAL shiftData_3                      : std_logic;  -- ufix1
  SIGNAL shiftData_4                      : std_logic;  -- ufix1
  SIGNAL shiftData_5                      : std_logic;  -- ufix1
  SIGNAL shiftData_6                      : std_logic;  -- ufix1
  SIGNAL shiftData_7                      : std_logic;  -- ufix1
  SIGNAL shiftData_8                      : std_logic;  -- ufix1
  SIGNAL shiftData_9                      : std_logic;  -- ufix1
  SIGNAL shiftData_10                     : std_logic;  -- ufix1
  SIGNAL shiftData_11                     : std_logic;  -- ufix1
  SIGNAL shiftData_12                     : std_logic;  -- ufix1
  SIGNAL shiftData_13                     : std_logic;  -- ufix1
  SIGNAL switchData                       : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL switchData_13                    : std_logic;  -- ufix1
  SIGNAL shiftData_13_1                   : std_logic;  -- ufix1
  SIGNAL switchData_12                    : std_logic;  -- ufix1
  SIGNAL shiftData_12_1                   : std_logic;  -- ufix1
  SIGNAL switchData_11                    : std_logic;  -- ufix1
  SIGNAL shiftData_11_1                   : std_logic;  -- ufix1
  SIGNAL switchData_10                    : std_logic;  -- ufix1
  SIGNAL shiftData_10_1                   : std_logic;  -- ufix1
  SIGNAL switchData_9                     : std_logic;  -- ufix1
  SIGNAL shiftData_9_1                    : std_logic;  -- ufix1
  SIGNAL switchData_8                     : std_logic;  -- ufix1
  SIGNAL shiftData_8_1                    : std_logic;  -- ufix1
  SIGNAL switchData_7                     : std_logic;  -- ufix1
  SIGNAL shiftData_7_1                    : std_logic;  -- ufix1
  SIGNAL switchData_6                     : std_logic;  -- ufix1
  SIGNAL shiftData_6_1                    : std_logic;  -- ufix1
  SIGNAL switchData_5                     : std_logic;  -- ufix1
  SIGNAL shiftData_5_1                    : std_logic;  -- ufix1
  SIGNAL switchData_4                     : std_logic;  -- ufix1
  SIGNAL shiftData_4_1                    : std_logic;  -- ufix1
  SIGNAL switchData_3                     : std_logic;  -- ufix1
  SIGNAL shiftData_3_1                    : std_logic;  -- ufix1
  SIGNAL switchData_2                     : std_logic;  -- ufix1
  SIGNAL shiftData_2_1                    : std_logic;  -- ufix1
  SIGNAL switchData_1                     : std_logic;  -- ufix1
  SIGNAL shiftData_1_1                    : std_logic;  -- ufix1
  SIGNAL xorData                          : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL alpha_switch_delay               : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL xorDataReg                       : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL switchData_0                     : std_logic;  -- ufix1
  SIGNAL shiftData_0_1                    : std_logic;  -- ufix1
  SIGNAL wrData                           : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL wraddr_register_reg              : vector_of_unsigned4(0 TO 5);  -- ufix4 [6]
  SIGNAL wrAddr                           : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL rdaddr_register_reg              : vector_of_unsigned4(0 TO 4);  -- ufix4 [5]
  SIGNAL rdAddrReg                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL alphaTmp                         : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL alphavalid_register_reg          : std_logic_vector(4 DOWNTO 0);  -- ufix1 [5]
  SIGNAL alphaAddr_tmp                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Column_LUT_add_cast              : signed(31 DOWNTO 0);  -- int32
  SIGNAL Column_LUT_cast                  : signed(5 DOWNTO 0);  -- sfix6
  SIGNAL Column_LUT_mul_temp              : signed(37 DOWNTO 0);  -- sfix38
  SIGNAL cVal                             : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL columnVal_tmp                    : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL shiftData_0_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_1_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_2_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_3_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_4_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_5_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_6_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_7_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_8_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_9_2                    : std_logic;  -- ufix1
  SIGNAL shiftData_10_2                   : std_logic;  -- ufix1
  SIGNAL shiftData_11_2                   : std_logic;  -- ufix1
  SIGNAL shiftData_12_2                   : std_logic;  -- ufix1
  SIGNAL shiftData_13_2                   : std_logic;  -- ufix1
  SIGNAL xorDataParityReg                 : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL xorDataParityReg_13              : std_logic;  -- ufix1
  SIGNAL shiftData_13_3                   : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_12              : std_logic;  -- ufix1
  SIGNAL shiftData_12_3                   : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_11              : std_logic;  -- ufix1
  SIGNAL shiftData_11_3                   : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_10              : std_logic;  -- ufix1
  SIGNAL shiftData_10_3                   : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_9               : std_logic;  -- ufix1
  SIGNAL shiftData_9_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_8               : std_logic;  -- ufix1
  SIGNAL shiftData_8_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_7               : std_logic;  -- ufix1
  SIGNAL shiftData_7_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_6               : std_logic;  -- ufix1
  SIGNAL shiftData_6_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_5               : std_logic;  -- ufix1
  SIGNAL shiftData_5_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_4               : std_logic;  -- ufix1
  SIGNAL shiftData_4_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_3               : std_logic;  -- ufix1
  SIGNAL shiftData_3_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_2               : std_logic;  -- ufix1
  SIGNAL shiftData_2_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParityReg_1               : std_logic;  -- ufix1
  SIGNAL shiftData_1_3                    : std_logic;  -- ufix1
  SIGNAL xorDataParity1                   : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL alpha_switch_delay_1             : std_logic_vector(13 DOWNTO 0);  -- ufix1 [14]
  SIGNAL xorDataParityReg_0               : std_logic;  -- ufix1
  SIGNAL shiftData_0_3                    : std_logic;  -- ufix1

BEGIN
  u_Barrel_Rotator_Unit : full_tx_ip_fir_reduced_src_BarrelRotator
    PORT MAP( data => rdData,  -- ufix1 [14]
              shift => std_logic_vector(shiftVal),  -- ufix4
              shiftData => sData  -- ufix1 [14]
              );

  u_Alpha_RAM_singlebit_bank0 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(0),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(0)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank1 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(1),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(1)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank2 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(2),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(2)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank3 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(3),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(3)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank4 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(4),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(4)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank5 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(5),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(5)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank6 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(6),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(6)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank7 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(7),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(7)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank8 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(8),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(8)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank9 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(9),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(9)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank10 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(10),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(10)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank11 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(11),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(11)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank12 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(12),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(12)  -- ufix1
              );

  u_Alpha_RAM_singlebit_bank13 : full_tx_ip_fir_reduced_src_SimpleDualPortRAM_singlebit_block
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 1
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => wrData(13),  -- ufix1
              wr_addr => std_logic_vector(wrAddr),
              wr_en => wrEnbReg,  -- ufix1
              rd_addr => std_logic_vector(rdAddrReg),
              dout => alphaTmp(13)  -- ufix1
              );

  alphaController_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alphaController_countLayer <= to_unsigned(16#1#, 4);
        alphaController_layerDone <= '0';
        alphaController_idxCount <= to_unsigned(16#01#, 5);
        alphaController_encEnb <= '0';
        alphaController_xIdx <= to_unsigned(16#1#, 4);
        alphaController_yIdx <= to_unsigned(16#01#, 5);
        alphaController_alphaEnb <= '0';
        alphaController_alphaDone <= '0';
        alphaController_rdCount <= to_unsigned(16#1#, 4);
      ELSIF enb = '1' THEN
        alphaController_countLayer <= alphaController_countLayer_next;
        alphaController_layerDone <= alphaController_layerDone_next;
        alphaController_idxCount <= alphaController_idxCount_next;
        alphaController_xIdx <= alphaController_xIdx_next;
        alphaController_yIdx <= alphaController_yIdx_next;
        alphaController_encEnb <= alphaController_encEnb_next;
        alphaController_alphaEnb <= alphaController_alphaEnb_next;
        alphaController_alphaDone <= alphaController_alphaDone_next;
        alphaController_rdCount <= alphaController_rdCount_next;
      END IF;
    END IF;
  END PROCESS alphaController_process;

  alphaController_output : PROCESS (alphaController_alphaDone, alphaController_alphaEnb,
       alphaController_countLayer, alphaController_encEnb,
       alphaController_idxCount, alphaController_layerDone,
       alphaController_rdCount, alphaController_xIdx, alphaController_yIdx,
       encEnable, reset)
    VARIABLE countIdx : unsigned(4 DOWNTO 0);
    VARIABLE countLayer_temp : unsigned(3 DOWNTO 0);
    VARIABLE idxCount_temp : unsigned(4 DOWNTO 0);
    VARIABLE encEnb_temp : std_logic;
    VARIABLE alphaDone_temp : std_logic;
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
  BEGIN
    countLayer_temp := alphaController_countLayer;
    idxCount_temp := alphaController_idxCount;
    encEnb_temp := alphaController_encEnb;
    alphaDone_temp := alphaController_alphaDone;
    alphaController_layerDone_next <= alphaController_layerDone;
    alphaController_rdCount_next <= alphaController_rdCount;
    sub_cast := signed(resize(alphaController_countLayer, 32));
    countIdx := unsigned(alphaController_data(to_integer(sub_cast - 1))(4 DOWNTO 0));
    IF reset /= '0' THEN 
      countLayer_temp := to_unsigned(16#1#, 4);
      encEnb_temp := '1';
      alphaController_layerDone_next <= '0';
      idxCount_temp := to_unsigned(16#01#, 5);
      alphaDone_temp := '0';
    ELSIF alphaController_alphaEnb = '1' THEN 
      IF alphaController_idxCount = countIdx THEN 
        IF alphaController_countLayer = to_unsigned(16#C#, 4) THEN 
          countLayer_temp := to_unsigned(16#1#, 4);
          alphaController_layerDone_next <= '1';
          idxCount_temp := to_unsigned(16#01#, 5);
          encEnb_temp := '0';
          alphaDone_temp := '1';
        ELSE 
          countLayer_temp := alphaController_countLayer + to_unsigned(16#1#, 4);
          alphaController_layerDone_next <= '1';
          idxCount_temp := to_unsigned(16#01#, 5);
          alphaDone_temp := '0';
        END IF;
      ELSE 
        idxCount_temp := alphaController_idxCount + to_unsigned(16#01#, 5);
        alphaController_layerDone_next <= '0';
        alphaDone_temp := '0';
      END IF;
    END IF;
    alphaController_xIdx_next <= countLayer_temp;
    alphaController_yIdx_next <= idxCount_temp;
    IF reset /= '0' THEN 
      alphaController_alphaEnb_next <= '0';
    ELSE 
      alphaController_alphaEnb_next <= encEnable AND encEnb_temp;
    END IF;
    IF reset /= '0' THEN 
      alphaController_rdCount_next <= to_unsigned(16#1#, 4);
      alphaDone_temp := '0';
    ELSIF alphaDone_temp = '1' THEN 
      IF alphaController_rdCount = to_unsigned(16#D#, 4) THEN 
        alphaDone_temp := '0';
      ELSE 
        alphaController_rdCount_next <= alphaController_rdCount + to_unsigned(16#1#, 4);
      END IF;
    END IF;
    countLayer <= alphaController_countLayer;
    xIndex <= alphaController_xIdx;
    yIndex <= alphaController_yIdx;
    layerDone <= alphaController_layerDone;
    rdValid <= alphaController_alphaEnb;
    sub_cast_0 := signed(resize(alphaController_rdCount, 32));
    rdAddr <= unsigned(alphacontroller_data_0(to_integer(sub_cast_0 - 1))(3 DOWNTO 0));
    aValid <= alphaController_alphaDone;
    alphaController_countLayer_next <= countLayer_temp;
    alphaController_idxCount_next <= idxCount_temp;
    alphaController_encEnb_next <= encEnb_temp;
    alphaController_alphaDone_next <= alphaDone_temp;
  END PROCESS alphaController_output;


  rdvalid_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdvalid_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        rdvalid_register_reg(0) <= rdValid;
        rdvalid_register_reg(2 DOWNTO 1) <= rdvalid_register_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS rdvalid_register_process;

  rdValidReg <= rdvalid_register_reg(2);

  rdValid_register_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdValidReg1 <= '0';
      ELSIF enb = '1' THEN
        rdValidReg1 <= rdValidReg;
      END IF;
    END IF;
  END PROCESS rdValid_register_1_process;


  
  switch_compare_1 <= '1' WHEN rdValidReg1 > '0' ELSE
      '0';

  zeroData <= (OTHERS => '0');

  const1 <= '1';

  alpha_sub_cast <= '0' & '0' & '0' & const1;
  xIdx <= xIndex - alpha_sub_cast;

  alpha_sub_cast_1 <= '0' & '0' & '0' & '0' & const1;
  yIdx <= yIndex - alpha_sub_cast_1;

  Shift_LUT_add_cast <= signed(resize(xIdx, 32));
  Shift_LUT_cast <= signed(resize(yIdx, 6));
  Shift_LUT_mul_temp <= Shift_LUT_cast * to_signed(16#0000000C#, 32);
  sVal <= Shift_LUT_data(to_integer(Shift_LUT_add_cast + resize(Shift_LUT_mul_temp, 32)));

  data_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdData <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        rdData <= data;
      END IF;
    END IF;
  END PROCESS data_register_process;


  shift_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        shift_register_reg <= (OTHERS => to_unsigned(16#0#, 4));
      ELSIF enb = '1' THEN
        shift_register_reg(0) <= sVal;
        shift_register_reg(1 TO 2) <= shift_register_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS shift_register_process;

  shiftVal <= shift_register_reg(2);

  shift_register_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        sDataReg <= (OTHERS => '0');
      ELSIF enb = '1' AND rdValidReg = '1' THEN
        sDataReg <= sData;
      END IF;
    END IF;
  END PROCESS shift_register_1_process;


  
  sDataTmp <= zeroData WHEN switch_compare_1 = '0' ELSE
      sDataReg;

  shift_register_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        shiftData <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        shiftData <= sDataTmp;
      END IF;
    END IF;
  END PROCESS shift_register_2_process;


  shiftData_0 <= shiftData(0);

  layerdone_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        layerdone_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        layerdone_register_reg(0) <= layerDone;
        layerdone_register_reg(3 DOWNTO 1) <= layerdone_register_reg(2 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS layerdone_register_process;

  layerDoneReg <= layerdone_register_reg(3);

  encEnb_neg <=  NOT encEnable;

  encenb_reg_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        encEnbNegReg <= '0';
      ELSIF enb = '1' THEN
        encEnbNegReg <= encEnb_neg;
      END IF;
    END IF;
  END PROCESS encenb_reg_register_process;


  encEnbTmp <= encEnbNegReg AND encEnable;

  encenb_tmp_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        encenb_tmp_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        encenb_tmp_register_reg(0) <= encEnbTmp;
        encenb_tmp_register_reg(4 DOWNTO 1) <= encenb_tmp_register_reg(3 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS encenb_tmp_register_process;

  encEnbTmp1 <= encenb_tmp_register_reg(4);

  wrEnb <= layerDoneReg OR encEnbTmp1;

  wrenb_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrEnbReg <= '0';
      ELSIF enb = '1' THEN
        wrEnbReg <= wrEnb;
      END IF;
    END IF;
  END PROCESS wrenb_register_process;


  
  switch_compare_1_1 <= '1' WHEN wrEnbReg > '0' ELSE
      '0';

  const_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        const1Reg <= '0';
      ELSIF enb = '1' THEN
        const1Reg <= const1;
      END IF;
    END IF;
  END PROCESS const_register_process;


  shiftData_1 <= shiftData(1);

  shiftData_2 <= shiftData(2);

  shiftData_3 <= shiftData(3);

  shiftData_4 <= shiftData(4);

  shiftData_5 <= shiftData(5);

  shiftData_6 <= shiftData(6);

  shiftData_7 <= shiftData(7);

  shiftData_8 <= shiftData(8);

  shiftData_9 <= shiftData(9);

  shiftData_10 <= shiftData(10);

  shiftData_11 <= shiftData(11);

  shiftData_12 <= shiftData(12);

  shiftData_13 <= shiftData(13);

  switchData_13 <= switchData(13);

  shiftData_13_1 <= shiftData_13 XOR switchData_13;

  switchData_12 <= switchData(12);

  shiftData_12_1 <= shiftData_12 XOR switchData_12;

  switchData_11 <= switchData(11);

  shiftData_11_1 <= shiftData_11 XOR switchData_11;

  switchData_10 <= switchData(10);

  shiftData_10_1 <= shiftData_10 XOR switchData_10;

  switchData_9 <= switchData(9);

  shiftData_9_1 <= shiftData_9 XOR switchData_9;

  switchData_8 <= switchData(8);

  shiftData_8_1 <= shiftData_8 XOR switchData_8;

  switchData_7 <= switchData(7);

  shiftData_7_1 <= shiftData_7 XOR switchData_7;

  switchData_6 <= switchData(6);

  shiftData_6_1 <= shiftData_6 XOR switchData_6;

  switchData_5 <= switchData(5);

  shiftData_5_1 <= shiftData_5 XOR switchData_5;

  switchData_4 <= switchData(4);

  shiftData_4_1 <= shiftData_4 XOR switchData_4;

  switchData_3 <= switchData(3);

  shiftData_3_1 <= shiftData_3 XOR switchData_3;

  switchData_2 <= switchData(2);

  shiftData_2_1 <= shiftData_2 XOR switchData_2;

  switchData_1 <= switchData(1);

  shiftData_1_1 <= shiftData_1 XOR switchData_1;

  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_switch_delay <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        IF reset = '1' THEN
          alpha_switch_delay <= (OTHERS => '0');
        ELSIF const1Reg = '1' THEN
          alpha_switch_delay <= xorData;
        END IF;
      END IF;
    END IF;
  END PROCESS c_2_process;

  
  xorDataReg <= (OTHERS => '0') WHEN reset = '1' ELSE
      alpha_switch_delay;

  
  switchData <= xorDataReg WHEN switch_compare_1_1 = '0' ELSE
      zeroData;

  switchData_0 <= switchData(0);

  shiftData_0_1 <= shiftData_0 XOR switchData_0;

  xorData(0) <= shiftData_0_1;
  xorData(1) <= shiftData_1_1;
  xorData(2) <= shiftData_2_1;
  xorData(3) <= shiftData_3_1;
  xorData(4) <= shiftData_4_1;
  xorData(5) <= shiftData_5_1;
  xorData(6) <= shiftData_6_1;
  xorData(7) <= shiftData_7_1;
  xorData(8) <= shiftData_8_1;
  xorData(9) <= shiftData_9_1;
  xorData(10) <= shiftData_10_1;
  xorData(11) <= shiftData_11_1;
  xorData(12) <= shiftData_12_1;
  xorData(13) <= shiftData_13_1;

  wrdata_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrData <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        wrData <= xorData;
      END IF;
    END IF;
  END PROCESS wrdata_register_process;


  wraddr_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wraddr_register_reg <= (OTHERS => to_unsigned(16#0#, 4));
      ELSIF enb = '1' THEN
        wraddr_register_reg(0) <= countLayer;
        wraddr_register_reg(1 TO 5) <= wraddr_register_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS wraddr_register_process;

  wrAddr <= wraddr_register_reg(5);

  rdaddr_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdaddr_register_reg <= (OTHERS => to_unsigned(16#0#, 4));
      ELSIF enb = '1' THEN
        rdaddr_register_reg(0) <= rdAddr;
        rdaddr_register_reg(1 TO 4) <= rdaddr_register_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS rdaddr_register_process;

  rdAddrReg <= rdaddr_register_reg(4);


  alphavalid_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alphavalid_register_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        alphavalid_register_reg(0) <= aValid;
        alphavalid_register_reg(4 DOWNTO 1) <= alphavalid_register_reg(3 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS alphavalid_register_process;

  alphaValid <= alphavalid_register_reg(4);

  alphaaddr_register_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alphaAddr_tmp <= to_unsigned(16#0#, 4);
      ELSIF enb = '1' THEN
        alphaAddr_tmp <= rdAddrReg;
      END IF;
    END IF;
  END PROCESS alphaaddr_register_process;


  alphaAddr <= std_logic_vector(alphaAddr_tmp);

  Column_LUT_add_cast <= signed(resize(xIdx, 32));
  Column_LUT_cast <= signed(resize(yIdx, 6));
  Column_LUT_mul_temp <= Column_LUT_cast * to_signed(16#0000000C#, 32);
  cVal <= Column_LUT_data(to_integer(Column_LUT_add_cast + resize(Column_LUT_mul_temp, 32)));

  column_value_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        columnVal_tmp <= to_unsigned(16#00#, 5);
      ELSIF enb = '1' THEN
        columnVal_tmp <= cVal;
      END IF;
    END IF;
  END PROCESS column_value_process;


  columnVal <= std_logic_vector(columnVal_tmp);

  shiftData_0_2 <= shiftData(0);

  shiftData_1_2 <= shiftData(1);

  shiftData_2_2 <= shiftData(2);

  shiftData_3_2 <= shiftData(3);

  shiftData_4_2 <= shiftData(4);

  shiftData_5_2 <= shiftData(5);

  shiftData_6_2 <= shiftData(6);

  shiftData_7_2 <= shiftData(7);

  shiftData_8_2 <= shiftData(8);

  shiftData_9_2 <= shiftData(9);

  shiftData_10_2 <= shiftData(10);

  shiftData_11_2 <= shiftData(11);

  shiftData_12_2 <= shiftData(12);

  shiftData_13_2 <= shiftData(13);

  xorDataParityReg_13 <= xorDataParityReg(13);

  shiftData_13_3 <= shiftData_13_2 XOR xorDataParityReg_13;

  xorDataParityReg_12 <= xorDataParityReg(12);

  shiftData_12_3 <= shiftData_12_2 XOR xorDataParityReg_12;

  xorDataParityReg_11 <= xorDataParityReg(11);

  shiftData_11_3 <= shiftData_11_2 XOR xorDataParityReg_11;

  xorDataParityReg_10 <= xorDataParityReg(10);

  shiftData_10_3 <= shiftData_10_2 XOR xorDataParityReg_10;

  xorDataParityReg_9 <= xorDataParityReg(9);

  shiftData_9_3 <= shiftData_9_2 XOR xorDataParityReg_9;

  xorDataParityReg_8 <= xorDataParityReg(8);

  shiftData_8_3 <= shiftData_8_2 XOR xorDataParityReg_8;

  xorDataParityReg_7 <= xorDataParityReg(7);

  shiftData_7_3 <= shiftData_7_2 XOR xorDataParityReg_7;

  xorDataParityReg_6 <= xorDataParityReg(6);

  shiftData_6_3 <= shiftData_6_2 XOR xorDataParityReg_6;

  xorDataParityReg_5 <= xorDataParityReg(5);

  shiftData_5_3 <= shiftData_5_2 XOR xorDataParityReg_5;

  xorDataParityReg_4 <= xorDataParityReg(4);

  shiftData_4_3 <= shiftData_4_2 XOR xorDataParityReg_4;

  xorDataParityReg_3 <= xorDataParityReg(3);

  shiftData_3_3 <= shiftData_3_2 XOR xorDataParityReg_3;

  xorDataParityReg_2 <= xorDataParityReg(2);

  shiftData_2_3 <= shiftData_2_2 XOR xorDataParityReg_2;

  xorDataParityReg_1 <= xorDataParityReg(1);

  shiftData_1_3 <= shiftData_1_2 XOR xorDataParityReg_1;

  c_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        alpha_switch_delay_1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        IF reset = '1' THEN
          alpha_switch_delay_1 <= (OTHERS => '0');
        ELSIF const1Reg = '1' THEN
          alpha_switch_delay_1 <= xorDataParity1;
        END IF;
      END IF;
    END IF;
  END PROCESS c_3_process;

  
  xorDataParityReg <= (OTHERS => '0') WHEN reset = '1' ELSE
      alpha_switch_delay_1;

  xorDataParityReg_0 <= xorDataParityReg(0);

  shiftData_0_3 <= shiftData_0_2 XOR xorDataParityReg_0;

  xorDataParity1(0) <= shiftData_0_3;
  xorDataParity1(1) <= shiftData_1_3;
  xorDataParity1(2) <= shiftData_2_3;
  xorDataParity1(3) <= shiftData_3_3;
  xorDataParity1(4) <= shiftData_4_3;
  xorDataParity1(5) <= shiftData_5_3;
  xorDataParity1(6) <= shiftData_6_3;
  xorDataParity1(7) <= shiftData_7_3;
  xorDataParity1(8) <= shiftData_8_3;
  xorDataParity1(9) <= shiftData_9_3;
  xorDataParity1(10) <= shiftData_10_3;
  xorDataParity1(11) <= shiftData_11_3;
  xorDataParity1(12) <= shiftData_12_3;
  xorDataParity1(13) <= shiftData_13_3;

  first_parity_value_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parity1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        parity1 <= xorDataParity1;
      END IF;
    END IF;
  END PROCESS first_parity_value_process;


  alpha <= alphaTmp;

END rtl;

