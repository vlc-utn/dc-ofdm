-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLRxDemodulator/rx_demod_optimized_src_OFDM_Channel_Estimator.vhd
-- Created: 2024-10-01 11:34:41
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: rx_demod_optimized_src_OFDM_Channel_Estimator
-- Source Path: HDLRxDemodulator/rx_demodulator_full/channel_estimation_and_equalization/Channel Estimation/OFDM 
-- Channel Estimato
-- Hierarchy Level: 3
-- Model version: 1.61
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.rx_demod_optimized_src_rx_demodulator_full_pac.ALL;

ENTITY rx_demod_optimized_src_OFDM_Channel_Estimator IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_2_0                         :   IN    std_logic;
        In1_re                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        In1_im                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        In2                               :   IN    std_logic;
        In3_re                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
        In3_im                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
        In4                               :   IN    std_logic;
        numSCPS                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        reset                             :   IN    std_logic;
        Out1_re                           :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        Out1_im                           :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        Out2                              :   OUT   std_logic
        );
END rx_demod_optimized_src_OFDM_Channel_Estimator;


ARCHITECTURE rtl OF rx_demod_optimized_src_OFDM_Channel_Estimator IS

  -- Component Declarations
  COMPONENT rx_demod_optimized_src_SimpleDualPortRAM_generic_block3
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          wr_din_re                       :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_din_im                       :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout_re                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          dout_im                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT rx_demod_optimized_src_SimpleDualPortRAM_generic_block2
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : rx_demod_optimized_src_SimpleDualPortRAM_generic_block3
    USE ENTITY work.rx_demod_optimized_src_SimpleDualPortRAM_generic_block3(rtl);

  FOR ALL : rx_demod_optimized_src_SimpleDualPortRAM_generic_block2
    USE ENTITY work.rx_demod_optimized_src_SimpleDualPortRAM_generic_block2(rtl);

  -- Signals
  SIGNAL Constant1_out1                   : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL out_rsvd                         : std_logic;
  SIGNAL out_rsvd_1                       : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL Delay3_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL Constant_out1_re                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant_out1_im                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In1_re_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In1_im_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_re                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_im                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant1_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant1_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Add_out1_re                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Add_out1_im                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay_reg_re                     : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay_reg_im                     : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay_out1_re                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay_out1_im                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In3_re_signed                    : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL In3_im_signed                    : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL dataOut_re                       : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL dataOut_im                       : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL conj_cast                        : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL conj_cast_1                      : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL Conjugate_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL Conjugate_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL Delay1_reg_re                    : vector_of_signed16(0 TO 1);  -- sfix16_En12 [2]
  SIGNAL Delay1_reg_im                    : vector_of_signed16(0 TO 1);  -- sfix16_En12 [2]
  SIGNAL Delay1_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL Delay1_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL Product_Re_AC                    : signed(31 DOWNTO 0);  -- sfix32_En26
  SIGNAL Product_Re_AC_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Re_BD                    : signed(31 DOWNTO 0);  -- sfix32_En26
  SIGNAL Product_Re_BD_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL mulOutput                        : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Im_AD                    : signed(31 DOWNTO 0);  -- sfix32_En26
  SIGNAL Product_Im_AD_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Im_BC                    : signed(31 DOWNTO 0);  -- sfix32_En26
  SIGNAL Product_Im_BC_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL mulOutput_1                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay6_reg_re                    : vector_of_signed16(0 TO 2);  -- sfix16_En14 [3]
  SIGNAL Delay6_reg_im                    : vector_of_signed16(0 TO 2);  -- sfix16_En14 [3]
  SIGNAL Delay6_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay6_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_rsvd_2                       : std_logic;
  SIGNAL out_rsvd_3                       : std_logic;
  SIGNAL Delay_reg                        : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Logical_Operator6_out1           : std_logic;
  SIGNAL Delay9_out1                      : std_logic;
  SIGNAL Delay1_reg                       : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL Delay2_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL Logical_Operator5_out1           : std_logic;
  SIGNAL count_step                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_from                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_reset                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL numSCPS_unsigned                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL out_rsvd_4                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Delay10_reg                      : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL Delay10_out1                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Data_Type_Conversion3_out1       : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Constant12_out1                  : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL count_step_1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_from_1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_reset_1                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL AvgSymbCount_out1                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count                            : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL need_to_wrap                     : std_logic;
  SIGNAL count_value                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Compare_To_Constant1_out1        : std_logic;
  SIGNAL SubScCount_out1                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Compare_To_Constant4_out1        : std_logic;
  SIGNAL Logical_Operator5_out1_1         : std_logic;
  SIGNAL numScPerSymOut                   : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym                 : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym_next            : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Compare_To_Constant5_out1        : std_logic;
  SIGNAL Switch6_out1                     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL count_1                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL need_to_wrap_1                   : std_logic;
  SIGNAL count_value_1                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_2                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL AND_out1                         : std_logic;
  SIGNAL Logical_Operator3_out1           : std_logic;
  SIGNAL count_3                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Relational_Operator_out1         : std_logic;
  SIGNAL count_4                          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_5                          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL ScCountDelay_out1                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant11_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Add3_out1                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL dataDelay1_out1                  : std_logic;
  SIGNAL dataDelay_out1                   : std_logic;
  SIGNAL Logical_Operator4_out1           : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;
  SIGNAL Delay4_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay4_out1                      : std_logic;
  SIGNAL Constant_out1_re_1               : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Constant_out1_im_1               : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Constant_out1_dtc_re             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant_out1_dtc_im             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_rsvd_5                       : std_logic;
  SIGNAL Logical_Operator6_out1_1         : std_logic;
  SIGNAL Delay9_out1_1                    : std_logic;
  SIGNAL Delay1_reg_1                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_1                    : std_logic;
  SIGNAL Delay2_reg_1                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1_1                    : std_logic;
  SIGNAL Logical_Operator5_out1_2         : std_logic;
  SIGNAL Delay2_out1_2                    : std_logic;
  SIGNAL Constant2_out1_re                : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Constant2_out1_im                : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL dataOut_re_1                     : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL dataOut_im_1                     : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay4_out1_re                   : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay4_out1_im                   : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Switch_out1_re_1                 : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Switch_out1_im_1                 : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Compare_To_Constant3_out1        : std_logic;
  SIGNAL Logical_Operator2_out1           : std_logic;
  SIGNAL Delay1_out1_2                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Delay5_out1                      : std_logic;
  SIGNAL Logical_Operator_out1_2          : std_logic;
  SIGNAL Constant13_out1                  : std_logic;
  SIGNAL Switch8_out1                     : std_logic;
  SIGNAL Constant1_out1_re_1              : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Constant1_out1_im_1              : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Accumulator_RAM_out1_im          : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL Accumulator_RAM_out1_im_signed   : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Add_out1_im_1                    : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Add_out1_re_1                    : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Accumulator_RAM_out1_re          : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL Accumulator_RAM_out1_re_signed   : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Switch7_out1_re                  : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Switch7_out1_im                  : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay1_reg_re_1                  : vector_of_signed17(0 TO 1);  -- sfix17_En14 [2]
  SIGNAL Delay1_reg_im_1                  : vector_of_signed17(0 TO 1);  -- sfix17_En14 [2]
  SIGNAL Delay1_out1_re_1                 : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay1_out1_im_1                 : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Constant1_out1_1                 : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Constant_out1_1                  : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Switch2_out1                     : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Constant2_out1                   : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Constant2_out1_dtc               : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Add2_out1                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Counter_RAM_out1                 : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Counter_RAM_out1_unsigned        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Switch3_out1                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Out_value                        : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Delay2_reg_2                     : vector_of_unsigned17(0 TO 1);  -- ufix17 [2]
  SIGNAL Delay2_out1_3                    : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Product1_cast                    : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product1_mul_temp                : signed(34 DOWNTO 0);  -- sfix35_En30
  SIGNAL Product1_Re                      : signed(33 DOWNTO 0);  -- sfix34_En30
  SIGNAL Product1_Re_1                    : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Product1_cast_1                  : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product1_mul_temp_1              : signed(34 DOWNTO 0);  -- sfix35_En30
  SIGNAL Product1_Im                      : signed(33 DOWNTO 0);  -- sfix34_En30
  SIGNAL Product1_Im_1                    : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay3_out1_re                   : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay3_out1_im                   : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Delay3_out1_dtc_re               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay3_out1_dtc_im               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_reg_re                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_reg_im                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_out1_re_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_out1_im_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant4_out1                   : std_logic;
  SIGNAL Delay3_reg_1                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay3_out1_1                    : std_logic;
  SIGNAL Switch4_out1                     : std_logic;
  SIGNAL out_rsvd_6                       : std_logic;
  SIGNAL Logical_Operator6_out1_2         : std_logic;
  SIGNAL Delay9_out1_2                    : std_logic;
  SIGNAL Delay1_reg_2                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_3                    : std_logic;
  SIGNAL Delay2_reg_3                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1_4                    : std_logic;
  SIGNAL Logical_Operator5_out1_3         : std_logic;
  SIGNAL count_step_2                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_from_2                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_reset_2                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Constant5_out1                   : std_logic;
  SIGNAL Delay9_reg                       : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL Delay9_out1_3                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Delay9_out1_dtc                  : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Constant1_out1_2                 : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Add1_out1                        : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Delay8_reg                       : vector_of_unsigned9(0 TO 2);  -- ufix9 [3]
  SIGNAL Delay8_out1                      : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Switch5_out1                     : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Data_Type_Conversion3_out1_1     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Constant12_out1_1                : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numSCPS_Counter_out1             : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_6                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL need_to_wrap_2                   : std_logic;
  SIGNAL count_value_2                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_7                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Switch6_out1_1                   : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Add1_sub_cast                    : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_sub_cast_1                  : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_out1_1                      : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Compare_To_Constant3_out1_1      : std_logic;
  SIGNAL Logical_Operator2_out1_1         : std_logic;
  SIGNAL Logical_Operator4_out1_1         : std_logic;
  SIGNAL count_8                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Compare_To_Zero1_out1            : std_logic;
  SIGNAL Logical_Operator5_out1_4         : std_logic;
  SIGNAL numScPerSymOut_1                 : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym_1               : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym_next_1          : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Delay_reg_1                      : vector_of_unsigned17(0 TO 1);  -- ufix17 [2]
  SIGNAL Delay_out1_1                     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Compare_To_Constant5_out1_1      : std_logic;
  SIGNAL Constant2_out1_1                 : std_logic;
  SIGNAL Compare_To_Constant1_out1_1      : std_logic;
  SIGNAL Logical_Operator3_out1_1         : std_logic;
  SIGNAL Delay5_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay5_out1_1                    : std_logic;
  SIGNAL Constant9_out1                   : std_logic;
  SIGNAL Delay7_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay7_out1                      : std_logic;
  SIGNAL Constant8_out1                   : std_logic;
  SIGNAL Switch4_out1_1                   : std_logic;
  SIGNAL Switch2_out1_1                   : std_logic;
  SIGNAL Logical_Operator6_out1_3         : std_logic;
  SIGNAL Delay9_out1_4                    : std_logic;
  SIGNAL Delay1_reg_3                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_4                    : std_logic;
  SIGNAL Delay2_reg_4                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1_5                    : std_logic;
  SIGNAL Logical_Operator5_out1_5         : std_logic;
  SIGNAL Constant4_out1_1                 : std_logic;
  SIGNAL count_step_3                     : std_logic;  -- ufix1
  SIGNAL count_from_3                     : std_logic;  -- ufix1
  SIGNAL count_reset_3                    : std_logic;  -- ufix1
  SIGNAL first_bin_flag_indicator_out1    : std_logic;  -- ufix1
  SIGNAL count_9                          : std_logic;  -- ufix1
  SIGNAL need_to_wrap_3                   : std_logic;
  SIGNAL count_value_3                    : std_logic;  -- ufix1
  SIGNAL Compare_To_Zero_out1             : std_logic;
  SIGNAL Logical_Operator_out1_3          : std_logic;
  SIGNAL Switch1_out1                     : std_logic;
  SIGNAL count_10                         : std_logic;  -- ufix1
  SIGNAL count_11                         : std_logic;  -- ufix1
  SIGNAL Switch2_out1_2                   : std_logic;
  SIGNAL count_step_4                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_from_4                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant5_out1_1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_reset_4                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL InterpPointsSampCount_out1       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_12                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL need_to_wrap_4                   : std_logic;
  SIGNAL count_value_4                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_13                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_14                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_15                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Compare_To_Constant_out1_1       : std_logic;
  SIGNAL Switch3_out1_1                   : std_logic;
  SIGNAL Logical_Operator3_out1_2         : std_logic;
  SIGNAL Compare_To_Constant1_out1_2      : std_logic;
  SIGNAL Logical_Operator1_out1_1         : std_logic;
  SIGNAL interpFacOut                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Data1Out_re                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data1Out_im                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_re                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_im                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL posOfFirstHighRef_1              : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL initExtrapValidOut               : std_logic;
  SIGNAL posOfFirstHighRefBuff            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL intermediateBuff_re              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL intermediateBuff_im              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_re                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_im                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_re                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_im                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL posOfFirstHighRefBuff_next       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL intermediateBuff_next_re         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL intermediateBuff_next_im         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_next_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_next_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_next_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_next_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL HDL_Counter_ctrl_const_out       : std_logic;
  SIGNAL HDL_Counter_ctrl_delay_out       : std_logic;
  SIGNAL HDL_Counter_Initial_Val_out      : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Constant2_out1_2                 : std_logic;
  SIGNAL count_step_5                     : std_logic;  -- ufix1
  SIGNAL count_from_5                     : std_logic;  -- ufix1
  SIGNAL count_reset_5                    : std_logic;  -- ufix1
  SIGNAL Logical_Operator_out1_4          : std_logic;
  SIGNAL Constant5_out1_2                 : std_logic;
  SIGNAL Constant4_out1_2                 : std_logic;
  SIGNAL count_step_6                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_from_6                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Constant_out1_2                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_reset_6                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_step_7                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_from_7                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_reset_7                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL HDL_Counter1_out1                : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_16                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL need_to_wrap_5                   : std_logic;
  SIGNAL count_value_5                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL HDL_Counter_out1                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_17                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL need_to_wrap_6                   : std_logic;
  SIGNAL count_value_6                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL binary_counter_out1              : std_logic;  -- ufix1
  SIGNAL Compare_To_Constant3_out1_2      : std_logic;
  SIGNAL Compare_To_Constant2_out1        : std_logic;
  SIGNAL Logical_Operator1_out1_2         : std_logic;
  SIGNAL Switch4_out1_2                   : std_logic;
  SIGNAL Logical_Operator_out1_5          : std_logic;
  SIGNAL Switch1_out1_1                   : std_logic;
  SIGNAL count_18                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_19                         : std_logic;  -- ufix1
  SIGNAL need_to_wrap_7                   : std_logic;
  SIGNAL count_value_7                    : std_logic;  -- ufix1
  SIGNAL Switch_out1                      : std_logic;
  SIGNAL count_20                         : std_logic;  -- ufix1
  SIGNAL Logical_Operator6_out1_4         : std_logic;
  SIGNAL count_21                         : std_logic;  -- ufix1
  SIGNAL Compare_To_Constant_out1_2       : std_logic;
  SIGNAL count_22                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_23                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL HDL_Counter_out                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Compare_To_Constant1_out1_3      : std_logic;
  SIGNAL Logical_Operator2_out1_2         : std_logic;
  SIGNAL count_24                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Compare_To_Constant5_out1_2      : std_logic;
  SIGNAL count_25                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Constant8_out1_1                 : std_logic;
  SIGNAL CmpIPF_out1                      : std_logic;
  SIGNAL Switch4_out1_3                   : std_logic;
  SIGNAL Constant1_out1_3                 : std_logic;
  SIGNAL count_step_8                     : std_logic;  -- ufix1
  SIGNAL count_from_8                     : std_logic;  -- ufix1
  SIGNAL count_reset_8                    : std_logic;  -- ufix1
  SIGNAL binary_counter1_out1             : std_logic;  -- ufix1
  SIGNAL count_26                         : std_logic;  -- ufix1
  SIGNAL need_to_wrap_8                   : std_logic;
  SIGNAL count_value_8                    : std_logic;  -- ufix1
  SIGNAL Compare_To_Constant4_out1_1      : std_logic;
  SIGNAL Logical_Operator3_out1_3         : std_logic;
  SIGNAL Switch3_out1_2                   : std_logic;
  SIGNAL count_27                         : std_logic;  -- ufix1
  SIGNAL count_28                         : std_logic;  -- ufix1
  SIGNAL Switch2_out1_3                   : std_logic;
  SIGNAL Constant_out1_3                  : std_logic;
  SIGNAL count_step_9                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_from_9                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_reset_9                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL numSCPSOutCounter_out1           : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_29                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL need_to_wrap_9                   : std_logic;
  SIGNAL count_value_9                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Add_sub_cast                     : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add_sub_cast_1                   : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add_out1                         : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Compare_To_Constant6_out1        : std_logic;
  SIGNAL Logical_Operator4_out1_2         : std_logic;
  SIGNAL finalExtrapValidOut              : std_logic;
  SIGNAL FinalExtrapRepBuff               : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL FinalExtrapRepBuff_next          : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL finalExtrapValidOut_1            : std_logic;
  SIGNAL Logical_Operator5_out1_6         : std_logic;
  SIGNAL Logical_Operator2_out1_3         : std_logic;
  SIGNAL Compare_To_Constant3_out1_3      : std_logic;
  SIGNAL Switch1_out1_2                   : std_logic;
  SIGNAL count_30                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Add1_sub_cast_2                  : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_sub_cast_3                  : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_out1_2                      : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Logical_Operator3_out1_4         : std_logic;
  SIGNAL count_31                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Add_sub_cast_2                   : signed(10 DOWNTO 0);  -- sfix11
  SIGNAL Add_sub_cast_3                   : signed(10 DOWNTO 0);  -- sfix11
  SIGNAL Add_out1_1                       : signed(10 DOWNTO 0);  -- sfix11
  SIGNAL Delay1_reg_4                     : vector_of_signed11(0 TO 5);  -- sfix11 [6]
  SIGNAL Delay1_out1_5                    : signed(10 DOWNTO 0);  -- sfix11
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Constant4_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant4_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch3_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch3_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_reg_re                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay2_reg_im                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay2_out1_re_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_out1_im_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Compare_To_Constant7_out1        : std_logic;
  SIGNAL Logical_Operator7_out1           : std_logic;
  SIGNAL Constant6_out1                   : std_logic;
  SIGNAL count_step_10                    : std_logic;  -- ufix1
  SIGNAL count_from_10                    : std_logic;  -- ufix1
  SIGNAL count_reset_10                   : std_logic;  -- ufix1
  SIGNAL binary_counter2_out1             : std_logic;  -- ufix1
  SIGNAL count_32                         : std_logic;  -- ufix1
  SIGNAL need_to_wrap_10                  : std_logic;
  SIGNAL count_value_10                   : std_logic;  -- ufix1
  SIGNAL Switch7_out1                     : std_logic;
  SIGNAL count_33                         : std_logic;  -- ufix1
  SIGNAL count_34                         : std_logic;  -- ufix1
  SIGNAL Delay1_reg_5                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay1_out1_6                    : std_logic;  -- ufix1
  SIGNAL Constant3_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant3_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch5_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch5_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_reg_re_1                  : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_reg_im_1                  : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_out1_re_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_out1_im_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL down_counter_ctrl_const_out      : std_logic;
  SIGNAL down_counter_ctrl_delay_out      : std_logic;
  SIGNAL down_counter_Initial_Val_out     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_step_11                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_from_11                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_reset_11                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL down_counter_out1                : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_35                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL need_to_wrap_11                  : std_logic;
  SIGNAL count_value_11                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_36                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_37                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL down_counter_out                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Delay3_reg_2                     : vector_of_unsigned4(0 TO 1);  -- ufix4 [2]
  SIGNAL Delay3_out1_2                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Delay4_reg_re_2                  : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay4_reg_im_2                  : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay4_out1_re_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_out1_im_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_cast                     : signed(4 DOWNTO 0);  -- sfix5
  SIGNAL Product_mul_temp                 : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Product_cast_1                   : signed(4 DOWNTO 0);  -- sfix5
  SIGNAL Product_mul_temp_1               : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Product_out1_re                  : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Product_out1_im                  : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Delay7_out1_re                   : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Delay7_out1_im                   : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Delay5_reg_re                    : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay5_reg_im                    : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay5_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay5_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant1_out1_4                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_step_12                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_from_12                    : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_reset_12                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL up_counter_out1                  : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_38                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL need_to_wrap_12                  : std_logic;
  SIGNAL count_value_12                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_39                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL count_40                         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Add1_out1_3                      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Delay6_reg                       : vector_of_unsigned5(0 TO 1);  -- ufix5 [2]
  SIGNAL Delay6_out1                      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Product1_cast_2                  : signed(5 DOWNTO 0);  -- sfix6
  SIGNAL Product1_mul_temp_2              : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Product1_cast_3                  : signed(5 DOWNTO 0);  -- sfix6
  SIGNAL Product1_mul_temp_3              : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Product1_out1_re                 : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Product1_out1_im                 : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Delay8_out1_re                   : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Delay8_out1_im                   : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Add_add_cast                     : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Add_add_cast_1                   : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Add_add_cast_2                   : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Add_add_cast_3                   : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Add_out1_re_2                    : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Add_out1_im_2                    : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Delay_reg_re_1                   : vector_of_signed22(0 TO 1);  -- sfix22_En14 [2]
  SIGNAL Delay_reg_im_1                   : vector_of_signed22(0 TO 1);  -- sfix22_En14 [2]
  SIGNAL Delay_out1_re_1                  : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Delay_out1_im_1                  : signed(21 DOWNTO 0);  -- sfix22_En14
  SIGNAL Out_value_1                      : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Delay2_reg_5                     : vector_of_unsigned17(0 TO 4);  -- ufix17 [5]
  SIGNAL Delay2_out1_6                    : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Product2_cast                    : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product2_mul_temp                : signed(39 DOWNTO 0);  -- sfix40_En30
  SIGNAL Product2_cast_1                  : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product2_mul_temp_1              : signed(39 DOWNTO 0);  -- sfix40_En30
  SIGNAL Product2_out1_re                 : signed(38 DOWNTO 0);  -- sfix39_En30
  SIGNAL Product2_out1_im                 : signed(38 DOWNTO 0);  -- sfix39_En30
  SIGNAL Delay1_out1_re_2                 : signed(38 DOWNTO 0);  -- sfix39_En30
  SIGNAL Delay1_out1_im_2                 : signed(38 DOWNTO 0);  -- sfix39_En30
  SIGNAL dataOut_re_2                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_im_2                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch6_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch6_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re_4                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im_4                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch1_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch1_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant3_out1                   : std_logic;
  SIGNAL Delay1_reg_6                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay1_out1_7                    : std_logic;
  SIGNAL Delay4_reg_1                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay4_out1_1                    : std_logic;
  SIGNAL Switch3_out1_3                   : std_logic;
  SIGNAL Logical_Operator6_out1_5         : std_logic;
  SIGNAL Delay9_out1_5                    : std_logic;
  SIGNAL Delay1_reg_7                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_8                    : std_logic;
  SIGNAL Delay4_reg_2                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay4_out1_2                    : std_logic;
  SIGNAL Delay6_reg_1                     : std_logic_vector(3 DOWNTO 0);  -- ufix1 [4]
  SIGNAL Delay6_out1_1                    : std_logic;
  SIGNAL Delay7_reg_1                     : std_logic_vector(4 DOWNTO 0);  -- ufix1 [5]
  SIGNAL Delay7_out1_1                    : std_logic;
  SIGNAL Delay8_reg_1                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay8_out1_1                    : std_logic;
  SIGNAL Logical_Operator5_out1_7         : std_logic;

  ATTRIBUTE use_dsp : string;

  ATTRIBUTE use_dsp OF Product_Re_AC : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product_Re_BD : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product_Im_AD : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product_Im_BC : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product1_Re : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product1_Im : SIGNAL IS "no";

BEGIN
  -- Subcarrier Counter
  -- Increment Symbol Counter based on Subcarrier count and average Length (mask)
  -- Compare numScperSym and reset Subcarrier Counter
  -- Sample numScPerSym when dataValid = 1 and Symbol counter = 0 and Sub carrier Counter = 0
  -- if numScPerSym is less than 0; numScperSym is taken as 13
  -- Add with refData or 0 based on refValid 
  -- actual RAM output
  -- Final Average 
  -- Output
  -- Push 0 when Avg is not require
  -- Add with 1 or 0 based on refValid 
  -- Push 0 with Avg Start didnt arrive
  -- actual RAM output
  -- Final Counter 
  -- Output

  u_Accumulator_RAM : rx_demod_optimized_src_SimpleDualPortRAM_generic_block3
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 17
                 )
    PORT MAP( clk => clk,
              enb_1_2_0 => enb_1_2_0,
              wr_din_re => std_logic_vector(Add_out1_re_1),
              wr_din_im => std_logic_vector(Add_out1_im_1),
              wr_addr => std_logic_vector(Delay1_out1_2),
              wr_en => Switch8_out1,
              rd_addr => std_logic_vector(SubScCount_out1),
              dout_re => Accumulator_RAM_out1_re,
              dout_im => Accumulator_RAM_out1_im
              );

  u_Counter_RAM : rx_demod_optimized_src_SimpleDualPortRAM_generic_block2
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 4
                 )
    PORT MAP( clk => clk,
              enb_1_2_0 => enb_1_2_0,
              wr_din => std_logic_vector(Add2_out1),
              wr_addr => std_logic_vector(Delay1_out1_2),
              wr_en => Switch8_out1,
              rd_addr => std_logic_vector(SubScCount_out1),
              dout => Counter_RAM_out1
              );

  Constant1_out1 <= '0';

  Constant_out1 <= '1';

  --MATLAB Function 'OFDM Channel Estimator/LS Estimator/ValidIn Selector'
  out_rsvd <= In2;

  --MATLAB Function 'OFDM Channel Estimator/LS Estimator/ValidInRef Selector'
  out_rsvd_1 <= In4;

  Logical_Operator_out1 <= out_rsvd AND out_rsvd_1;

  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay3_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay3_reg(0) <= Logical_Operator_out1;
        Delay3_reg(2 DOWNTO 1) <= Delay3_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay3_process;

  Delay3_out1 <= Delay3_reg(2);

  Constant_out1_re <= to_signed(16#0000#, 16);
  Constant_out1_im <= to_signed(16#0000#, 16);

  In1_re_signed <= signed(In1_re);

  In1_im_signed <= signed(In1_im);

  --MATLAB Function 'OFDM Channel Estimator/LS Estimator/DataIn Selector'
  out_re <= In1_re_signed;
  out_im <= In1_im_signed;

  Constant1_out1_re <= to_signed(16#0000#, 16);
  Constant1_out1_im <= to_signed(16#0000#, 16);

  Add_out1_re <= out_re + Constant1_out1_re;
  Add_out1_im <= out_im + Constant1_out1_im;

  Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay_reg_re <= (OTHERS => to_signed(16#0000#, 16));
        Delay_reg_im <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay_reg_im(0) <= Add_out1_im;
        Delay_reg_im(1) <= Delay_reg_im(0);
        Delay_reg_re(0) <= Add_out1_re;
        Delay_reg_re(1) <= Delay_reg_re(0);
      END IF;
    END IF;
  END PROCESS Delay_process;

  Delay_out1_re <= Delay_reg_re(1);
  Delay_out1_im <= Delay_reg_im(1);

  In3_re_signed <= signed(In3_re);

  In3_im_signed <= signed(In3_im);

  --MATLAB Function 'OFDM Channel Estimator/LS Estimator/DataRef Selector'
  dataOut_re <= In3_re_signed;
  dataOut_im <= In3_im_signed;

  Conjugate_out1_re <= dataOut_re;
  conj_cast <= resize(dataOut_im, 17);
  conj_cast_1 <=  - (conj_cast);
  
  Conjugate_out1_im <= X"7FFF" WHEN (conj_cast_1(16) = '0') AND (conj_cast_1(15) /= '0') ELSE
      X"8000" WHEN (conj_cast_1(16) = '1') AND (conj_cast_1(15) /= '1') ELSE
      conj_cast_1(15 DOWNTO 0);

  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_re <= (OTHERS => to_signed(16#0000#, 16));
        Delay1_reg_im <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_im(0) <= Conjugate_out1_im;
        Delay1_reg_im(1) <= Delay1_reg_im(0);
        Delay1_reg_re(0) <= Conjugate_out1_re;
        Delay1_reg_re(1) <= Delay1_reg_re(0);
      END IF;
    END IF;
  END PROCESS Delay1_process;

  Delay1_out1_re <= Delay1_reg_re(1);
  Delay1_out1_im <= Delay1_reg_im(1);

  Product_Re_AC <= Delay_out1_re * Delay1_out1_re;

  Product_Re_AC_1 <= Product_Re_AC(27 DOWNTO 12);

  Product_Re_BD <= Delay_out1_im * Delay1_out1_im;

  Product_Re_BD_1 <= Product_Re_BD(27 DOWNTO 12);

  mulOutput <= Product_Re_AC_1 - Product_Re_BD_1;

  Product_Im_AD <= Delay_out1_re * Delay1_out1_im;

  Product_Im_AD_1 <= Product_Im_AD(27 DOWNTO 12);

  Product_Im_BC <= Delay_out1_im * Delay1_out1_re;

  Product_Im_BC_1 <= Product_Im_BC(27 DOWNTO 12);

  mulOutput_1 <= Product_Im_AD_1 + Product_Im_BC_1;

  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_out1_re <= to_signed(16#0000#, 16);
        Delay2_out1_im <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_out1_re <= mulOutput;
        Delay2_out1_im <= mulOutput_1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  
  Switch_out1_re <= Constant_out1_re WHEN Delay3_out1 = '0' ELSE
      Delay2_out1_re;
  
  Switch_out1_im <= Constant_out1_im WHEN Delay3_out1 = '0' ELSE
      Delay2_out1_im;

  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay6_reg_re <= (OTHERS => to_signed(16#0000#, 16));
        Delay6_reg_im <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay6_reg_im(0) <= Switch_out1_im;
        Delay6_reg_im(1 TO 2) <= Delay6_reg_im(0 TO 1);
        Delay6_reg_re(0) <= Switch_out1_re;
        Delay6_reg_re(1 TO 2) <= Delay6_reg_re(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay6_process;

  Delay6_out1_re <= Delay6_reg_re(2);
  Delay6_out1_im <= Delay6_reg_im(2);

  --MATLAB Function 'OFDM Channel Estimator/Averaging/Reset Selector'
  out_rsvd_2 <= reset;

  --MATLAB Function 'OFDM Channel Estimator/Averaging/ValidIn Selector'
  out_rsvd_3 <= In2;

  Delay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay_reg(0) <= out_rsvd_3;
        Delay_reg(2 DOWNTO 1) <= Delay_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay_1_process;

  Delay_out1 <= Delay_reg(2);

  Logical_Operator6_out1 <=  NOT out_rsvd_2;

  Delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay9_out1 <= Logical_Operator6_out1;
      END IF;
    END IF;
  END PROCESS Delay9_process;


  Delay1_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg(0) <= Logical_Operator6_out1;
        Delay1_reg(1) <= Delay1_reg(0);
      END IF;
    END IF;
  END PROCESS Delay1_1_process;

  Delay1_out1 <= Delay1_reg(1);

  Delay2_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg(0) <= Logical_Operator6_out1;
        Delay2_reg(2 DOWNTO 1) <= Delay2_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_1_process;

  Delay2_out1 <= Delay2_reg(2);

  Logical_Operator5_out1 <= Delay2_out1 AND (Delay1_out1 AND (Delay_out1 AND Delay9_out1));

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 255
  count_step <= to_unsigned(16#001#, 10);

  count_from <= to_unsigned(16#000#, 10);

  count_reset <= to_unsigned(16#000#, 10);

  numSCPS_unsigned <= unsigned(numSCPS);

  --MATLAB Function 'OFDM Channel Estimator/Averaging/NumSCPerSym Selector'
  out_rsvd_4 <= numSCPS_unsigned;

  Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay10_reg <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb_1_2_0 = '1' THEN
        Delay10_reg(0) <= out_rsvd_4;
        Delay10_reg(1 TO 2) <= Delay10_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay10_process;

  Delay10_out1 <= Delay10_reg(2);

  Data_Type_Conversion3_out1 <= resize(Delay10_out1, 17);

  Constant12_out1 <= to_unsigned(16#0000D#, 17);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_1 <= to_unsigned(16#1#, 3);

  count_from_1 <= to_unsigned(16#0#, 3);

  count_reset_1 <= to_unsigned(16#0#, 3);

  count <= AvgSymbCount_out1 + count_step_1;

  
  need_to_wrap <= '1' WHEN AvgSymbCount_out1 = to_unsigned(16#1#, 3) ELSE
      '0';

  
  count_value <= count WHEN need_to_wrap = '0' ELSE
      count_from_1;

  
  Compare_To_Constant1_out1 <= '1' WHEN AvgSymbCount_out1 = to_unsigned(16#0#, 3) ELSE
      '0';

  
  Compare_To_Constant4_out1 <= '1' WHEN SubScCount_out1 = to_unsigned(16#000#, 10) ELSE
      '0';

  Logical_Operator5_out1_1 <= Compare_To_Constant1_out1 AND (Logical_Operator5_out1 AND Compare_To_Constant4_out1);

  whdlmod_c97_NumSCPerSym_Generator_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        numValidScPerSym <= to_unsigned(16#0000D#, 17);
      ELSIF enb_1_2_0 = '1' THEN
        numValidScPerSym <= numValidScPerSym_next;
      END IF;
    END IF;
  END PROCESS whdlmod_c97_NumSCPerSym_Generator_process;

  whdlmod_c97_NumSCPerSym_Generator_output : PROCESS (Data_Type_Conversion3_out1, Logical_Operator5_out1_1, numValidScPerSym)
    VARIABLE sub_cast : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(18 DOWNTO 0);
    VARIABLE sub_temp : signed(18 DOWNTO 0);
    VARIABLE cast : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_1 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_2 : signed(18 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(18 DOWNTO 0);
    VARIABLE cast_0 : unsigned(17 DOWNTO 0);
  BEGIN
    sub_temp := to_signed(16#00000#, 19);
    sub_temp_0 := to_signed(16#00000#, 19);
    sub_cast := to_unsigned(16#00000#, 18);
    sub_cast_0 := to_signed(16#00000#, 19);
    cast := to_unsigned(16#00000#, 18);
    sub_cast_1 := to_unsigned(16#00000#, 18);
    sub_cast_2 := to_signed(16#00000#, 19);
    cast_0 := to_unsigned(16#00000#, 18);
    numValidScPerSym_next <= numValidScPerSym;
    --MATLAB Function 'OFDM Channel Estimator/Averaging/SCAndSymb Indicator/NumSCPerSym Generator'
    IF Logical_Operator5_out1_1 = '1' THEN 
      sub_cast := resize(Data_Type_Conversion3_out1, 18);
      sub_cast_0 := signed(resize(sub_cast, 19));
      sub_temp := sub_cast_0 - to_signed(16#00001#, 19);
      IF sub_temp(18) = '1' THEN 
        cast := "000000000000000000";
      ELSE 
        cast := unsigned(sub_temp(17 DOWNTO 0));
      END IF;
      IF cast(17) /= '0' THEN 
        numScPerSymOut <= "11111111111111111";
      ELSE 
        numScPerSymOut <= cast(16 DOWNTO 0);
      END IF;
      sub_cast_1 := resize(Data_Type_Conversion3_out1, 18);
      sub_cast_2 := signed(resize(sub_cast_1, 19));
      sub_temp_0 := sub_cast_2 - to_signed(16#00001#, 19);
      IF sub_temp_0(18) = '1' THEN 
        cast_0 := "000000000000000000";
      ELSE 
        cast_0 := unsigned(sub_temp_0(17 DOWNTO 0));
      END IF;
      IF cast_0(17) /= '0' THEN 
        numValidScPerSym_next <= "11111111111111111";
      ELSE 
        numValidScPerSym_next <= cast_0(16 DOWNTO 0);
      END IF;
    ELSE 
      numScPerSymOut <= numValidScPerSym;
    END IF;
  END PROCESS whdlmod_c97_NumSCPerSym_Generator_output;


  
  Compare_To_Constant5_out1 <= '1' WHEN numScPerSymOut > to_unsigned(16#00000#, 17) ELSE
      '0';

  
  Switch6_out1 <= Constant12_out1 WHEN Compare_To_Constant5_out1 = '0' ELSE
      numScPerSymOut;

  count_1 <= SubScCount_out1 + count_step;

  
  need_to_wrap_1 <= '1' WHEN SubScCount_out1 = to_unsigned(16#0FF#, 10) ELSE
      '0';

  
  count_value_1 <= count_1 WHEN need_to_wrap_1 = '0' ELSE
      count_from;

  
  count_2 <= SubScCount_out1 WHEN Logical_Operator5_out1 = '0' ELSE
      count_value_1;

  Logical_Operator3_out1 <= AND_out1 OR out_rsvd_2;

  
  count_3 <= count_2 WHEN Logical_Operator3_out1 = '0' ELSE
      count_reset;

  SubScCount_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        SubScCount_out1 <= to_unsigned(16#000#, 10);
      ELSIF enb_1_2_0 = '1' THEN
        SubScCount_out1 <= count_3;
      END IF;
    END IF;
  END PROCESS SubScCount_process;


  
  Relational_Operator_out1 <= '1' WHEN resize(SubScCount_out1, 17) >= Switch6_out1 ELSE
      '0';

  AND_out1 <= Relational_Operator_out1 AND Logical_Operator5_out1;

  
  count_4 <= AvgSymbCount_out1 WHEN AND_out1 = '0' ELSE
      count_value;

  
  count_5 <= count_4 WHEN out_rsvd_2 = '0' ELSE
      count_reset_1;

  AvgSymbCount_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        AvgSymbCount_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_2_0 = '1' THEN
        AvgSymbCount_out1 <= count_5;
      END IF;
    END IF;
  END PROCESS AvgSymbCount_process;


  ScCountDelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        ScCountDelay_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_2_0 = '1' THEN
        ScCountDelay_out1 <= AvgSymbCount_out1;
      END IF;
    END IF;
  END PROCESS ScCountDelay_process;


  Constant11_out1 <= to_unsigned(16#1#, 3);

  Add3_out1 <= resize(ScCountDelay_out1, 4) + resize(Constant11_out1, 4);

  
  Compare_To_Constant_out1 <= '1' WHEN Add3_out1 = to_unsigned(16#2#, 4) ELSE
      '0';

  Logical_Operator_out1_1 <=  NOT out_rsvd_2;

  dataDelay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dataDelay1_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        dataDelay1_out1 <= Logical_Operator_out1_1;
      END IF;
    END IF;
  END PROCESS dataDelay1_process;


  dataDelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dataDelay_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        dataDelay_out1 <= Logical_Operator5_out1;
      END IF;
    END IF;
  END PROCESS dataDelay_process;


  Logical_Operator4_out1 <= dataDelay1_out1 AND dataDelay_out1;

  Logical_Operator1_out1 <= Compare_To_Constant_out1 AND Logical_Operator4_out1;

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_reg(0) <= Logical_Operator1_out1;
        Delay4_reg(2 DOWNTO 1) <= Delay4_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay4_process;

  Delay4_out1 <= Delay4_reg(2);

  Constant_out1_re_1 <= to_signed(16#00000#, 17);
  Constant_out1_im_1 <= to_signed(16#00000#, 17);

  Constant_out1_dtc_re <= Constant_out1_re_1(15 DOWNTO 0);
  Constant_out1_dtc_im <= Constant_out1_im_1(15 DOWNTO 0);

  --MATLAB Function 'OFDM Channel Estimator/LS Estimator/Reset Selector'
  out_rsvd_5 <= reset;

  Logical_Operator6_out1_1 <=  NOT out_rsvd_5;

  Delay9_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay9_out1_1 <= Logical_Operator6_out1_1;
      END IF;
    END IF;
  END PROCESS Delay9_1_process;


  Delay1_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_1(0) <= Logical_Operator6_out1_1;
        Delay1_reg_1(1) <= Delay1_reg_1(0);
      END IF;
    END IF;
  END PROCESS Delay1_2_process;

  Delay1_out1_1 <= Delay1_reg_1(1);

  Delay2_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg_1(0) <= Logical_Operator6_out1_1;
        Delay2_reg_1(2 DOWNTO 1) <= Delay2_reg_1(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_2_process;

  Delay2_out1_1 <= Delay2_reg_1(2);

  Logical_Operator5_out1_2 <= Delay2_out1_1 AND (Delay1_out1_1 AND (Delay3_out1 AND Delay9_out1_1));

  Delay2_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_out1_2 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_out1_2 <= Logical_Operator5_out1_2;
      END IF;
    END IF;
  END PROCESS Delay2_3_process;


  Constant2_out1_re <= to_signed(16#00000#, 17);
  Constant2_out1_im <= to_signed(16#00000#, 17);

  --MATLAB Function 'OFDM Channel Estimator/Averaging/Data BitGrowth'
  -- double(numOFDMSymToBeAvg)-1; %
  -- Embedded FI
  dataOut_re_1 <= resize(Switch_out1_re, 17);
  dataOut_im_1 <= resize(Switch_out1_im, 17);

  Delay4_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_out1_re <= to_signed(16#00000#, 17);
        Delay4_out1_im <= to_signed(16#00000#, 17);
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_out1_re <= dataOut_re_1;
        Delay4_out1_im <= dataOut_im_1;
      END IF;
    END IF;
  END PROCESS Delay4_1_process;


  
  Switch_out1_re_1 <= Constant2_out1_re WHEN Delay2_out1_2 = '0' ELSE
      Delay4_out1_re;
  
  Switch_out1_im_1 <= Constant2_out1_im WHEN Delay2_out1_2 = '0' ELSE
      Delay4_out1_im;

  
  Compare_To_Constant3_out1 <= '1' WHEN ScCountDelay_out1 = to_unsigned(16#0#, 3) ELSE
      '0';

  Logical_Operator2_out1 <= Logical_Operator4_out1 AND Compare_To_Constant3_out1;

  Delay1_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_out1_2 <= to_unsigned(16#000#, 10);
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_out1_2 <= SubScCount_out1;
      END IF;
    END IF;
  END PROCESS Delay1_3_process;


  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay5_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay5_out1 <= Logical_Operator5_out1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  Logical_Operator_out1_2 <= Delay5_out1 AND Delay2_out1_2;

  Constant13_out1 <= '1';

  
  Switch8_out1 <= Logical_Operator_out1_2 WHEN Logical_Operator2_out1 = '0' ELSE
      Constant13_out1;

  Constant1_out1_re_1 <= to_signed(16#00000#, 17);
  Constant1_out1_im_1 <= to_signed(16#00000#, 17);

  Accumulator_RAM_out1_im_signed <= signed(Accumulator_RAM_out1_im);

  Accumulator_RAM_out1_re_signed <= signed(Accumulator_RAM_out1_re);

  
  Switch7_out1_re <= Accumulator_RAM_out1_re_signed WHEN Logical_Operator2_out1 = '0' ELSE
      Constant1_out1_re_1;
  
  Switch7_out1_im <= Accumulator_RAM_out1_im_signed WHEN Logical_Operator2_out1 = '0' ELSE
      Constant1_out1_im_1;

  Add_out1_re_1 <= Switch_out1_re_1 + Switch7_out1_re;
  Add_out1_im_1 <= Switch_out1_im_1 + Switch7_out1_im;

  Delay1_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_re_1 <= (OTHERS => to_signed(16#00000#, 17));
        Delay1_reg_im_1 <= (OTHERS => to_signed(16#00000#, 17));
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_im_1(0) <= Add_out1_im_1;
        Delay1_reg_im_1(1) <= Delay1_reg_im_1(0);
        Delay1_reg_re_1(0) <= Add_out1_re_1;
        Delay1_reg_re_1(1) <= Delay1_reg_re_1(0);
      END IF;
    END IF;
  END PROCESS Delay1_4_process;

  Delay1_out1_re_1 <= Delay1_reg_re_1(1);
  Delay1_out1_im_1 <= Delay1_reg_im_1(1);

  Constant1_out1_1 <= to_unsigned(16#000#, 9);

  Constant_out1_1 <= to_unsigned(16#001#, 9);

  
  Switch2_out1 <= Constant1_out1_1 WHEN Delay2_out1_2 = '0' ELSE
      Constant_out1_1;

  Constant2_out1 <= to_unsigned(16#0#, 2);

  Constant2_out1_dtc <= resize(Constant2_out1, 4);

  Counter_RAM_out1_unsigned <= unsigned(Counter_RAM_out1);

  
  Switch3_out1 <= Counter_RAM_out1_unsigned WHEN Logical_Operator2_out1 = '0' ELSE
      Constant2_out1_dtc;

  Add2_out1 <= resize(Switch2_out1, 4) + Switch3_out1;

  whdlmod_c92_MUL_LUT_output : PROCESS (Add2_out1)
  BEGIN
    --MATLAB Function 'OFDM Channel Estimator/Averaging/AvgCalculator/MUL_LUT'
    IF Add2_out1 = to_unsigned(16#1#, 4) THEN 
      Out_value <= to_unsigned(16#10000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#2#, 4) THEN 
      Out_value <= to_unsigned(16#08000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#3#, 4) THEN 
      Out_value <= to_unsigned(16#05555#, 17);
    ELSIF Add2_out1 = to_unsigned(16#4#, 4) THEN 
      Out_value <= to_unsigned(16#04000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#5#, 4) THEN 
      Out_value <= to_unsigned(16#03333#, 17);
    ELSIF Add2_out1 = to_unsigned(16#6#, 4) THEN 
      Out_value <= to_unsigned(16#02AAA#, 17);
    ELSIF Add2_out1 = to_unsigned(16#7#, 4) THEN 
      Out_value <= to_unsigned(16#02492#, 17);
    ELSIF Add2_out1 = to_unsigned(16#8#, 4) THEN 
      Out_value <= to_unsigned(16#02000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#9#, 4) THEN 
      Out_value <= to_unsigned(16#01C71#, 17);
    ELSIF Add2_out1 = to_unsigned(16#A#, 4) THEN 
      Out_value <= to_unsigned(16#01999#, 17);
    ELSIF Add2_out1 = to_unsigned(16#B#, 4) THEN 
      Out_value <= to_unsigned(16#01745#, 17);
    ELSIF Add2_out1 = to_unsigned(16#C#, 4) THEN 
      Out_value <= to_unsigned(16#01555#, 17);
    ELSIF Add2_out1 = to_unsigned(16#D#, 4) THEN 
      Out_value <= to_unsigned(16#013B1#, 17);
    ELSIF Add2_out1 = to_unsigned(16#E#, 4) THEN 
      Out_value <= to_unsigned(16#01249#, 17);
    ELSE 
      Out_value <= to_unsigned(16#10000#, 17);
    END IF;
  END PROCESS whdlmod_c92_MUL_LUT_output;


  Delay2_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg_2 <= (OTHERS => to_unsigned(16#00000#, 17));
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg_2(0) <= Out_value;
        Delay2_reg_2(1) <= Delay2_reg_2(0);
      END IF;
    END IF;
  END PROCESS Delay2_4_process;

  Delay2_out1_3 <= Delay2_reg_2(1);

  Product1_cast <= signed(resize(Delay2_out1_3, 18));
  Product1_mul_temp <= Delay1_out1_re_1 * Product1_cast;
  Product1_Re <= Product1_mul_temp(33 DOWNTO 0);

  Product1_Re_1 <= Product1_Re(32 DOWNTO 16);

  Product1_cast_1 <= signed(resize(Delay2_out1_3, 18));
  Product1_mul_temp_1 <= Delay1_out1_im_1 * Product1_cast_1;
  Product1_Im <= Product1_mul_temp_1(33 DOWNTO 0);

  Product1_Im_1 <= Product1_Im(32 DOWNTO 16);

  Delay3_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay3_out1_re <= to_signed(16#00000#, 17);
        Delay3_out1_im <= to_signed(16#00000#, 17);
      ELSIF enb_1_2_0 = '1' THEN
        Delay3_out1_re <= Product1_Re_1;
        Delay3_out1_im <= Product1_Im_1;
      END IF;
    END IF;
  END PROCESS Delay3_1_process;


  Delay3_out1_dtc_re <= Delay3_out1_re(15 DOWNTO 0);
  Delay3_out1_dtc_im <= Delay3_out1_im(15 DOWNTO 0);

  
  Switch_out1_re_2 <= Constant_out1_dtc_re WHEN Delay4_out1 = '0' ELSE
      Delay3_out1_dtc_re;
  
  Switch_out1_im_2 <= Constant_out1_dtc_im WHEN Delay4_out1 = '0' ELSE
      Delay3_out1_dtc_im;

  
  Switch_out1_re_3 <= Delay6_out1_re WHEN Constant_out1 = '0' ELSE
      Switch_out1_re_2;
  
  Switch_out1_im_3 <= Delay6_out1_im WHEN Constant_out1 = '0' ELSE
      Switch_out1_im_2;

  Delay4_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_reg_re <= (OTHERS => to_signed(16#0000#, 16));
        Delay4_reg_im <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_reg_im(0) <= Switch_out1_im_3;
        Delay4_reg_im(1 TO 5) <= Delay4_reg_im(0 TO 4);
        Delay4_reg_re(0) <= Switch_out1_re_3;
        Delay4_reg_re(1 TO 5) <= Delay4_reg_re(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay4_2_process;

  Delay4_out1_re_1 <= Delay4_reg_re(5);
  Delay4_out1_im_1 <= Delay4_reg_im(5);

  Constant4_out1 <= '1';

  Delay3_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay3_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay3_reg_1(0) <= Logical_Operator5_out1;
        Delay3_reg_1(2 DOWNTO 1) <= Delay3_reg_1(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay3_2_process;

  Delay3_out1_1 <= Delay3_reg_1(2);

  
  Switch4_out1 <= Delay3_out1_1 WHEN Constant4_out1 = '0' ELSE
      Delay4_out1;

  --MATLAB Function 'OFDM Channel Estimator/Interpolator/Reset Selector'
  out_rsvd_6 <= reset;

  Logical_Operator6_out1_2 <=  NOT out_rsvd_6;

  Delay9_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_out1_2 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay9_out1_2 <= Logical_Operator6_out1_2;
      END IF;
    END IF;
  END PROCESS Delay9_2_process;


  Delay1_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_2 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_2(0) <= Logical_Operator6_out1_2;
        Delay1_reg_2(1) <= Delay1_reg_2(0);
      END IF;
    END IF;
  END PROCESS Delay1_5_process;

  Delay1_out1_3 <= Delay1_reg_2(1);

  Delay2_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg_3 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg_3(0) <= Logical_Operator6_out1_2;
        Delay2_reg_3(2 DOWNTO 1) <= Delay2_reg_3(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_5_process;

  Delay2_out1_4 <= Delay2_reg_3(2);

  Logical_Operator5_out1_3 <= Delay2_out1_4 AND (Delay1_out1_3 AND (Switch4_out1 AND Delay9_out1_2));

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 255
  count_step_2 <= to_unsigned(16#001#, 10);

  count_from_2 <= to_unsigned(16#000#, 10);

  count_reset_2 <= to_unsigned(16#000#, 10);

  Constant5_out1 <= '1';

  Delay9_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_reg <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb_1_2_0 = '1' THEN
        Delay9_reg(0) <= Delay10_out1;
        Delay9_reg(1 TO 2) <= Delay9_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay9_3_process;

  Delay9_out1_3 <= Delay9_reg(2);

  Delay9_out1_dtc <= resize(Delay9_out1_3, 9);

  Constant1_out1_2 <= to_unsigned(16#00001#, 17);

  Add1_out1 <= resize(Switch6_out1, 9) + resize(Constant1_out1_2, 9);

  Delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay8_reg <= (OTHERS => to_unsigned(16#000#, 9));
      ELSIF enb_1_2_0 = '1' THEN
        Delay8_reg(0) <= Add1_out1;
        Delay8_reg(1 TO 2) <= Delay8_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay8_process;

  Delay8_out1 <= Delay8_reg(2);

  
  Switch5_out1 <= Delay9_out1_dtc WHEN Constant5_out1 = '0' ELSE
      Delay8_out1;

  Data_Type_Conversion3_out1_1 <= resize(Switch5_out1, 17);

  Constant12_out1_1 <= to_unsigned(16#00019#, 17);

  count_6 <= numSCPS_Counter_out1 + count_step_2;

  
  need_to_wrap_2 <= '1' WHEN numSCPS_Counter_out1 = to_unsigned(16#0FF#, 10) ELSE
      '0';

  
  count_value_2 <= count_6 WHEN need_to_wrap_2 = '0' ELSE
      count_from_2;

  
  count_7 <= numSCPS_Counter_out1 WHEN Logical_Operator5_out1_3 = '0' ELSE
      count_value_2;

  Add1_sub_cast <= signed(resize(Switch6_out1_1, 18));
  Add1_sub_cast_1 <= signed(resize(numSCPS_Counter_out1, 18));
  Add1_out1_1 <= Add1_sub_cast - Add1_sub_cast_1;

  
  Compare_To_Constant3_out1_1 <= '1' WHEN Add1_out1_1 = to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator2_out1_1 <= Compare_To_Constant3_out1_1 AND Logical_Operator5_out1_3;

  Logical_Operator4_out1_1 <= Logical_Operator2_out1_1 OR out_rsvd_6;

  
  count_8 <= count_7 WHEN Logical_Operator4_out1_1 = '0' ELSE
      count_reset_2;

  numSCPS_Counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        numSCPS_Counter_out1 <= to_unsigned(16#000#, 10);
      ELSIF enb_1_2_0 = '1' THEN
        numSCPS_Counter_out1 <= count_8;
      END IF;
    END IF;
  END PROCESS numSCPS_Counter_process;


  
  Compare_To_Zero1_out1 <= '1' WHEN numSCPS_Counter_out1 = to_unsigned(16#000#, 10) ELSE
      '0';

  Logical_Operator5_out1_4 <= Logical_Operator5_out1_3 AND Compare_To_Zero1_out1;

  whdlmod_c99_NumSCPerSym_Generator_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        numValidScPerSym_1 <= to_unsigned(16#00019#, 17);
      ELSIF enb_1_2_0 = '1' THEN
        numValidScPerSym_1 <= numValidScPerSym_next_1;
      END IF;
    END IF;
  END PROCESS whdlmod_c99_NumSCPerSym_Generator_process;

  whdlmod_c99_NumSCPerSym_Generator_output : PROCESS (Data_Type_Conversion3_out1_1, Logical_Operator5_out1_4, numValidScPerSym_1)
    VARIABLE sub_cast1 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_01 : signed(18 DOWNTO 0);
    VARIABLE sub_temp1 : signed(18 DOWNTO 0);
    VARIABLE cast1 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_11 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_21 : signed(18 DOWNTO 0);
    VARIABLE sub_temp_01 : signed(18 DOWNTO 0);
    VARIABLE cast_01 : unsigned(17 DOWNTO 0);
  BEGIN
    sub_temp1 := to_signed(16#00000#, 19);
    sub_temp_01 := to_signed(16#00000#, 19);
    sub_cast1 := to_unsigned(16#00000#, 18);
    sub_cast_01 := to_signed(16#00000#, 19);
    cast1 := to_unsigned(16#00000#, 18);
    sub_cast_11 := to_unsigned(16#00000#, 18);
    sub_cast_21 := to_signed(16#00000#, 19);
    cast_01 := to_unsigned(16#00000#, 18);
    numValidScPerSym_next_1 <= numValidScPerSym_1;
    --MATLAB Function 'OFDM Channel Estimator/Interpolator/CtrlSignal Generator/NumSCPerSym Generator/NumSCPerSym Sampler/NumSCPerSym Generator'
    IF Logical_Operator5_out1_4 = '1' THEN 
      sub_cast1 := resize(Data_Type_Conversion3_out1_1, 18);
      sub_cast_01 := signed(resize(sub_cast1, 19));
      sub_temp1 := sub_cast_01 - to_signed(16#00001#, 19);
      IF sub_temp1(18) = '1' THEN 
        cast1 := "000000000000000000";
      ELSE 
        cast1 := unsigned(sub_temp1(17 DOWNTO 0));
      END IF;
      IF cast1(17) /= '0' THEN 
        numValidScPerSym_next_1 <= "11111111111111111";
      ELSE 
        numValidScPerSym_next_1 <= cast1(16 DOWNTO 0);
      END IF;
      sub_cast_11 := resize(Data_Type_Conversion3_out1_1, 18);
      sub_cast_21 := signed(resize(sub_cast_11, 19));
      sub_temp_01 := sub_cast_21 - to_signed(16#00001#, 19);
      IF sub_temp_01(18) = '1' THEN 
        cast_01 := "000000000000000000";
      ELSE 
        cast_01 := unsigned(sub_temp_01(17 DOWNTO 0));
      END IF;
      IF cast_01(17) /= '0' THEN 
        numScPerSymOut_1 <= "11111111111111111";
      ELSE 
        numScPerSymOut_1 <= cast_01(16 DOWNTO 0);
      END IF;
    ELSE 
      numScPerSymOut_1 <= numValidScPerSym_1;
    END IF;
  END PROCESS whdlmod_c99_NumSCPerSym_Generator_output;


  Delay_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay_reg_1 <= (OTHERS => to_unsigned(16#00000#, 17));
      ELSIF enb_1_2_0 = '1' THEN
        Delay_reg_1(0) <= numScPerSymOut_1;
        Delay_reg_1(1) <= Delay_reg_1(0);
      END IF;
    END IF;
  END PROCESS Delay_2_process;

  Delay_out1_1 <= Delay_reg_1(1);

  
  Compare_To_Constant5_out1_1 <= '1' WHEN Delay_out1_1 > to_unsigned(16#00000#, 17) ELSE
      '0';

  
  Switch6_out1_1 <= Constant12_out1_1 WHEN Compare_To_Constant5_out1_1 = '0' ELSE
      Delay_out1_1;

  Constant2_out1_1 <= '1';

  
  Compare_To_Constant1_out1_1 <= '1' WHEN Add2_out1 > to_unsigned(16#0#, 4) ELSE
      '0';

  Logical_Operator3_out1_1 <= Logical_Operator1_out1 AND Compare_To_Constant1_out1_1;

  Delay5_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay5_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay5_reg(0) <= Logical_Operator3_out1_1;
        Delay5_reg(2 DOWNTO 1) <= Delay5_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay5_1_process;

  Delay5_out1_1 <= Delay5_reg(2);

  Constant9_out1 <= '0';

  Delay7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay7_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay7_reg(0) <= Logical_Operator5_out1_2;
        Delay7_reg(2 DOWNTO 1) <= Delay7_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay7_process;

  Delay7_out1 <= Delay7_reg(2);

  Constant8_out1 <= '1';

  
  Switch4_out1_1 <= Constant9_out1 WHEN Delay5_out1_1 = '0' ELSE
      Constant8_out1;

  
  Switch2_out1_1 <= Delay7_out1 WHEN Constant2_out1_1 = '0' ELSE
      Switch4_out1_1;

  Logical_Operator6_out1_3 <=  NOT out_rsvd_6;

  Delay9_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_out1_4 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay9_out1_4 <= Logical_Operator6_out1_3;
      END IF;
    END IF;
  END PROCESS Delay9_4_process;


  Delay1_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_3 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_3(0) <= Logical_Operator6_out1_3;
        Delay1_reg_3(1) <= Delay1_reg_3(0);
      END IF;
    END IF;
  END PROCESS Delay1_6_process;

  Delay1_out1_4 <= Delay1_reg_3(1);

  Delay2_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg_4 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg_4(0) <= Logical_Operator6_out1_3;
        Delay2_reg_4(2 DOWNTO 1) <= Delay2_reg_4(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_6_process;

  Delay2_out1_5 <= Delay2_reg_4(2);

  Logical_Operator5_out1_5 <= Delay2_out1_5 AND (Delay1_out1_4 AND (Switch2_out1_1 AND Delay9_out1_4));

  Constant4_out1_1 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_3 <= '1';

  count_from_3 <= '0';

  count_reset_3 <= '0';

  count_9 <= first_bin_flag_indicator_out1 XOR count_step_3;

  
  need_to_wrap_3 <= '1' WHEN first_bin_flag_indicator_out1 = '1' ELSE
      '0';

  
  count_value_3 <= count_9 WHEN need_to_wrap_3 = '0' ELSE
      count_from_3;

  
  Compare_To_Zero_out1 <= '1' WHEN first_bin_flag_indicator_out1 = '0' ELSE
      '0';

  Logical_Operator_out1_3 <= Logical_Operator5_out1_5 AND (Compare_To_Zero_out1 AND Logical_Operator5_out1_3);

  
  Switch1_out1 <= Logical_Operator_out1_3 WHEN first_bin_flag_indicator_out1 = '0' ELSE
      Constant4_out1_1;

  
  count_10 <= first_bin_flag_indicator_out1 WHEN Switch1_out1 = '0' ELSE
      count_value_3;

  
  count_11 <= count_10 WHEN Logical_Operator4_out1_1 = '0' ELSE
      count_reset_3;

  first_bin_flag_indicator_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        first_bin_flag_indicator_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        first_bin_flag_indicator_out1 <= count_11;
      END IF;
    END IF;
  END PROCESS first_bin_flag_indicator_process;


  
  Switch2_out1_2 <= Logical_Operator_out1_3 WHEN first_bin_flag_indicator_out1 = '0' ELSE
      Logical_Operator5_out1_3;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2
  count_step_4 <= to_unsigned(16#1#, 3);

  count_from_4 <= to_unsigned(16#0#, 3);

  Constant5_out1_1 <= to_unsigned(16#1#, 3);

  count_reset_4 <= to_unsigned(16#0#, 3);

  count_12 <= InterpPointsSampCount_out1 + count_step_4;

  
  need_to_wrap_4 <= '1' WHEN InterpPointsSampCount_out1 = to_unsigned(16#2#, 3) ELSE
      '0';

  
  count_value_4 <= count_12 WHEN need_to_wrap_4 = '0' ELSE
      count_from_4;

  
  count_13 <= InterpPointsSampCount_out1 WHEN Switch2_out1_2 = '0' ELSE
      count_value_4;

  
  count_14 <= count_13 WHEN Logical_Operator_out1_3 = '0' ELSE
      Constant5_out1_1;

  
  count_15 <= count_14 WHEN Logical_Operator4_out1_1 = '0' ELSE
      count_reset_4;

  InterpPointsSampCount_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        InterpPointsSampCount_out1 <= to_unsigned(16#0#, 3);
      ELSIF enb_1_2_0 = '1' THEN
        InterpPointsSampCount_out1 <= count_15;
      END IF;
    END IF;
  END PROCESS InterpPointsSampCount_process;


  
  Compare_To_Constant_out1_1 <= '1' WHEN InterpPointsSampCount_out1 = to_unsigned(16#0#, 3) ELSE
      '0';

  
  Switch3_out1_1 <= Logical_Operator_out1_3 WHEN first_bin_flag_indicator_out1 = '0' ELSE
      Compare_To_Constant_out1_1;

  Logical_Operator3_out1_2 <= Switch3_out1_1 AND Logical_Operator5_out1_3;

  
  Compare_To_Constant1_out1_2 <= '1' WHEN numSCPS_Counter_out1 = to_unsigned(16#002#, 10) ELSE
      '0';

  Logical_Operator1_out1_1 <= Compare_To_Constant1_out1_2 AND Logical_Operator5_out1_3;

  --MATLAB Function 'OFDM Channel Estimator/Interpolator/InterpFac DTConverter'
  interpFacOut <= to_unsigned(16#03#, 5);

  whdlmod_c102_InitExtrapData_Generator_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        posOfFirstHighRefBuff <= to_unsigned(16#000#, 10);
        intermediateBuff_re <= to_signed(16#0000#, 16);
        intermediateBuff_im <= to_signed(16#0000#, 16);
        interInp1_re <= to_signed(16#0000#, 16);
        interInp1_im <= to_signed(16#0000#, 16);
        interInp2_re <= to_signed(16#0000#, 16);
        interInp2_im <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        posOfFirstHighRefBuff <= posOfFirstHighRefBuff_next;
        intermediateBuff_re <= intermediateBuff_next_re;
        intermediateBuff_im <= intermediateBuff_next_im;
        interInp1_re <= interInp1_next_re;
        interInp1_im <= interInp1_next_im;
        interInp2_re <= interInp2_next_re;
        interInp2_im <= interInp2_next_im;
      END IF;
    END IF;
  END PROCESS whdlmod_c102_InitExtrapData_Generator_process;

  whdlmod_c102_InitExtrapData_Generator_output : PROCESS (Logical_Operator1_out1_1, Logical_Operator3_out1_2, Logical_Operator5_out1_3,
       Logical_Operator_out1_3, Switch_out1_im_3, Switch_out1_re_3,
       interInp1_im, interInp1_re, interInp2_im, interInp2_re,
       intermediateBuff_im, intermediateBuff_re, interpFacOut,
       numSCPS_Counter_out1, posOfFirstHighRefBuff)
    VARIABLE posOfFirstHighRef : unsigned(9 DOWNTO 0);
    VARIABLE endValue : unsigned(9 DOWNTO 0);
    VARIABLE tmpPosFirstRef : unsigned(9 DOWNTO 0);
    VARIABLE tmpInterBuff_re : signed(15 DOWNTO 0);
    VARIABLE tmpInterBuff_im : signed(15 DOWNTO 0);
    VARIABLE sub_cast2 : unsigned(5 DOWNTO 0);
    VARIABLE sub_cast_02 : signed(6 DOWNTO 0);
    VARIABLE sub_temp2 : signed(6 DOWNTO 0);
    VARIABLE add_cast : unsigned(5 DOWNTO 0);
    VARIABLE add_temp : unsigned(10 DOWNTO 0);
    VARIABLE sub_cast_12 : unsigned(5 DOWNTO 0);
    VARIABLE sub_cast_22 : signed(6 DOWNTO 0);
    VARIABLE sub_temp_02 : signed(6 DOWNTO 0);
    VARIABLE cast2 : unsigned(5 DOWNTO 0);
    VARIABLE cast_02 : unsigned(9 DOWNTO 0);
  BEGIN
    interInp1_next_re <= interInp1_re;
    interInp1_next_im <= interInp1_im;
    interInp2_next_re <= interInp2_re;
    interInp2_next_im <= interInp2_im;
    --MATLAB Function 'OFDM Channel Estimator/Interpolator/InitExtrapData Generator'
    --interpFac = double(abs(floor(real(interpFac))));
    --interpFac = cast(0,'like',ScCounter);
    posOfFirstHighRef := to_unsigned(16#000#, 10);
    initExtrapValidOut <= '0';
    IF Logical_Operator_out1_3 = '1' THEN 
      tmpPosFirstRef := numSCPS_Counter_out1;
      tmpInterBuff_re := Switch_out1_re_3;
      tmpInterBuff_im := Switch_out1_im_3;
    ELSE 
      tmpPosFirstRef := posOfFirstHighRefBuff;
      tmpInterBuff_re := intermediateBuff_re;
      tmpInterBuff_im := intermediateBuff_im;
    END IF;
    posOfFirstHighRefBuff_next <= tmpPosFirstRef;
    intermediateBuff_next_re <= tmpInterBuff_re;
    intermediateBuff_next_im <= tmpInterBuff_im;
    IF numSCPS_Counter_out1 >= tmpPosFirstRef THEN 
      posOfFirstHighRef := tmpPosFirstRef;
    END IF;
    sub_cast2 := resize(interpFacOut, 6);
    sub_cast_02 := signed(resize(sub_cast2, 7));
    sub_temp2 := sub_cast_02 - to_signed(16#01#, 7);
    IF sub_temp2(6) = '1' THEN 
      add_cast := "000000";
    ELSE 
      add_cast := unsigned(sub_temp2(5 DOWNTO 0));
    END IF;
    add_temp := resize(add_cast, 11) + resize(posOfFirstHighRef, 11);
    IF add_temp(10) /= '0' THEN 
      endValue := "1111111111";
    ELSE 
      endValue := add_temp(9 DOWNTO 0);
    END IF;
    sub_cast_12 := resize(interpFacOut, 6);
    sub_cast_22 := signed(resize(sub_cast_12, 7));
    sub_temp_02 := sub_cast_22 - to_signed(16#01#, 7);
    IF sub_temp_02(6) = '1' THEN 
      cast2 := "000000";
    ELSE 
      cast2 := unsigned(sub_temp_02(5 DOWNTO 0));
    END IF;
    cast_02 := resize(cast2, 10);
    IF Logical_Operator5_out1_3 = '1' AND ((numSCPS_Counter_out1 >= cast_02) AND (numSCPS_Counter_out1 <= endValue)) THEN 
      initExtrapValidOut <= '1';
    END IF;
    IF Logical_Operator1_out1_1 = '1' THEN 
      Data2Out_re <= tmpInterBuff_re;
      Data2Out_im <= tmpInterBuff_im;
      interInp1_next_re <= tmpInterBuff_re;
      interInp1_next_im <= tmpInterBuff_im;
      interInp2_next_re <= tmpInterBuff_re;
      interInp2_next_im <= tmpInterBuff_im;
    ELSIF (Logical_Operator3_out1_2 AND ( NOT Logical_Operator_out1_3)) = '1' THEN 
      interInp1_next_re <= interInp2_re;
      interInp1_next_im <= interInp2_im;
      tmpInterBuff_re := interInp2_re;
      tmpInterBuff_im := interInp2_im;
      Data2Out_re <= Switch_out1_re_3;
      Data2Out_im <= Switch_out1_im_3;
      interInp2_next_re <= Switch_out1_re_3;
      interInp2_next_im <= Switch_out1_im_3;
    ELSE 
      tmpInterBuff_re := interInp1_re;
      tmpInterBuff_im := interInp1_im;
      Data2Out_re <= interInp2_re;
      Data2Out_im <= interInp2_im;
    END IF;
    Data1Out_re <= tmpInterBuff_re;
    Data1Out_im <= tmpInterBuff_im;
    posOfFirstHighRef_1 <= posOfFirstHighRef;
  END PROCESS whdlmod_c102_InitExtrapData_Generator_output;


  HDL_Counter_ctrl_const_out <= '1';

  HDL_Counter_ctrl_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        HDL_Counter_ctrl_delay_out <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        HDL_Counter_ctrl_delay_out <= HDL_Counter_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS HDL_Counter_ctrl_delay_process;


  HDL_Counter_Initial_Val_out <= to_unsigned(16#2#, 4);

  Constant2_out1_2 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_5 <= '1';

  count_from_5 <= '0';

  count_reset_5 <= '0';

  Logical_Operator_out1_4 <=  NOT Logical_Operator_out1_3;

  Constant5_out1_2 <= '1';

  Constant4_out1_2 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 2
  --  step value      = -1
  --  count to value  = 0
  count_step_6 <= to_unsigned(16#1#, 4);

  count_from_6 <= to_unsigned(16#2#, 4);

  Constant_out1_2 <= to_unsigned(16#2#, 4);

  count_reset_6 <= to_unsigned(16#2#, 4);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2
  count_step_7 <= to_unsigned(16#1#, 4);

  count_from_7 <= to_unsigned(16#0#, 4);

  count_reset_7 <= to_unsigned(16#0#, 4);

  count_16 <= HDL_Counter1_out1 + count_step_7;

  
  need_to_wrap_5 <= '1' WHEN HDL_Counter1_out1 = to_unsigned(16#2#, 4) ELSE
      '0';

  
  count_value_5 <= count_16 WHEN need_to_wrap_5 = '0' ELSE
      count_from_7;

  count_17 <= HDL_Counter_out1 - count_step_6;

  
  need_to_wrap_6 <= '1' WHEN HDL_Counter_out1 = to_unsigned(16#0#, 4) ELSE
      '0';

  
  count_value_6 <= count_17 WHEN need_to_wrap_6 = '0' ELSE
      count_from_6;

  
  Compare_To_Constant3_out1_2 <= '1' WHEN binary_counter_out1 = '1' ELSE
      '0';

  
  Compare_To_Constant2_out1 <= '1' WHEN HDL_Counter_out1 = to_unsigned(16#0#, 4) ELSE
      '0';

  Logical_Operator1_out1_2 <= Compare_To_Constant2_out1 AND Compare_To_Constant3_out1_2;

  
  Switch4_out1_2 <= Constant5_out1_2 WHEN Logical_Operator1_out1_2 = '0' ELSE
      Constant4_out1_2;

  
  Switch1_out1_1 <= Logical_Operator_out1_5 WHEN binary_counter_out1 = '0' ELSE
      Switch4_out1_2;

  
  count_18 <= HDL_Counter_out1 WHEN Switch1_out1_1 = '0' ELSE
      count_value_6;

  count_19 <= binary_counter_out1 XOR count_step_5;

  
  need_to_wrap_7 <= '1' WHEN binary_counter_out1 = '1' ELSE
      '0';

  
  count_value_7 <= count_19 WHEN need_to_wrap_7 = '0' ELSE
      count_from_5;

  
  Switch_out1 <= Logical_Operator_out1_5 WHEN binary_counter_out1 = '0' ELSE
      Constant2_out1_2;

  
  count_20 <= binary_counter_out1 WHEN Switch_out1 = '0' ELSE
      count_value_7;

  
  count_21 <= count_20 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_5;

  binary_counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        binary_counter_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        binary_counter_out1 <= count_21;
      END IF;
    END IF;
  END PROCESS binary_counter_process;


  
  Compare_To_Constant_out1_2 <= '1' WHEN binary_counter_out1 = '0' ELSE
      '0';

  Logical_Operator_out1_5 <= Logical_Operator_out1_4 AND (Compare_To_Constant_out1_2 AND Logical_Operator3_out1_2);

  
  count_22 <= count_18 WHEN Logical_Operator_out1_5 = '0' ELSE
      Constant_out1_2;

  
  count_23 <= count_22 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_6;

  HDL_Counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        HDL_Counter_out <= to_unsigned(16#0#, 4);
      ELSIF enb_1_2_0 = '1' THEN
        HDL_Counter_out <= count_23;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  
  HDL_Counter_out1 <= HDL_Counter_Initial_Val_out WHEN HDL_Counter_ctrl_delay_out = '0' ELSE
      HDL_Counter_out;

  
  Compare_To_Constant1_out1_3 <= '1' WHEN HDL_Counter_out1 > to_unsigned(16#0#, 4) ELSE
      '0';

  Logical_Operator2_out1_2 <= Compare_To_Constant1_out1_3 AND Switch1_out1_1;

  
  count_24 <= HDL_Counter1_out1 WHEN Logical_Operator2_out1_2 = '0' ELSE
      count_value_5;

  Logical_Operator6_out1_4 <= Compare_To_Constant5_out1_2 OR out_rsvd_6;

  
  count_25 <= count_24 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_7;

  HDL_Counter1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        HDL_Counter1_out1 <= to_unsigned(16#0#, 4);
      ELSIF enb_1_2_0 = '1' THEN
        HDL_Counter1_out1 <= count_25;
      END IF;
    END IF;
  END PROCESS HDL_Counter1_process;


  
  Compare_To_Constant5_out1_2 <= '1' WHEN HDL_Counter1_out1 = to_unsigned(16#2#, 4) ELSE
      '0';

  Constant8_out1_1 <= '0';

  
  CmpIPF_out1 <= '1' WHEN Add1_out1_1 < to_signed(16#00003#, 18) ELSE
      '0';

  
  Switch4_out1_3 <= Constant8_out1_1 WHEN Logical_Operator3_out1_2 = '0' ELSE
      CmpIPF_out1;

  Constant1_out1_3 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_8 <= '1';

  count_from_8 <= '0';

  count_reset_8 <= '0';

  count_26 <= binary_counter1_out1 XOR count_step_8;

  
  need_to_wrap_8 <= '1' WHEN binary_counter1_out1 = '1' ELSE
      '0';

  
  count_value_8 <= count_26 WHEN need_to_wrap_8 = '0' ELSE
      count_from_8;

  
  Compare_To_Constant4_out1_1 <= '1' WHEN binary_counter1_out1 = '0' ELSE
      '0';

  Logical_Operator3_out1_3 <= Compare_To_Constant4_out1_1 AND Switch4_out1_3;

  
  Switch3_out1_2 <= Logical_Operator3_out1_3 WHEN binary_counter1_out1 = '0' ELSE
      Constant1_out1_3;

  
  count_27 <= binary_counter1_out1 WHEN Switch3_out1_2 = '0' ELSE
      count_value_8;

  
  count_28 <= count_27 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_8;

  binary_counter1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        binary_counter1_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        binary_counter1_out1 <= count_28;
      END IF;
    END IF;
  END PROCESS binary_counter1_process;


  
  Switch2_out1_3 <= Logical_Operator_out1_5 WHEN binary_counter_out1 = '0' ELSE
      Compare_To_Constant1_out1_3;

  Constant_out1_3 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 255
  count_step_9 <= to_unsigned(16#001#, 10);

  count_from_9 <= to_unsigned(16#000#, 10);

  count_reset_9 <= to_unsigned(16#000#, 10);

  count_29 <= numSCPSOutCounter_out1 + count_step_9;

  
  need_to_wrap_9 <= '1' WHEN numSCPSOutCounter_out1 = to_unsigned(16#0FF#, 10) ELSE
      '0';

  
  count_value_9 <= count_29 WHEN need_to_wrap_9 = '0' ELSE
      count_from_9;

  Add_sub_cast <= signed(resize(Switch6_out1_1, 18));
  Add_sub_cast_1 <= signed(resize(numSCPSOutCounter_out1, 18));
  Add_out1 <= Add_sub_cast - Add_sub_cast_1;

  
  Compare_To_Constant6_out1 <= '1' WHEN Add_out1 >= to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator4_out1_2 <= Compare_To_Constant6_out1 AND (Compare_To_Constant5_out1_2 AND binary_counter1_out1);

  whdlmod_c104_FinExtrapCtrl_Generator_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        FinalExtrapRepBuff <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        FinalExtrapRepBuff <= FinalExtrapRepBuff_next;
      END IF;
    END IF;
  END PROCESS whdlmod_c104_FinExtrapCtrl_Generator_process;

  whdlmod_c104_FinExtrapCtrl_Generator_output : PROCESS (Add_out1, FinalExtrapRepBuff, Logical_Operator4_out1_2)
    VARIABLE tmpDiff : signed(17 DOWNTO 0);
  BEGIN
    --MATLAB Function 'OFDM Channel Estimator/Interpolator/InterpAndExtrap/InterpAndFinalExtrap/Final Extrapolation/FinExtrapCtrl Generator'
    finalExtrapValidOut <= '0';
    IF Logical_Operator4_out1_2 = '1' THEN 
      tmpDiff := Add_out1;
    ELSE 
      tmpDiff := FinalExtrapRepBuff;
    END IF;
    FinalExtrapRepBuff_next <= tmpDiff;
    IF Add_out1 >= to_signed(16#00000#, 18) THEN 
      IF Add_out1 <= tmpDiff THEN 
        finalExtrapValidOut <= '1';
      END IF;
      IF Add_out1 = to_signed(16#00000#, 18) THEN 
        FinalExtrapRepBuff_next <= to_signed(16#00000#, 18);
      END IF;
    END IF;
  END PROCESS whdlmod_c104_FinExtrapCtrl_Generator_output;


  finalExtrapValidOut_1 <= finalExtrapValidOut;

  Logical_Operator5_out1_6 <= finalExtrapValidOut_1 OR Switch2_out1_3;

  Logical_Operator2_out1_3 <= initExtrapValidOut OR Logical_Operator5_out1_6;

  
  Switch1_out1_2 <= Logical_Operator2_out1_3 WHEN Compare_To_Constant3_out1_3 = '0' ELSE
      Constant_out1_3;

  
  count_30 <= numSCPSOutCounter_out1 WHEN Switch1_out1_2 = '0' ELSE
      count_value_9;

  Add1_sub_cast_2 <= signed(resize(Switch6_out1_1, 18));
  Add1_sub_cast_3 <= signed(resize(numSCPSOutCounter_out1, 18));
  Add1_out1_2 <= Add1_sub_cast_2 - Add1_sub_cast_3;

  
  Compare_To_Constant3_out1_3 <= '1' WHEN Add1_out1_2 = to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator3_out1_4 <= Compare_To_Constant3_out1_3 OR out_rsvd_6;

  
  count_31 <= count_30 WHEN Logical_Operator3_out1_4 = '0' ELSE
      count_reset_9;

  numSCPSOutCounter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        numSCPSOutCounter_out1 <= to_unsigned(16#000#, 10);
      ELSIF enb_1_2_0 = '1' THEN
        numSCPSOutCounter_out1 <= count_31;
      END IF;
    END IF;
  END PROCESS numSCPSOutCounter_process;


  Add_sub_cast_2 <= signed(resize(numSCPSOutCounter_out1, 11));
  Add_sub_cast_3 <= signed(resize(posOfFirstHighRef_1, 11));
  Add_out1_1 <= Add_sub_cast_2 - Add_sub_cast_3;

  Delay1_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_4 <= (OTHERS => to_signed(16#000#, 11));
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_4(0) <= Add_out1_1;
        Delay1_reg_4(1 TO 5) <= Delay1_reg_4(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay1_7_process;

  Delay1_out1_5 <= Delay1_reg_4(5);

  
  switch_compare_1 <= '1' WHEN Delay1_out1_5 > to_signed(16#000#, 11) ELSE
      '0';

  Constant4_out1_re <= to_signed(16#0000#, 16);
  Constant4_out1_im <= to_signed(16#0000#, 16);

  
  Switch3_out1_re <= Constant4_out1_re WHEN initExtrapValidOut = '0' ELSE
      Data2Out_re;
  
  Switch3_out1_im <= Constant4_out1_im WHEN initExtrapValidOut = '0' ELSE
      Data2Out_im;

  Delay2_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg_re <= (OTHERS => to_signed(16#0000#, 16));
        Delay2_reg_im <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg_im(0) <= Switch3_out1_im;
        Delay2_reg_im(1 TO 5) <= Delay2_reg_im(0 TO 4);
        Delay2_reg_re(0) <= Switch3_out1_re;
        Delay2_reg_re(1 TO 5) <= Delay2_reg_re(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay2_7_process;

  Delay2_out1_re_1 <= Delay2_reg_re(5);
  Delay2_out1_im_1 <= Delay2_reg_im(5);

  
  Compare_To_Constant7_out1 <= '1' WHEN Add_out1 = to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator7_out1 <= Compare_To_Constant7_out1 OR out_rsvd_6;

  Constant6_out1 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_10 <= '1';

  count_from_10 <= '0';

  count_reset_10 <= '0';

  count_32 <= binary_counter2_out1 XOR count_step_10;

  
  need_to_wrap_10 <= '1' WHEN binary_counter2_out1 = '1' ELSE
      '0';

  
  count_value_10 <= count_32 WHEN need_to_wrap_10 = '0' ELSE
      count_from_10;

  
  Switch7_out1 <= Logical_Operator4_out1_2 WHEN binary_counter2_out1 = '0' ELSE
      Constant6_out1;

  
  count_33 <= binary_counter2_out1 WHEN Switch7_out1 = '0' ELSE
      count_value_10;

  
  count_34 <= count_33 WHEN Logical_Operator7_out1 = '0' ELSE
      count_reset_10;

  binary_counter2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        binary_counter2_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        binary_counter2_out1 <= count_34;
      END IF;
    END IF;
  END PROCESS binary_counter2_process;


  Delay1_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_5 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_5(0) <= binary_counter2_out1;
        Delay1_reg_5(5 DOWNTO 1) <= Delay1_reg_5(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay1_8_process;

  Delay1_out1_6 <= Delay1_reg_5(5);

  Constant3_out1_re <= to_signed(16#0000#, 16);
  Constant3_out1_im <= to_signed(16#0000#, 16);

  
  Switch5_out1_re <= Constant3_out1_re WHEN finalExtrapValidOut = '0' ELSE
      Data2Out_re;
  
  Switch5_out1_im <= Constant3_out1_im WHEN finalExtrapValidOut = '0' ELSE
      Data2Out_im;

  Delay4_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_reg_re_1 <= (OTHERS => to_signed(16#0000#, 16));
        Delay4_reg_im_1 <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_reg_im_1(0) <= Switch5_out1_im;
        Delay4_reg_im_1(1 TO 5) <= Delay4_reg_im_1(0 TO 4);
        Delay4_reg_re_1(0) <= Switch5_out1_re;
        Delay4_reg_re_1(1 TO 5) <= Delay4_reg_re_1(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay4_3_process;

  Delay4_out1_re_2 <= Delay4_reg_re_1(5);
  Delay4_out1_im_2 <= Delay4_reg_im_1(5);

  down_counter_ctrl_const_out <= '1';

  down_counter_ctrl_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        down_counter_ctrl_delay_out <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        down_counter_ctrl_delay_out <= down_counter_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS down_counter_ctrl_delay_process;


  down_counter_Initial_Val_out <= to_unsigned(16#2#, 4);

  -- Count limited, Unsigned Counter
  --  initial value   = 2
  --  step value      = -1
  --  count to value  = 0
  count_step_11 <= to_unsigned(16#1#, 4);

  count_from_11 <= to_unsigned(16#2#, 4);

  count_reset_11 <= to_unsigned(16#2#, 4);

  count_35 <= down_counter_out1 - count_step_11;

  
  need_to_wrap_11 <= '1' WHEN down_counter_out1 = to_unsigned(16#0#, 4) ELSE
      '0';

  
  count_value_11 <= count_35 WHEN need_to_wrap_11 = '0' ELSE
      count_from_11;

  
  count_36 <= down_counter_out1 WHEN Switch2_out1_3 = '0' ELSE
      count_value_11;

  
  count_37 <= count_36 WHEN out_rsvd_6 = '0' ELSE
      count_reset_11;

  down_counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        down_counter_out <= to_unsigned(16#0#, 4);
      ELSIF enb_1_2_0 = '1' THEN
        down_counter_out <= count_37;
      END IF;
    END IF;
  END PROCESS down_counter_process;


  
  down_counter_out1 <= down_counter_Initial_Val_out WHEN down_counter_ctrl_delay_out = '0' ELSE
      down_counter_out;

  Delay3_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay3_reg_2 <= (OTHERS => to_unsigned(16#0#, 4));
      ELSIF enb_1_2_0 = '1' THEN
        Delay3_reg_2(0) <= down_counter_out1;
        Delay3_reg_2(1) <= Delay3_reg_2(0);
      END IF;
    END IF;
  END PROCESS Delay3_3_process;

  Delay3_out1_2 <= Delay3_reg_2(1);

  Delay4_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_reg_re_2 <= (OTHERS => to_signed(16#0000#, 16));
        Delay4_reg_im_2 <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_reg_im_2(0) <= Data1Out_im;
        Delay4_reg_im_2(1) <= Delay4_reg_im_2(0);
        Delay4_reg_re_2(0) <= Data1Out_re;
        Delay4_reg_re_2(1) <= Delay4_reg_re_2(0);
      END IF;
    END IF;
  END PROCESS Delay4_4_process;

  Delay4_out1_re_3 <= Delay4_reg_re_2(1);
  Delay4_out1_im_3 <= Delay4_reg_im_2(1);

  Product_cast <= signed(resize(Delay3_out1_2, 5));
  Product_mul_temp <= Product_cast * Delay4_out1_re_3;
  Product_out1_re <= Product_mul_temp(19 DOWNTO 0);
  Product_cast_1 <= signed(resize(Delay3_out1_2, 5));
  Product_mul_temp_1 <= Product_cast_1 * Delay4_out1_im_3;
  Product_out1_im <= Product_mul_temp_1(19 DOWNTO 0);

  Delay7_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay7_out1_re <= to_signed(16#00000#, 20);
        Delay7_out1_im <= to_signed(16#00000#, 20);
      ELSIF enb_1_2_0 = '1' THEN
        Delay7_out1_re <= Product_out1_re;
        Delay7_out1_im <= Product_out1_im;
      END IF;
    END IF;
  END PROCESS Delay7_1_process;


  Delay5_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay5_reg_re <= (OTHERS => to_signed(16#0000#, 16));
        Delay5_reg_im <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        Delay5_reg_im(0) <= Data2Out_im;
        Delay5_reg_im(1) <= Delay5_reg_im(0);
        Delay5_reg_re(0) <= Data2Out_re;
        Delay5_reg_re(1) <= Delay5_reg_re(0);
      END IF;
    END IF;
  END PROCESS Delay5_2_process;

  Delay5_out1_re <= Delay5_reg_re(1);
  Delay5_out1_im <= Delay5_reg_im(1);

  Constant1_out1_4 <= to_unsigned(16#1#, 4);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2
  count_step_12 <= to_unsigned(16#1#, 4);

  count_from_12 <= to_unsigned(16#0#, 4);

  count_reset_12 <= to_unsigned(16#0#, 4);

  count_38 <= up_counter_out1 + count_step_12;

  
  need_to_wrap_12 <= '1' WHEN up_counter_out1 = to_unsigned(16#2#, 4) ELSE
      '0';

  
  count_value_12 <= count_38 WHEN need_to_wrap_12 = '0' ELSE
      count_from_12;

  
  count_39 <= up_counter_out1 WHEN Switch2_out1_3 = '0' ELSE
      count_value_12;

  
  count_40 <= count_39 WHEN out_rsvd_6 = '0' ELSE
      count_reset_12;

  up_counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        up_counter_out1 <= to_unsigned(16#0#, 4);
      ELSIF enb_1_2_0 = '1' THEN
        up_counter_out1 <= count_40;
      END IF;
    END IF;
  END PROCESS up_counter_process;


  Add1_out1_3 <= resize(Constant1_out1_4, 5) + resize(up_counter_out1, 5);

  Delay6_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay6_reg <= (OTHERS => to_unsigned(16#00#, 5));
      ELSIF enb_1_2_0 = '1' THEN
        Delay6_reg(0) <= Add1_out1_3;
        Delay6_reg(1) <= Delay6_reg(0);
      END IF;
    END IF;
  END PROCESS Delay6_1_process;

  Delay6_out1 <= Delay6_reg(1);

  Product1_cast_2 <= signed(resize(Delay6_out1, 6));
  Product1_mul_temp_2 <= Delay5_out1_re * Product1_cast_2;
  Product1_out1_re <= Product1_mul_temp_2(20 DOWNTO 0);
  Product1_cast_3 <= signed(resize(Delay6_out1, 6));
  Product1_mul_temp_3 <= Delay5_out1_im * Product1_cast_3;
  Product1_out1_im <= Product1_mul_temp_3(20 DOWNTO 0);

  Delay8_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay8_out1_re <= to_signed(16#000000#, 21);
        Delay8_out1_im <= to_signed(16#000000#, 21);
      ELSIF enb_1_2_0 = '1' THEN
        Delay8_out1_re <= Product1_out1_re;
        Delay8_out1_im <= Product1_out1_im;
      END IF;
    END IF;
  END PROCESS Delay8_1_process;


  Add_add_cast <= resize(Delay7_out1_re, 22);
  Add_add_cast_1 <= resize(Delay8_out1_re, 22);
  Add_out1_re_2 <= Add_add_cast + Add_add_cast_1;
  Add_add_cast_2 <= resize(Delay7_out1_im, 22);
  Add_add_cast_3 <= resize(Delay8_out1_im, 22);
  Add_out1_im_2 <= Add_add_cast_2 + Add_add_cast_3;

  Delay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay_reg_re_1 <= (OTHERS => to_signed(16#000000#, 22));
        Delay_reg_im_1 <= (OTHERS => to_signed(16#000000#, 22));
      ELSIF enb_1_2_0 = '1' THEN
        Delay_reg_im_1(0) <= Add_out1_im_2;
        Delay_reg_im_1(1) <= Delay_reg_im_1(0);
        Delay_reg_re_1(0) <= Add_out1_re_2;
        Delay_reg_re_1(1) <= Delay_reg_re_1(0);
      END IF;
    END IF;
  END PROCESS Delay_3_process;

  Delay_out1_re_1 <= Delay_reg_re_1(1);
  Delay_out1_im_1 <= Delay_reg_im_1(1);

  --MATLAB Function 'OFDM Channel Estimator/Interpolator/InterpAndExtrap/InterpAndFinalExtrap/Data Interpolator/InterpCalculator/MulLutInterp'
  Out_value_1 <= to_unsigned(16#05555#, 17);

  Delay2_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_reg_5 <= (OTHERS => to_unsigned(16#00000#, 17));
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_reg_5(0) <= Out_value_1;
        Delay2_reg_5(1 TO 4) <= Delay2_reg_5(0 TO 3);
      END IF;
    END IF;
  END PROCESS Delay2_8_process;

  Delay2_out1_6 <= Delay2_reg_5(4);

  Product2_cast <= signed(resize(Delay2_out1_6, 18));
  Product2_mul_temp <= Delay_out1_re_1 * Product2_cast;
  Product2_out1_re <= Product2_mul_temp(38 DOWNTO 0);
  Product2_cast_1 <= signed(resize(Delay2_out1_6, 18));
  Product2_mul_temp_1 <= Delay_out1_im_1 * Product2_cast_1;
  Product2_out1_im <= Product2_mul_temp_1(38 DOWNTO 0);

  Delay1_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_out1_re_2 <= to_signed(0, 39);
        Delay1_out1_im_2 <= to_signed(0, 39);
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_out1_re_2 <= Product2_out1_re;
        Delay1_out1_im_2 <= Product2_out1_im;
      END IF;
    END IF;
  END PROCESS Delay1_9_process;


  --MATLAB Function 'OFDM Channel Estimator/Interpolator/InterpAndExtrap/InterpAndFinalExtrap/InterpOp DTConverter'
  
  dataOut_re_2 <= X"7FFF" WHEN ((Delay1_out1_re_2(38) = '0') AND (Delay1_out1_re_2(37 DOWNTO 31) /= "0000000")) OR ((Delay1_out1_re_2(38) = '0') AND (Delay1_out1_re_2(31 DOWNTO 16) = X"7FFF")) ELSE
      X"8000" WHEN (Delay1_out1_re_2(38) = '1') AND (Delay1_out1_re_2(37 DOWNTO 31) /= "1111111") ELSE
      Delay1_out1_re_2(31 DOWNTO 16) + ('0' & Delay1_out1_re_2(15));
  
  dataOut_im_2 <= X"7FFF" WHEN ((Delay1_out1_im_2(38) = '0') AND (Delay1_out1_im_2(37 DOWNTO 31) /= "0000000")) OR ((Delay1_out1_im_2(38) = '0') AND (Delay1_out1_im_2(31 DOWNTO 16) = X"7FFF")) ELSE
      X"8000" WHEN (Delay1_out1_im_2(38) = '1') AND (Delay1_out1_im_2(37 DOWNTO 31) /= "1111111") ELSE
      Delay1_out1_im_2(31 DOWNTO 16) + ('0' & Delay1_out1_im_2(15));

  
  Switch6_out1_re <= dataOut_re_2 WHEN Delay1_out1_6 = '0' ELSE
      Delay4_out1_re_2;
  
  Switch6_out1_im <= dataOut_im_2 WHEN Delay1_out1_6 = '0' ELSE
      Delay4_out1_im_2;

  
  Switch_out1_re_4 <= Delay2_out1_re_1 WHEN switch_compare_1 = '0' ELSE
      Switch6_out1_re;
  
  Switch_out1_im_4 <= Delay2_out1_im_1 WHEN switch_compare_1 = '0' ELSE
      Switch6_out1_im;

  
  Switch1_out1_re <= Delay4_out1_re_1 WHEN Constant1_out1 = '0' ELSE
      Switch_out1_re_4;
  
  Switch1_out1_im <= Delay4_out1_im_1 WHEN Constant1_out1 = '0' ELSE
      Switch_out1_im_4;

  Out1_re <= std_logic_vector(Switch1_out1_re);

  Out1_im <= std_logic_vector(Switch1_out1_im);

  Constant3_out1 <= '0';

  Delay1_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_6 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_6(0) <= Logical_Operator5_out1_5;
        Delay1_reg_6(5 DOWNTO 1) <= Delay1_reg_6(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay1_10_process;

  Delay1_out1_7 <= Delay1_reg_6(5);

  Delay4_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_reg_1(0) <= Logical_Operator2_out1_3;
        Delay4_reg_1(5 DOWNTO 1) <= Delay4_reg_1(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay4_5_process;

  Delay4_out1_1 <= Delay4_reg_1(5);

  
  Switch3_out1_3 <= Delay1_out1_7 WHEN Constant3_out1 = '0' ELSE
      Delay4_out1_1;

  Logical_Operator6_out1_5 <=  NOT out_rsvd_6;

  Delay9_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_out1_5 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Delay9_out1_5 <= Logical_Operator6_out1_5;
      END IF;
    END IF;
  END PROCESS Delay9_5_process;


  Delay1_11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_reg_7 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay1_reg_7(0) <= Logical_Operator6_out1_5;
        Delay1_reg_7(1) <= Delay1_reg_7(0);
      END IF;
    END IF;
  END PROCESS Delay1_11_process;

  Delay1_out1_8 <= Delay1_reg_7(1);

  Delay4_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_reg_2 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_reg_2(0) <= Logical_Operator6_out1_5;
        Delay4_reg_2(2 DOWNTO 1) <= Delay4_reg_2(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay4_6_process;

  Delay4_out1_2 <= Delay4_reg_2(2);

  Delay6_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay6_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay6_reg_1(0) <= Logical_Operator6_out1_5;
        Delay6_reg_1(3 DOWNTO 1) <= Delay6_reg_1(2 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay6_2_process;

  Delay6_out1_1 <= Delay6_reg_1(3);

  Delay7_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay7_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay7_reg_1(0) <= Logical_Operator6_out1_5;
        Delay7_reg_1(4 DOWNTO 1) <= Delay7_reg_1(3 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay7_2_process;

  Delay7_out1_1 <= Delay7_reg_1(4);

  Delay8_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay8_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        Delay8_reg_1(0) <= Logical_Operator6_out1_5;
        Delay8_reg_1(5 DOWNTO 1) <= Delay8_reg_1(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay8_2_process;

  Delay8_out1_1 <= Delay8_reg_1(5);

  Logical_Operator5_out1_7 <= Delay8_out1_1 AND (Delay7_out1_1 AND (Delay6_out1_1 AND (Delay4_out1_2 AND (Delay1_out1_8 AND (Switch3_out1_3 AND Delay9_out1_5)))));




  Out2 <= Logical_Operator5_out1_7;

END rtl;

