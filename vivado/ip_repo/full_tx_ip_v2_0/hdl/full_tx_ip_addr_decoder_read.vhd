-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/full_tx_ip_addr_decoder_read.vhd
-- Created: 2024-08-11 18:38:06
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_tx_ip_addr_decoder_read
-- Source Path: full_tx_ip/full_tx_ip_axi_lite/full_tx_ip_addr_decoder/full_tx_ip_addr_decoder_read
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY full_tx_ip_addr_decoder_read IS
  PORT( IPCORE_CLK                        :   IN    std_logic;  -- ufix1
        IPCORE_RESET                      :   IN    std_logic;  -- ufix1
        AXI4_ACLK                         :   IN    std_logic;
        AXI4_ARESET                       :   IN    std_logic;
        addr_sel_rd                       :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix14
        rd_enb                            :   IN    std_logic;  -- ufix1
        read_ip_timestamp                 :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
        rd_enb_ack                        :   OUT   std_logic;  -- ufix1
        s_data_read                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
        );
END full_tx_ip_addr_decoder_read;


ARCHITECTURE rtl OF full_tx_ip_addr_decoder_read IS

  -- Component Declarations
  COMPONENT full_tx_ip_pulse_sync
    PORT( i_send_clk                      :   IN    std_logic;
          i_send_rst                      :   IN    std_logic;
          i_receive_clk                   :   IN    std_logic;  -- ufix1
          i_receive_rst                   :   IN    std_logic;  -- ufix1
          i_send_pulse                    :   IN    std_logic;  -- ufix1
          o_receive_pulse                 :   OUT   std_logic;  -- ufix1
          o_pulse_ack                     :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT full_tx_ip_addr_decoder_read_registers
    PORT( IPCORE_CLK                      :   IN    std_logic;  -- ufix1
          IPCORE_RESET                    :   IN    std_logic;  -- ufix1
          rd_enb_latch                    :   IN    std_logic;  -- ufix1
          read_ip_timestamp               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          read_ip_timestamp_sync          :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_tx_ip_pulse_sync
    USE ENTITY work.full_tx_ip_pulse_sync(rtl);

  FOR ALL : full_tx_ip_addr_decoder_read_registers
    USE ENTITY work.full_tx_ip_addr_decoder_read_registers(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL s_decoder_rd_enb_latch           : std_logic;  -- ufix1
  SIGNAL rd_enb_ack_1                     : std_logic;  -- ufix1
  SIGNAL addr_sel_rd_unsigned             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL decode_sel_ip_timestamp_1_1      : std_logic;  -- ufix1
  SIGNAL const_0                          : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL read_ip_timestamp_sync           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL read_ip_timestamp_sync_unsigned  : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL const_1_1                        : std_logic;  -- ufix1
  SIGNAL read_reg_ip_timestamp            : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL decode_rd_ip_timestamp_1_1       : unsigned(31 DOWNTO 0);  -- ufix32

  ATTRIBUTE cdc_info : string;
  ATTRIBUTE dont_touch : boolean;

  ATTRIBUTE cdc_info OF read_reg_ip_timestamp : SIGNAL IS "max_delay_endpoint_ip_to_axi";
  ATTRIBUTE dont_touch OF read_reg_ip_timestamp : SIGNAL IS true;

BEGIN
  u_full_tx_ip_rd_enable_sync_inst : full_tx_ip_pulse_sync
    PORT MAP( i_send_clk => AXI4_ACLK,
              i_send_rst => AXI4_ARESET,
              i_receive_clk => IPCORE_CLK,  -- ufix1
              i_receive_rst => IPCORE_RESET,  -- ufix1
              i_send_pulse => rd_enb,  -- ufix1
              o_receive_pulse => s_decoder_rd_enb_latch,  -- ufix1
              o_pulse_ack => rd_enb_ack_1  -- ufix1
              );

  u_full_tx_ip_addr_decoder_read_registers_inst : full_tx_ip_addr_decoder_read_registers
    PORT MAP( IPCORE_CLK => IPCORE_CLK,  -- ufix1
              IPCORE_RESET => IPCORE_RESET,  -- ufix1
              rd_enb_latch => s_decoder_rd_enb_latch,  -- ufix1
              read_ip_timestamp => read_ip_timestamp,  -- ufix32
              read_ip_timestamp_sync => read_ip_timestamp_sync  -- ufix32
              );

  addr_sel_rd_unsigned <= unsigned(addr_sel_rd);

  
  decode_sel_ip_timestamp_1_1 <= '1' WHEN addr_sel_rd_unsigned = to_unsigned(16#0002#, 14) ELSE
      '0';

  const_0 <= to_unsigned(0, 32);

  read_ip_timestamp_sync_unsigned <= unsigned(read_ip_timestamp_sync);

  const_1_1 <= '1';

  enb <= const_1_1;

  reg_sync_ip_timestamp_process : PROCESS (AXI4_ACLK)
  BEGIN
    IF AXI4_ACLK'EVENT AND AXI4_ACLK = '1' THEN
      IF AXI4_ARESET = '1' THEN
        read_reg_ip_timestamp <= to_unsigned(0, 32);
      ELSIF enb = '1' AND rd_enb_ack_1 = '1' THEN
        read_reg_ip_timestamp <= read_ip_timestamp_sync_unsigned;
      END IF;
    END IF;
  END PROCESS reg_sync_ip_timestamp_process;


  
  decode_rd_ip_timestamp_1_1 <= const_0 WHEN decode_sel_ip_timestamp_1_1 = '0' ELSE
      read_reg_ip_timestamp;

  s_data_read <= std_logic_vector(decode_rd_ip_timestamp_1_1);

  rd_enb_ack <= rd_enb_ack_1;

END rtl;

