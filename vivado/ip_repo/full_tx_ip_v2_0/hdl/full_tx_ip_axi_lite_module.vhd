-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/full_tx_ip_axi_lite_module.vhd
-- Created: 2024-08-11 18:38:06
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_tx_ip_axi_lite_module
-- Source Path: full_tx_ip/full_tx_ip_axi_lite/full_tx_ip_axi_lite_module
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY full_tx_ip_axi_lite_module IS
  PORT( clk                               :   IN    std_logic;
        AXI4_Lite_ARESETN                 :   IN    std_logic;  -- ufix1
        AXI4_Lite_AWADDR                  :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16
        AXI4_Lite_AWVALID                 :   IN    std_logic;  -- ufix1
        AXI4_Lite_WDATA                   :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
        AXI4_Lite_WSTRB                   :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
        AXI4_Lite_WVALID                  :   IN    std_logic;  -- ufix1
        AXI4_Lite_BREADY                  :   IN    std_logic;  -- ufix1
        AXI4_Lite_ARADDR                  :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16
        AXI4_Lite_ARVALID                 :   IN    std_logic;  -- ufix1
        AXI4_Lite_RREADY                  :   IN    std_logic;  -- ufix1
        data_read                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
        rd_enb_ack                        :   IN    std_logic;  -- ufix1
        IPCORE_CLK                        :   IN    std_logic;  -- ufix1
        IPCORE_RESET                      :   IN    std_logic;  -- ufix1
        AXI4_Lite_AWREADY                 :   OUT   std_logic;  -- ufix1
        AXI4_Lite_WREADY                  :   OUT   std_logic;  -- ufix1
        AXI4_Lite_BRESP                   :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
        AXI4_Lite_BVALID                  :   OUT   std_logic;  -- ufix1
        AXI4_Lite_ARREADY                 :   OUT   std_logic;  -- ufix1
        AXI4_Lite_RDATA                   :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
        AXI4_Lite_RRESP                   :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
        AXI4_Lite_RVALID                  :   OUT   std_logic;  -- ufix1
        data_write                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
        addr_sel                          :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        wr_enb                            :   OUT   std_logic;  -- ufix1
        rd_enb                            :   OUT   std_logic;  -- ufix1
        reset_internal                    :   OUT   std_logic;  -- ufix1
        addr_sel_rd                       :   OUT   std_logic_vector(13 DOWNTO 0)  -- ufix14
        );
END full_tx_ip_axi_lite_module;


ARCHITECTURE rtl OF full_tx_ip_axi_lite_module IS

  -- Component Declarations
  COMPONENT full_tx_ip_write_data_sync
    PORT( i_send_clk                      :   IN    std_logic;
          i_send_rst                      :   IN    std_logic;
          i_receive_clk                   :   IN    std_logic;  -- ufix1
          i_receive_rst                   :   IN    std_logic;  -- ufix1
          i_send_pulse                    :   IN    std_logic;  -- ufix1
          i_send_data                     :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          i_send_address                  :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix14
          o_send_data                     :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
          o_send_pulse                    :   OUT   std_logic;  -- ufix1
          o_receive_data                  :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
          o_receive_address               :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
          o_decoder_enable                :   OUT   std_logic;  -- ufix1
          o_busy                          :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_tx_ip_write_data_sync
    USE ENTITY work.full_tx_ip_write_data_sync(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL reset_x                          : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL AXI4_Lite_WSTRB_unsigned         : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL wstrb_reduce                     : std_logic;  -- ufix1
  SIGNAL AXI4_Lite_AWADDR_unsigned        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL const_1                          : std_logic;  -- ufix1
  SIGNAL ar_transfer_del                  : std_logic;  -- ufix1
  SIGNAL aw_transfer                      : std_logic;  -- ufix1
  SIGNAL waddr                            : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL waddr_sel                        : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL w_transfer                       : std_logic;  -- ufix1
  SIGNAL w_transfer_and_wstrb             : std_logic;  -- ufix1
  SIGNAL wdata                            : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL w_transfer_and_wstrb_delayed     : std_logic;  -- ufix1
  SIGNAL data_write_tmp                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL waddr_decoder                    : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL busy_CDCwrite                    : std_logic;  -- ufix1
  SIGNAL axi_lite_wstate                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL axi_lite_rstate                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL axi_lite_wstate_next             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL axi_lite_rstate_next             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL AXI4_Lite_ARREADY_1              : std_logic;  -- ufix1
  SIGNAL rvalid_int                       : std_logic;  -- ufix1
  SIGNAL ar_transfer                      : std_logic;  -- ufix1
  SIGNAL ar_select                        : std_logic;  -- ufix1
  SIGNAL const_0_2                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL data_read_unsigned               : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL AXI4_Lite_RDATA_tmp              : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL strobe_addr                      : std_logic;  -- ufix1
  SIGNAL strobe_sel                       : std_logic;  -- ufix1
  SIGNAL const_zero                       : std_logic;  -- ufix1
  SIGNAL wdata_unsigned                   : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL strobe_in                        : std_logic;  -- ufix1
  SIGNAL strobe_sw                        : std_logic;  -- ufix1
  SIGNAL soft_reset                       : std_logic;  -- ufix1
  SIGNAL raddr_enb                        : std_logic;  -- ufix1
  SIGNAL AXI4_Lite_ARADDR_unsigned        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL raddr                            : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL addr_sel_rd_tmp                  : unsigned(13 DOWNTO 0);  -- ufix14

BEGIN
  u_full_tx_ip_write_data_sync_inst : full_tx_ip_write_data_sync
    PORT MAP( i_send_clk => clk,
              i_send_rst => reset_x,
              i_receive_clk => IPCORE_CLK,  -- ufix1
              i_receive_rst => IPCORE_RESET,  -- ufix1
              i_send_pulse => w_transfer_and_wstrb,  -- ufix1
              i_send_data => AXI4_Lite_WDATA,  -- ufix32
              i_send_address => std_logic_vector(waddr_sel),  -- ufix14
              o_send_data => wdata,  -- ufix32
              o_send_pulse => w_transfer_and_wstrb_delayed,  -- ufix1
              o_receive_data => data_write_tmp,  -- ufix32
              o_receive_address => waddr_decoder,  -- ufix14
              o_decoder_enable => wr_enb,  -- ufix1
              o_busy => busy_CDCwrite  -- ufix1
              );

  reset_x <=  NOT AXI4_Lite_ARESETN;

  AXI4_Lite_WSTRB_unsigned <= unsigned(AXI4_Lite_WSTRB);

  wstrb_reduce <= (AXI4_Lite_WSTRB_unsigned(3) AND AXI4_Lite_WSTRB_unsigned(2) AND AXI4_Lite_WSTRB_unsigned(1) AND AXI4_Lite_WSTRB_unsigned(0));

  AXI4_Lite_AWADDR_unsigned <= unsigned(AXI4_Lite_AWADDR);

  const_1 <= '1';

  enb <= const_1;

  reg_ar_transfer_del_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        ar_transfer_del <= '0';
      ELSIF enb = '1' THEN
        ar_transfer_del <= rd_enb_ack;
      END IF;
    END IF;
  END PROCESS reg_ar_transfer_del_process;


  reg_waddr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        waddr <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' AND aw_transfer = '1' THEN
        waddr <= AXI4_Lite_AWADDR_unsigned;
      END IF;
    END IF;
  END PROCESS reg_waddr_process;


  waddr_sel <= waddr(15 DOWNTO 2);

  w_transfer_and_wstrb <= w_transfer AND wstrb_reduce;

  axi_lite_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        axi_lite_wstate <= to_unsigned(16#00#, 8);
        axi_lite_rstate <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        axi_lite_wstate <= axi_lite_wstate_next;
        axi_lite_rstate <= axi_lite_rstate_next;
      END IF;
    END IF;
  END PROCESS axi_lite_process;

  axi_lite_output : PROCESS (AXI4_Lite_ARVALID, AXI4_Lite_AWVALID, AXI4_Lite_BREADY, AXI4_Lite_RREADY,
       AXI4_Lite_WVALID, ar_transfer_del, axi_lite_rstate, axi_lite_wstate,
       busy_CDCwrite)
    VARIABLE out0 : std_logic;
    VARIABLE out1 : std_logic;
    VARIABLE awvalid : std_logic;
    VARIABLE wvalid : std_logic;
  BEGIN
    awvalid := AXI4_Lite_AWVALID;
    wvalid := AXI4_Lite_WVALID;
    CASE axi_lite_wstate IS
      WHEN "00000000" =>
        IF axi_lite_rstate = to_unsigned(16#00000000#, 8) THEN 
          out0 := '1';
        ELSE 
          out0 := '0';
        END IF;
        out1 := '0';
        AXI4_Lite_BVALID <= '0';
        IF awvalid = '1' AND (axi_lite_rstate = to_unsigned(16#00000000#, 8)) THEN 
          IF busy_CDCwrite = '0' THEN 
            axi_lite_wstate_next <= to_unsigned(16#02#, 8);
          ELSE 
            axi_lite_wstate_next <= to_unsigned(16#01#, 8);
          END IF;
        ELSE 
          axi_lite_wstate_next <= to_unsigned(16#00#, 8);
        END IF;
      WHEN "00000001" =>
        out0 := '0';
        out1 := '0';
        AXI4_Lite_BVALID <= '0';
        IF busy_CDCwrite = '0' THEN 
          axi_lite_wstate_next <= to_unsigned(16#02#, 8);
        ELSE 
          axi_lite_wstate_next <= to_unsigned(16#01#, 8);
        END IF;
      WHEN "00000010" =>
        out0 := '0';
        out1 := '1';
        AXI4_Lite_BVALID <= '0';
        IF wvalid = '1' THEN 
          axi_lite_wstate_next <= to_unsigned(16#03#, 8);
        ELSE 
          axi_lite_wstate_next <= to_unsigned(16#02#, 8);
        END IF;
      WHEN "00000011" =>
        out0 := '0';
        out1 := '0';
        AXI4_Lite_BVALID <= '1';
        IF AXI4_Lite_BREADY /= '0' THEN 
          axi_lite_wstate_next <= to_unsigned(16#00#, 8);
        ELSE 
          axi_lite_wstate_next <= to_unsigned(16#03#, 8);
        END IF;
      WHEN OTHERS => 
        out0 := '0';
        out1 := '0';
        AXI4_Lite_BVALID <= '0';
        axi_lite_wstate_next <= to_unsigned(16#00#, 8);
    END CASE;
    CASE axi_lite_rstate IS
      WHEN "00000000" =>
        AXI4_Lite_ARREADY_1 <= hdlcoder_to_stdlogic(axi_lite_wstate = to_unsigned(16#00000000#, 8)) AND ( NOT awvalid);
        rvalid_int <= '0';
        ar_transfer <= '0';
        ar_select <= '0';
        IF ((AXI4_Lite_ARVALID /= '0') AND (axi_lite_wstate = to_unsigned(16#00000000#, 8))) AND ( NOT awvalid) = '1' THEN 
          axi_lite_rstate_next <= to_unsigned(16#01#, 8);
        ELSE 
          axi_lite_rstate_next <= to_unsigned(16#00#, 8);
        END IF;
      WHEN "00000001" =>
        AXI4_Lite_ARREADY_1 <= '0';
        rvalid_int <= '0';
        ar_transfer <= '1';
        ar_select <= '0';
        axi_lite_rstate_next <= to_unsigned(16#02#, 8);
      WHEN "00000010" =>
        AXI4_Lite_ARREADY_1 <= '0';
        rvalid_int <= '0';
        ar_transfer <= '0';
        ar_select <= '1';
        IF ar_transfer_del /= '0' THEN 
          axi_lite_rstate_next <= to_unsigned(16#03#, 8);
        ELSE 
          axi_lite_rstate_next <= to_unsigned(16#02#, 8);
        END IF;
      WHEN "00000011" =>
        AXI4_Lite_ARREADY_1 <= '0';
        rvalid_int <= '1';
        ar_transfer <= '0';
        ar_select <= '1';
        IF AXI4_Lite_RREADY /= '0' THEN 
          axi_lite_rstate_next <= to_unsigned(16#00#, 8);
        ELSE 
          axi_lite_rstate_next <= to_unsigned(16#03#, 8);
        END IF;
      WHEN OTHERS => 
        AXI4_Lite_ARREADY_1 <= '0';
        rvalid_int <= '0';
        ar_transfer <= '0';
        ar_select <= '0';
        axi_lite_rstate_next <= to_unsigned(16#00#, 8);
    END CASE;
    AXI4_Lite_AWREADY <= out0;
    AXI4_Lite_WREADY <= out1;
    aw_transfer <= awvalid AND out0;
    w_transfer <= wvalid AND out1;
  END PROCESS axi_lite_output;


  const_0_2 <= to_unsigned(16#0#, 2);

  AXI4_Lite_BRESP <= std_logic_vector(const_0_2);

  data_read_unsigned <= unsigned(data_read);

  reg_rdata_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        AXI4_Lite_RDATA_tmp <= to_unsigned(0, 32);
      ELSIF enb = '1' AND ar_transfer_del = '1' THEN
        AXI4_Lite_RDATA_tmp <= data_read_unsigned;
      END IF;
    END IF;
  END PROCESS reg_rdata_process;


  AXI4_Lite_RDATA <= std_logic_vector(AXI4_Lite_RDATA_tmp);

  AXI4_Lite_RRESP <= std_logic_vector(const_0_2);

  
  strobe_addr <= '1' WHEN waddr_sel = to_unsigned(16#0000#, 14) ELSE
      '0';

  strobe_sel <= strobe_addr AND w_transfer_and_wstrb_delayed;

  const_zero <= '0';

  wdata_unsigned <= unsigned(wdata);

  strobe_in <= wdata_unsigned(0);

  
  strobe_sw <= const_zero WHEN strobe_sel = '0' ELSE
      strobe_in;

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        soft_reset <= '0';
      ELSIF enb = '1' THEN
        soft_reset <= strobe_sw;
      END IF;
    END IF;
  END PROCESS reg_process;


  raddr_enb <= AXI4_Lite_ARREADY_1 AND AXI4_Lite_ARVALID;

  AXI4_Lite_ARADDR_unsigned <= unsigned(AXI4_Lite_ARADDR);

  reg_raddr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        raddr <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' AND raddr_enb = '1' THEN
        raddr <= AXI4_Lite_ARADDR_unsigned;
      END IF;
    END IF;
  END PROCESS reg_raddr_process;


  addr_sel_rd_tmp <= raddr(15 DOWNTO 2);

  addr_sel_rd <= std_logic_vector(addr_sel_rd_tmp);

  AXI4_Lite_ARREADY <= AXI4_Lite_ARREADY_1;

  AXI4_Lite_RVALID <= rvalid_int;

  data_write <= data_write_tmp;

  addr_sel <= waddr_decoder;

  rd_enb <= ar_transfer;

  reset_internal <= soft_reset;

END rtl;

